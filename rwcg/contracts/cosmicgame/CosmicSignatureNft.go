// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package cosmicgame

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// ICosmicSignatureNftNftInfo is an auto generated low-level Go binding around an user-defined struct.
type ICosmicSignatureNftNftInfo struct {
	Name string
	Seed *big.Int
}

// CosmicSignatureNftMetaData contains all meta data concerning the CosmicSignatureNft contract.
var CosmicSignatureNftMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"game_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ERC721EnumerableForbiddenBatchMint\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ERC721IncorrectOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ERC721InsufficientApproval\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"ERC721InvalidApprover\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"ERC721InvalidOperator\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ERC721InvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ERC721InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ERC721InvalidSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ERC721NonexistentToken\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"ERC721OutOfBoundsIndex\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"errStr\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"nftNameLength\",\"type\":\"uint256\"}],\"name\":\"TooLongNftName\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"errStr\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"callerAddress\",\"type\":\"address\"}],\"name\":\"UnauthorizedCaller\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"errStr\",\"type\":\"string\"}],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newValue\",\"type\":\"string\"}],\"name\":\"NftBaseUriChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newValue\",\"type\":\"string\"}],\"name\":\"NftGenerationScriptUriChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundNum\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftOwnerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftSeed\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"NftMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"nftName\",\"type\":\"string\"}],\"name\":\"NftNameChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"game\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId_\",\"type\":\"uint256\"}],\"name\":\"getNftInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"}],\"internalType\":\"structICosmicSignatureNft.NftInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId_\",\"type\":\"uint256\"}],\"name\":\"getNftName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId_\",\"type\":\"uint256\"}],\"name\":\"getNftSeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundNum_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftOwnerAddress_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"randomNumberSeed_\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundNum_\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"nftOwnerAddresses_\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"randomNumberSeed_\",\"type\":\"uint256\"}],\"name\":\"mintMany\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftBaseUri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftGenerationScriptUri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newValue_\",\"type\":\"string\"}],\"name\":\"setNftBaseUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newValue_\",\"type\":\"string\"}],\"name\":\"setNftGenerationScriptUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"nftName_\",\"type\":\"string\"}],\"name\":\"setNftName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x60a0604052346100465761001961001461010b565b6105dd565b61002161004b565b61345c6108578239608051818181610d7c015281816117bf0152611a28015261345c90f35b610051565b60405190565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b9061007d90610055565b810190811060018060401b0382111761009557604052565b61005f565b906100ad6100a661004b565b9283610073565b565b5f80fd5b60018060a01b031690565b6100c7906100b3565b90565b6100d3816100be565b036100da57565b5f80fd5b905051906100eb826100ca565b565b9060208282031261010657610103915f016100de565b90565b6100af565b610129613cb38038038061011e8161009a565b9283398101906100ed565b90565b60018060401b03811161014857610144602091610055565b0190565b61005f565b9061015f61015a8361012c565b61009a565b918252565b5f7f436f736d69635369676e61747572654e66740000000000000000000000000000910152565b610195601261014d565b906101a260208301610164565b565b6101ac61018b565b90565b5f7f43534e0000000000000000000000000000000000000000000000000000000000910152565b6101e0600361014d565b906101ed602083016101af565b565b6101f76101d6565b90565b5f7f5442440000000000000000000000000000000000000000000000000000000000910152565b61022b600361014d565b90610238602083016101fa565b565b610242610221565b90565b61024d61023a565b90565b5190565b634e487b7160e01b5f52602260045260245ffd5b9060016002830492168015610288575b602083101461028357565b610254565b91607f1691610278565b5f5260205f2090565b601f602091010490565b1b90565b919060086102c49102916102be5f19846102a5565b926102a5565b9181191691161790565b90565b90565b6102e86102e36102ed926102ce565b6102d1565b6102ce565b90565b90565b9190610309610304610311936102d4565b6102f0565b9083546102a9565b9055565b5f90565b61032b91610325610315565b916102f3565b565b5b818110610339575050565b806103465f600193610319565b0161032e565b9190601f811161035c575b505050565b61036861038d93610292565b9060206103748461029b565b83019310610395575b6103869061029b565b019061032d565b5f8080610357565b91506103868192905061037d565b1c90565b906103b7905f19906008026103a3565b191690565b816103c6916103a7565b906002021790565b906103d881610250565b9060018060401b038211610496576103fa826103f48554610268565b8561034c565b602090601f831160011461042e5791809161041d935f92610422575b50506103bc565b90555b565b90915001515f80610416565b601f1983169161043d85610292565b925f5b81811061047e57509160029391856001969410610464575b50505002019055610420565b610474910151601f8416906103a7565b90555f8080610458565b91936020600181928787015181550195019201610440565b61005f565b906104a5916103ce565b565b5f7f697066733a2f2f54424400000000000000000000000000000000000000000000910152565b6104d8600a61014d565b906104e5602083016104a7565b565b6104ef6104ce565b90565b6104fa6104e7565b90565b90565b61051461050f610519926104fd565b6102d1565b6100b3565b90565b61052590610500565b90565b60209181520190565b5f7f5468652070726f76696465642061646472657373206973207a65726f2e000000910152565b610565601d602092610528565b61056e81610531565b0190565b6105879060208101905f818303910152610558565b90565b806105a561059f61059a5f61051c565b6100be565b916100be565b146105b5576105b3906105d8565b565b6105bd61004b565b63eac0d38960e01b8152806105d460048201610572565b0390fd5b608052565b61062b906106026105ec6101a4565b6105f46101ef565b6105fc61073d565b9161062d565b61061461060d610245565b600b61049b565b61062661061f6104f2565b600c61049b565b61058a565b565b90610638929161063a565b565b906106459291610647565b565b906106529291610654565b565b9061065f9291610661565b565b9061066c929161066e565b565b6106859061067e61068c9461068e565b600161049b565b600261049b565b565b61069790610699565b565b6106a2906106a4565b565b6106ad906106af565b565b6106b8906106ba565b565b6106c3906106e7565b565b6106ce906100be565b9052565b91906106e5905f602085019401906106c5565b565b806107026106fc6106f75f61051c565b6100be565b916100be565b1461071257610710906107f7565b565b61073561071e5f61051c565b5f918291631e4fbdf760e01b8352600483016106d2565b0390fd5b5f90565b610745610739565b503390565b5f1c90565b60018060a01b031690565b61076661076b9161074a565b61074f565b90565b610778905461075a565b90565b5f1b90565b9061079160018060a01b039161077b565b9181191691161790565b6107af6107aa6107b4926100b3565b6102d1565b6100b3565b90565b6107c09061079b565b90565b6107cc906107b7565b90565b90565b906107e76107e26107ee926107c3565b6107cf565b8254610780565b9055565b5f0190565b6108005f61076e565b61080a825f6107d2565b9061083e6108387f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0936107c3565b916107c3565b9161084761004b565b80610851816107f2565b0390a356fe60806040526004361015610013575b611002565b61001d5f356101fc565b806301ffc9a7146101f757806306fdde03146101f2578063081812fc146101ed57806308ab7be8146101e8578063095ea7b3146101e357806311c9f23b146101de57806318160ddd146101d957806323b872dd146101d4578063278ec44f146101cf5780632f745c59146101ca57806342842e0e146101c55780634f6ccce7146101c05780636352211e146101bb5780636578f113146101b65780636cf92d10146101b157806370a08231146101ac578063715018a6146101a7578063836a1040146101a25780638da5cb5b1461019d57806395d89b4114610198578063a22cb46514610193578063b0c0fe4e1461018e578063b88d4fde14610189578063c3fe3e2814610184578063c87b56dd1461017f578063d5ec2d831461017a578063e10a312d14610175578063e985e9c514610170578063ee056e1d1461016b5763f2fde38b0361000e57610fcf565b610f9b565b610f20565b610ec0565b610e8b565b610dd3565b610d9e565b610d43565b610c33565b610bff565b610b7a565b610b45565b610b0f565b610aa2565b610a6d565b610a1a565b6109d2565b610903565b6108ce565b61089a565b610864565b61082f565b6107fb565b61078c565b610737565b61062a565b6105a0565b6103e9565b610337565b610288565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b63ffffffff60e01b1690565b61022981610214565b0361023057565b5f80fd5b9050359061024182610220565b565b9060208282031261025c57610259915f01610234565b90565b61020c565b151590565b61026f90610261565b9052565b9190610286905f60208501940190610266565b565b346102b8576102b46102a361029e366004610243565b61100a565b6102ab610202565b91829182610273565b0390f35b610208565b5f9103126102c757565b61020c565b5190565b60209181520190565b90825f9392825e0152565b601f801991011690565b61030d61031660209361031b93610304816102cc565b938480936102d0565b958691016102d9565b6102e4565b0190565b6103349160208201915f8184039101526102ee565b90565b34610367576103473660046102bd565b61036361035261105b565b61035a610202565b9182918261031f565b0390f35b610208565b90565b6103788161036c565b0361037f57565b5f80fd5b905035906103908261036f565b565b906020828203126103ab576103a8915f01610383565b90565b61020c565b60018060a01b031690565b6103c4906103b0565b90565b6103d0906103bb565b9052565b91906103e7905f602085019401906103c7565b565b34610419576104156104046103ff366004610392565b611075565b61040c610202565b918291826103d4565b0390f35b610208565b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52602260045260245ffd5b9060016002830492168015610465575b602083101461046057565b610431565b91607f1691610455565b60209181520190565b5f5260205f2090565b905f929180549061049b61049483610445565b809461046f565b916001811690815f146104f257506001146104b6575b505050565b6104c39192939450610478565b915f925b8184106104da57505001905f80806104b1565b600181602092959395548486015201910192906104c7565b92949550505060ff19168252151560200201905f80806104b1565b9061051791610481565b90565b634e487b7160e01b5f52604160045260245ffd5b90610538906102e4565b810190811067ffffffffffffffff82111761055257604052565b61051a565b9061057761057092610567610202565b9384809261050d565b038361052e565b565b905f1061058c5761058990610557565b90565b61041e565b61059d600c5f90610579565b90565b346105d0576105b03660046102bd565b6105cc6105bb610591565b6105c3610202565b9182918261031f565b0390f35b610208565b6105de816103bb565b036105e557565b5f80fd5b905035906105f6826105d5565b565b9190604083820312610620578061061461061d925f86016105e9565b93602001610383565b90565b61020c565b5f0190565b346106595761064361063d3660046105f8565b90611094565b61064b610202565b8061065581610625565b0390f35b610208565b5f80fd5b5f80fd5b90610679610672610202565b928361052e565b565b67ffffffffffffffff8111610699576106956020916102e4565b0190565b61051a565b90825f939282370152565b909291926106be6106b98261067b565b610666565b938185526020850190828401116106da576106d89261069e565b565b610662565b9080601f830112156106fd578160206106fa933591016106a9565b90565b61065e565b90602082820312610732575f82013567ffffffffffffffff811161072d5761072a92016106df565b90565b610210565b61020c565b346107655761074f61074a366004610702565b61130e565b610757610202565b8061076181610625565b0390f35b610208565b6107739061036c565b9052565b919061078a905f6020850194019061076a565b565b346107bc5761079c3660046102bd565b6107b86107a761131d565b6107af610202565b91829182610777565b0390f35b610208565b90916060828403126107f6576107f36107dc845f85016105e9565b936107ea81602086016105e9565b93604001610383565b90565b61020c565b3461082a5761081461080e3660046107c1565b91611390565b61081c610202565b8061082681610625565b0390f35b610208565b3461085f5761085b61084a610845366004610392565b611478565b610852610202565b9182918261031f565b0390f35b610208565b346108955761089161088061087a3660046105f8565b90611546565b610888610202565b91829182610777565b0390f35b610208565b346108c9576108b36108ad3660046107c1565b916115db565b6108bb610202565b806108c581610625565b0390f35b610208565b346108fe576108fa6108e96108e4366004610392565b611648565b6108f1610202565b91829182610777565b0390f35b610208565b346109335761092f61091e610919366004610392565b6116af565b610926610202565b918291826103d4565b0390f35b610208565b5f80fd5b5f80fd5b909182601f8301121561097a5781359167ffffffffffffffff831161097557602001926020830284011161097057565b61093c565b610938565b61065e565b906060828203126109cd57610996815f8401610383565b92602083013567ffffffffffffffff81116109c8576109ba836109c5928601610940565b939094604001610383565b90565b610210565b61020c565b34610a0657610a026109f16109e836600461097f565b9291909161194c565b6109f9610202565b91829182610777565b0390f35b610208565b610a17600b5f90610579565b90565b34610a4a57610a2a3660046102bd565b610a46610a35610a0b565b610a3d610202565b9182918261031f565b0390f35b610208565b90602082820312610a6857610a65915f016105e9565b90565b61020c565b34610a9d57610a99610a88610a83366004610a4f565b611979565b610a90610202565b91829182610777565b0390f35b610208565b34610ad057610ab23660046102bd565b610aba611a04565b610ac2610202565b80610acc81610625565b0390f35b610208565b9091606082840312610b0a57610b07610af0845f8501610383565b93610afe81602086016105e9565b93604001610383565b90565b61020c565b34610b4057610b3c610b2b610b25366004610ad5565b91611a7b565b610b33610202565b91829182610777565b0390f35b610208565b34610b7557610b553660046102bd565b610b71610b60611abd565b610b68610202565b918291826103d4565b0390f35b610208565b34610baa57610b8a3660046102bd565b610ba6610b95611ad2565b610b9d610202565b9182918261031f565b0390f35b610208565b610bb881610261565b03610bbf57565b5f80fd5b90503590610bd082610baf565b565b9190604083820312610bfa5780610bee610bf7925f86016105e9565b93602001610bc3565b90565b61020c565b34610c2e57610c18610c12366004610bd2565b90611ae8565b610c20610202565b80610c2a81610625565b0390f35b610208565b34610c6357610c5f610c4e610c49366004610392565b611afe565b610c56610202565b91829182610777565b0390f35b610208565b67ffffffffffffffff8111610c8657610c826020916102e4565b0190565b61051a565b90929192610ca0610c9b82610c68565b610666565b93818552602085019082840111610cbc57610cba9261069e565b565b610662565b9080601f83011215610cdf57816020610cdc93359101610c8b565b90565b61065e565b90608082820312610d3e57610cfb815f84016105e9565b92610d0982602085016105e9565b92610d178360408301610383565b92606082013567ffffffffffffffff8111610d3957610d369201610cc1565b90565b610210565b61020c565b34610d7557610d5f610d56366004610ce4565b92919091611b21565b610d67610202565b80610d7181610625565b0390f35b610208565b7f000000000000000000000000000000000000000000000000000000000000000090565b34610dce57610dae3660046102bd565b610dca610db9610d7a565b610dc1610202565b918291826103d4565b0390f35b610208565b34610e0357610dff610dee610de9366004610392565b611bc3565b610df6610202565b9182918261031f565b0390f35b610208565b610e27610e30602093610e3593610e1e816102cc565b9384809361046f565b958691016102d9565b6102e4565b0190565b610e429061036c565b9052565b90610e7090602080610e65604084015f8701518582035f870152610e08565b940151910190610e39565b90565b610e889160208201915f818403910152610e46565b90565b34610ebb57610eb7610ea6610ea1366004610392565b611ccc565b610eae610202565b91829182610e73565b0390f35b610208565b34610eee57610ed8610ed3366004610702565b611d45565b610ee0610202565b80610eea81610625565b0390f35b610208565b9190604083820312610f1b5780610f0f610f18925f86016105e9565b936020016105e9565b90565b61020c565b34610f5157610f4d610f3c610f36366004610ef3565b90611da3565b610f44610202565b91829182610273565b0390f35b610208565b919091604081840312610f9657610f6f835f8301610383565b92602082013567ffffffffffffffff8111610f9157610f8e92016106df565b90565b610210565b61020c565b34610fca57610fb4610fae366004610f56565b90611e8b565b610fbc610202565b80610fc681610625565b0390f35b610208565b34610ffd57610fe7610fe2366004610a4f565b611fad565b610fef610202565b80610ff981610625565b0390f35b610208565b5f80fd5b5f90565b611012611006565b508061102d61102763780e9d6360e01b610214565b91610214565b1490811561103a575b5090565b6110449150611fb8565b5f611036565b606090565b61105890610557565b90565b61106361104a565b5061106e600161104f565b90565b5f90565b61109190611081611071565b5061108b81612020565b5061208c565b90565b906110a891906110a26120ab565b916120b8565b565b6110bb906110b66120c8565b6112c8565b565b601f602091010490565b1b90565b919060086110e69102916110e05f19846110c7565b926110c7565b9181191691161790565b90565b61110761110261110c9261036c565b6110f0565b61036c565b90565b90565b9190611128611123611130936110f3565b61110f565b9083546110cb565b9055565b5f90565b61114a91611144611134565b91611112565b565b5b818110611158575050565b806111655f600193611138565b0161114d565b9190601f811161117b575b505050565b6111876111ac93610478565b906020611193846110bd565b830193106111b4575b6111a5906110bd565b019061114c565b5f8080611176565b91506111a58192905061119c565b1c90565b906111d6905f19906008026111c2565b191690565b816111e5916111c6565b906002021790565b906111f7816102cc565b9067ffffffffffffffff82116112b75761121b826112158554610445565b8561116b565b602090601f831160011461124f5791809161123e935f92611243575b50506111db565b90555b565b90915001515f80611237565b601f1983169161125e85610478565b925f5b81811061129f57509160029391856001969410611285575b50505002019055611241565b611295910151601f8416906111c6565b90555f8080611279565b91936020600181928787015181550195019201611261565b61051a565b906112c6916111ed565b565b6112d381600c6112bc565b6113097f27e2bd70f498920ee0fd7d8204ae8845b75dc81330e3acafa32946be3503730c91611300610202565b9182918261031f565b0390a1565b611317906110aa565b565b5490565b611325611134565b506113306009611319565b90565b90565b61134a61134561134f92611333565b6110f0565b6103b0565b90565b61135b90611336565b90565b60409061138761138e949695939661137d60608401985f8501906103c7565b602083019061076a565b01906103c7565b565b9190806113ad6113a76113a25f611352565b6103bb565b916103bb565b14611404576113c590826113bf6120ab565b91612116565b91826113d96113d3836103bb565b916103bb565b036113e357505050565b6114009091925f9384936364283d7b60e01b85526004850161135e565b0390fd5b6114276114105f611352565b5f918291633250574960e11b8352600483016103d4565b0390fd5b634e487b7160e01b5f52603260045260245ffd5b506801000000000000000090565b90565b6114598161143f565b8210156114735761146b60029161144d565b910201905f90565b61142b565b5f6114906114979261148861104a565b50600d611450565b500161104f565b90565b9160206114bb9294936114b460408201965f8301906103c7565b019061076a565b565b6114d16114cc6114d6926103b0565b6110f0565b6103b0565b90565b6114e2906114bd565b90565b6114ee906114d9565b90565b906114fb906114e5565b5f5260205260405f2090565b90611511906110f3565b5f5260205260405f2090565b5f1c90565b90565b6115316115369161151d565b611522565b90565b6115439054611525565b90565b61154e611134565b508161156a61156461155f84611979565b61036c565b9161036c565b101561158f5761158c916115826115879260076114f1565b611507565b611539565b90565b6115a95f92839263295f44f760e21b84526004840161149a565b0390fd5b906115bf6115ba8361067b565b610666565b918252565b6115cd5f6115ad565b90565b6115d86115c4565b90565b916115ef92916115e96115d0565b92611b21565b565b5f5260205f2090565b61160381611319565b82101561161d576116156001916115f1565b910201905f90565b61142b565b61163290600861163793026111c2565b611522565b90565b906116459154611622565b90565b611650611134565b508061166b61166561166061131d565b61036c565b9161036c565b10156116885761167f6116859160096115fa565b9061163a565b90565b6116915f611352565b6116ab5f92839263295f44f760e21b84526004840161149a565b0390fd5b6116c1906116bb611071565b50612020565b90565b60407f6d6574686f642e00000000000000000000000000000000000000000000000000917f4f6e6c792074686520436f736d69635369676e617475726547616d6520636f6e5f8201527f7472616374206973207065726d697474656420746f2063616c6c20746869732060208201520152565b61174460476060926102d0565b61174d816116c4565b0190565b919061177490602061176c604086018681035f880152611737565b9401906103c7565b565b1561177e5750565b6117a09061178a610202565b91829163ced50f6760e01b835260048301611751565b0390fd5b906117fd949392916117f86117b76120ab565b6117e96117e37f00000000000000000000000000000000000000000000000000000000000000006103bb565b916103bb565b146117f26120ab565b90611776565b611870565b90565b5090565b61181861181361181d92611333565b6110f0565b61036c565b90565b9190811015611830576020020190565b61142b565b3561183f816105d5565b90565b90565b61185961185461185e92611842565b6110f0565b61036c565b90565b600161186d910161036c565b90565b929091925061187d611134565b93611889848390611800565b61189b6118955f611804565b9161036c565b116118a8575b5050505090565b9091929493506118d5836118ce6118c988866118c35f611804565b91611820565b611835565b8391612225565b936118e06001611845565b915b826118ff6118f96118f48a8890611800565b61036c565b9161036c565b101561193d5761191161193791611861565b926119318661192a6119258b898691611820565b611835565b8691612225565b50611861565b916118e2565b5094505050505f8080806118a1565b9061196093929161195b611134565b6117a4565b90565b9061196d906114e5565b5f5260205260405f2090565b611981611134565b508061199d6119976119925f611352565b6103bb565b916103bb565b146119b8576119b06119b5916004611963565b611539565b90565b6119db6119c45f611352565b5f9182916322718ad960e21b8352600483016103d4565b0390fd5b6119e76120c8565b6119ef6119f1565b565b611a026119fd5f611352565b6122fd565b565b611a0c6119df565b565b90611a66939291611a61611a206120ab565b611a52611a4c7f00000000000000000000000000000000000000000000000000000000000000006103bb565b916103bb565b14611a5b6120ab565b90611776565b611a69565b90565b90611a78939150919091612225565b90565b90611a8e9291611a89611134565b611a0e565b90565b60018060a01b031690565b611aa8611aad9161151d565b611a91565b90565b611aba9054611a9c565b90565b611ac5611071565b50611acf5f611ab0565b90565b611ada61104a565b50611ae5600261104f565b90565b611afc91611af46120ab565b9190916123a1565b565b6001611b17611b1e92611b0f611134565b50600d611450565b5001611539565b90565b91611b3d939192611b3481858491611390565b9290919261256b565b565b90565b5190565b611b4e6115c4565b90565b905090565b611b7b611b7292602092611b69816102cc565b94858093611b51565b938491016102d9565b0190565b611b8d90611b939392611b56565b90611b56565b90565b611bb59291611bc191611ba7610202565b948592602084019283611b7f565b9081038252038361052e565b565b611bcb61104a565b50611bd581612020565b50611bde6126c6565b90611bf0611beb83611b3f565b611b42565b611c02611bfc5f611804565b9161036c565b115f14611c2057611c16611c1c929161277a565b90611b96565b5b90565b5050611c2a611b46565b611c1d565b611c396040610666565b90565b606090565b5f90565b611c4d611c2f565b9060208083611c5a611c3c565b815201611c65611c41565b81525050565b611c73611c45565b90565b52565b90611c839061036c565b9052565b90611cbe611cb56001611c98611c2f565b94611caf611ca75f8301610557565b5f8801611c76565b01611539565b60208401611c79565b565b611cc990611c87565b90565b611ce3611ce991611cdb611c6b565b50600d611450565b50611cc0565b90565b611cfd90611cf86120c8565b611cff565b565b611d0a81600b6112bc565b611d407fbdfd815215fcee5bb949c941ab489c7ead076a7c8acd3527cd1b50f613ac67e691611d37610202565b9182918261031f565b0390a1565b611d4e90611cec565b565b90611d5a906114e5565b5f5260205260405f2090565b90611d70906114e5565b5f5260205260405f2090565b60ff1690565b611d8e611d939161151d565b611d7c565b90565b611da09054611d82565b90565b611dc891611dbe611dc392611db6611006565b506006611d50565b611d66565b611d96565b90565b90565b611de2611ddd611de792611dcb565b6110f0565b61036c565b90565b611df46020611dce565b90565b5f7f4e4654206e616d6520697320746f6f206c6f6e672e0000000000000000000000910152565b611e2b60156020926102d0565b611e3481611df7565b0190565b9190611e5b906020611e53604086018681035f880152611e1e565b94019061076a565b565b15611e655750565b611e8790611e71610202565b91829163c237685160e01b835260048301611e38565b0390fd5b611ea6611e9782612823565b611e9f6120ab565b8391612842565b611eec611eba611eb584611b3f565b611b42565b611ed3611ecd611ec8611dea565b61036c565b9161036c565b1115611ee6611ee185611b3f565b611b42565b90611e5d565b611f04825f611efd600d8590611450565b50016112bc565b611f43611f317fa14cfb0fe69c0b55eaaa4d9400bdba2a72e1860cade89c2a8a055e6cfde8936d926110f3565b92611f3a610202565b9182918261031f565b0390a2565b611f5990611f546120c8565b611f5b565b565b80611f76611f70611f6b5f611352565b6103bb565b916103bb565b14611f8657611f84906122fd565b565b611fa9611f925f611352565b5f918291631e4fbdf760e01b8352600483016103d4565b0390fd5b611fb690611f48565b565b611fc0611006565b5080611fdb611fd56380ac58cd60e01b610214565b91610214565b148015611fff575b908115611fef575b5090565b611ff991506128be565b5f611feb565b508061201a612014635b5e139f60e01b610214565b91610214565b14611fe3565b612028611071565b5061203281612823565b908161204e6120486120435f611352565b6103bb565b916103bb565b14612057575090565b612072905f918291637e27328960e01b835260048301610777565b0390fd5b90612080906110f3565b5f5260205260405f2090565b6120a36120a89161209b611071565b506005612076565b611ab0565b90565b6120b3611071565b503390565b916120c692916001926128e4565b565b6120d0611abd565b6120e96120e36120de6120ab565b6103bb565b916103bb565b036120f057565b6121126120fb6120ab565b5f91829163118cdaa760e01b8352600483016103d4565b0390fd5b909161212f90612124611071565b508290849091612a3c565b918261214b6121456121405f611352565b6103bb565b916103bb565b145f146121bc5761215b81612cec565b5b8161217761217161216c5f611352565b6103bb565b916103bb565b145f1461218c576121889150612ded565b5b90565b8261219f612199846103bb565b916103bb565b036121ac575b5050612189565b6121b591612d58565b5f806121a5565b826121cf6121c9846103bb565b916103bb565b036121da575b61215c565b6121e5838290612bbd565b6121d5565b5f1b90565b906121fb5f19916121ea565b9181191691161790565b9061221a612215612221926110f3565b61110f565b82546121ef565b9055565b9061222e611134565b5061224b61223a61131d565b93612246838690612e84565b612f28565b9161226583600161225e600d8890611450565b5001612205565b9083916122b96122a76122a161229b7fc2115f21464937bfdcd1560f96f0e20b70e88accbdcd1069084c80c8797ef106946110f3565b946114e5565b946110f3565b946122b0610202565b91829182610777565b0390a490565b906122d060018060a01b03916121ea565b9181191691161790565b90565b906122f26122ed6122f9926114e5565b6122da565b82546122bf565b9055565b6123065f611ab0565b612310825f6122dd565b9061234461233e7f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0936114e5565b916114e5565b9161234d610202565b8061235781610625565b0390a3565b9061236860ff916121ea565b9181191691161790565b61237b90610261565b90565b90565b9061239661239161239d92612372565b61237e565b825461235c565b9055565b919091826123bf6123b96123b45f611352565b6103bb565b916103bb565b14612433576123e3826123de6123d760068590611d50565b8690611d66565b612381565b91909161242e61241c6124167f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31936114e5565b936114e5565b93612425610202565b91829182610273565b0390a3565b61244e835f918291630b61174360e31b8352600483016103d4565b0390fd5b61245b906114bd565b90565b61246790612452565b90565b612473906114d9565b90565b60e01b90565b9050519061248982610220565b565b906020828203126124a4576124a1915f0161247c565b90565b61020c565b60209181520190565b6124d16124da6020936124df936124c881611b42565b938480936124a9565b958691016102d9565b6102e4565b0190565b90926125169061250c612523969461250260808601975f8701906103c7565b60208501906103c7565b604083019061076a565b60608184039101526124b2565b90565b9061253861253383610c68565b610666565b918252565b606090565b3d5f1461255d576125523d612526565b903d5f602084013e5b565b61256561253d565b9061255b565b929092833b61258261257c5f611804565b9161036c565b1161258e575b50505050565b6020916125ce5f6125a66125a18861245e565b61246a565b926125d963150b7a02916125b86120ab565b96986125c2610202565b998a9889978896612476565b8652600486016124e3565b03925af180915f92612696575b50155f146126535750600161260057505b5f808080612588565b612608612542565b9061261282611b42565b61262461261e5f611804565b9161036c565b145f1461264a57612646905f918291633250574960e11b8352600483016103d4565b0390fd5b50805190602001fd5b61266c612666630a85bd0160e11b610214565b91610214565b0361267757506125f7565b612692905f918291633250574960e11b8352600483016103d4565b0390fd5b6126b891925060203d81116126bf575b6126b0818361052e565b81019061248b565b905f6125e6565b503d6126a6565b6126ce61104a565b506126d9600b61104f565b90565b906126e7910161036c565b90565b369037565b906127146126fc836115ad565b9260208061270a869361067b565b92019103906126ea565b565b6001612722910361036c565b90565b90565b61273c61273761274192612725565b6110f0565b61036c565b90565b634e487b7160e01b5f52601260045260245ffd5b61276461276a9161036c565b9161036c565b908115612775570490565b612744565b61278261104a565b5061279f61278f82613092565b6127996001611845565b906126dc565b906127a9826126ef565b916127b2611134565b5060200182015b60011561281c576127cc6127f891612716565b916f181899199a1a9b1b9c1cb0b131b232b360811b600a82061a83536127f2600a612728565b90612758565b8061280b6128055f611804565b9161036c565b1461281657906127b9565b50505b90565b5050612819565b61283a61283f91612832611071565b506003612076565b611ab0565b90565b612857612851828486916132f3565b15610261565b61286057505050565b61287a61287461286f5f611352565b6103bb565b916103bb565b145f146128a05761289c825f918291637e27328960e01b835260048301610777565b0390fd5b6128ba5f92839263177e802f60e01b84526004840161149a565b0390fd5b6128c6611006565b506128e06128da6301ffc9a760e01b610214565b91610214565b1490565b919092808015612a0b575b61290d575b50509061290661290b92916005612076565b6122dd565b565b61291684612020565b918061293261292c6129275f611352565b6103bb565b916103bb565b1415806129f0575b806129d6575b6129b75750916129069161290b949361295c575b5091926128f4565b81849061299b61299561298f7f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925956114e5565b926114e5565b926110f3565b926129a4610202565b806129ae81610625565b0390a45f612954565b6129d2905f91829163a9fbf51f60e01b8352600483016103d4565b0390fd5b506129eb6129e5848390611da3565b15610261565b612940565b5082612a046129fe836103bb565b916103bb565b141561293a565b5081612a27612a21612a1c5f611352565b6103bb565b916103bb565b14156128ef565b90612a39910361036c565b90565b90612a45611071565b50612a4f81612823565b9280612a6b612a65612a605f611352565b6103bb565b916103bb565b03612baa575b5082612a8d612a87612a825f611352565b6103bb565b916103bb565b03612b56575b81612aae612aa8612aa35f611352565b6103bb565b916103bb565b03612b20575b612ac982612ac460038490612076565b6122dd565b8291612b07612b01612afb7fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef956114e5565b926114e5565b926110f3565b92612b10610202565b80612b1a81610625565b0390a490565b612b51612b2d6001611845565b612b4b612b3c60048690611963565b91612b4683611539565b6126dc565b90612205565b612ab4565b612b74612b625f611352565b82612b6c5f611352565b905f926128e4565b612ba5612b816001611845565b612b9f612b9060048790611963565b91612b9a83611539565b612a2e565b90612205565b612a93565b612bb79084908391612842565b5f612a71565b612c20612c2592612c1b5f93612c1485612c0f612bd984611979565b95612bee612be960088390611507565b611539565b80612c01612bfb8a61036c565b9161036c565b03612c27575b506008611507565b611138565b60076114f1565b611507565b611138565b565b612c7990612c74612c4c612c47612c4060078b906114f1565b8c90611507565b611539565b91612c6c83612c67612c6060078d906114f1565b8490611507565b612205565b916008611507565b612205565b5f612c07565b90565b5f5260205f2090565b5490565b612c9881612c8b565b821015612cb257612caa600191612c82565b910201905f90565b61142b565b9081549168010000000000000000831015612ce75782612cdf916001612ce595018155612c8f565b90611112565b565b61051a565b612d1d90612d0e612cfd6009611319565b612d09600a8490611507565b612205565b612d186009612c7f565b612cb7565b565b634e487b7160e01b5f52601160045260245ffd5b612d42612d489193929361036c565b9261036c565b8203918211612d5357565b612d1f565b90612da3612da892612d9b612d7f612d6f83611979565b612d796001611845565b90612d33565b91612d96612d8f869260076114f1565b8490611507565b612205565b916008611507565b612205565b565b634e487b7160e01b5f52603160045260245ffd5b612dc781612c8b565b8015612de8576001900390612de5612ddf8383612c8f565b90611138565b55565b612daa565b5f612e6b612e7092612e64612e15612e056009611319565b612e0f6001611845565b90612d33565b612e5f612e40612e3a612e32612e2d600a8890611507565b611539565b9360096115fa565b9061163a565b91612e5783612e51600984906115fa565b90611112565b91600a611507565b612205565b600a611507565b611138565b612e82612e7d6009612c7f565b612dbe565b565b9081612ea0612e9a612e955f611352565b6103bb565b916103bb565b14612f0157612eb99190612eb35f611352565b91612116565b612ed3612ecd612ec85f611352565b6103bb565b916103bb565b03612eda57565b612efd612ee65f611352565b5f9182916339e3563760e11b8352600483016103d4565b0390fd5b612f24612f0d5f611352565b5f918291633250574960e11b8352600483016103d4565b0390fd5b612f3a90612f34611134565b506133d5565b90565b90565b612f54612f4f612f5992612f3d565b6110f0565b61036c565b90565b90565b612f73612f6e612f7892612f5c565b6110f0565b61036c565b90565b90565b612f92612f8d612f9792612f7b565b6110f0565b61036c565b90565b90565b612fb1612fac612fb692612f9a565b6110f0565b61036c565b90565b90565b612fd0612fcb612fd592612fb9565b6110f0565b61036c565b90565b90565b612fef612fea612ff492612fd8565b6110f0565b61036c565b90565b90565b61300e61300961301392612ff7565b6110f0565b61036c565b90565b90565b61302d61302861303292613016565b6110f0565b61036c565b90565b90565b61304c61304761305192613035565b6110f0565b61036c565b90565b90565b61306b61306661307092613054565b6110f0565b61036c565b90565b90565b61308a61308561308f92613073565b6110f0565b61036c565b90565b61309a611134565b506130a45f611804565b90806130d36130cd7a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000612f40565b9161036c565b10156132ab575b806130fb6130f56d04ee2d6d415b85acef8100000000612f7e565b9161036c565b1015613270575b8061311c613116662386f26fc10000612f9d565b9161036c565b101561323c575b8061313a6131346305f5e100612fdb565b9161036c565b101561320b575b80613156613150612710613019565b9161036c565b10156131dc575b8061317161316b6064613057565b9161036c565b10156131ae575b61318b613185600a612728565b9161036c565b1015613195575b90565b6131a9906131a36001611845565b906126dc565b613192565b6131c56131d6916131bf6064613057565b90612758565b916131d06002613076565b906126dc565b90613178565b6131f4613205916131ee612710613019565b90612758565b916131ff6004613038565b906126dc565b9061315d565b6132256132369161321f6305f5e100612fdb565b90612758565b916132306008612ffa565b906126dc565b90613141565b61325961326a91613253662386f26fc10000612f9d565b90612758565b916132646010612fbc565b906126dc565b90613123565b6132946132a59161328e6d04ee2d6d415b85acef8100000000612f7e565b90612758565b9161329f6020611dce565b906126dc565b90613102565b6132dc6132ed916132d67a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000612f40565b90612758565b916132e76040612f5f565b906126dc565b906130da565b91906132fd611006565b508061331961331361330e5f611352565b6103bb565b916103bb565b14159283613328575b50505090565b809192935061333f613339846103bb565b916103bb565b14908115613381575b5091821561335b575b50505f8080613322565b61337991925061336d6133739161208c565b926103bb565b916103bb565b145f80613351565b61338d91508290611da3565b5f613348565b90565b6133a26133a79161036c565b613393565b9052565b6133b781602093613396565b0190565b60200190565b6133cd6133d29161151d565b6110f3565b90565b6133fc61340b613423926133e7611134565b506133f0610202565b928391602083016133ab565b6020820181038252038261052e565b61341d61341782611b42565b916133bb565b206133c1565b9056fea2646970667358221220d3f8932127daa5b6e37e2d83f4a3ad8a78123daa9fae27f44d8d853fff1d5d2964736f6c634300081c0033",
}

// CosmicSignatureNftABI is the input ABI used to generate the binding from.
// Deprecated: Use CosmicSignatureNftMetaData.ABI instead.
var CosmicSignatureNftABI = CosmicSignatureNftMetaData.ABI

// CosmicSignatureNftBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use CosmicSignatureNftMetaData.Bin instead.
var CosmicSignatureNftBin = CosmicSignatureNftMetaData.Bin

// DeployCosmicSignatureNft deploys a new Ethereum contract, binding an instance of CosmicSignatureNft to it.
func DeployCosmicSignatureNft(auth *bind.TransactOpts, backend bind.ContractBackend, game_ common.Address) (common.Address, *types.Transaction, *CosmicSignatureNft, error) {
	parsed, err := CosmicSignatureNftMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(CosmicSignatureNftBin), backend, game_)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &CosmicSignatureNft{CosmicSignatureNftCaller: CosmicSignatureNftCaller{contract: contract}, CosmicSignatureNftTransactor: CosmicSignatureNftTransactor{contract: contract}, CosmicSignatureNftFilterer: CosmicSignatureNftFilterer{contract: contract}}, nil
}

// CosmicSignatureNft is an auto generated Go binding around an Ethereum contract.
type CosmicSignatureNft struct {
	CosmicSignatureNftCaller     // Read-only binding to the contract
	CosmicSignatureNftTransactor // Write-only binding to the contract
	CosmicSignatureNftFilterer   // Log filterer for contract events
}

// CosmicSignatureNftCaller is an auto generated read-only Go binding around an Ethereum contract.
type CosmicSignatureNftCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CosmicSignatureNftTransactor is an auto generated write-only Go binding around an Ethereum contract.
type CosmicSignatureNftTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CosmicSignatureNftFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type CosmicSignatureNftFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CosmicSignatureNftSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type CosmicSignatureNftSession struct {
	Contract     *CosmicSignatureNft // Generic contract binding to set the session for
	CallOpts     bind.CallOpts       // Call options to use throughout this session
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// CosmicSignatureNftCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type CosmicSignatureNftCallerSession struct {
	Contract *CosmicSignatureNftCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts             // Call options to use throughout this session
}

// CosmicSignatureNftTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type CosmicSignatureNftTransactorSession struct {
	Contract     *CosmicSignatureNftTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts             // Transaction auth options to use throughout this session
}

// CosmicSignatureNftRaw is an auto generated low-level Go binding around an Ethereum contract.
type CosmicSignatureNftRaw struct {
	Contract *CosmicSignatureNft // Generic contract binding to access the raw methods on
}

// CosmicSignatureNftCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type CosmicSignatureNftCallerRaw struct {
	Contract *CosmicSignatureNftCaller // Generic read-only contract binding to access the raw methods on
}

// CosmicSignatureNftTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type CosmicSignatureNftTransactorRaw struct {
	Contract *CosmicSignatureNftTransactor // Generic write-only contract binding to access the raw methods on
}

// NewCosmicSignatureNft creates a new instance of CosmicSignatureNft, bound to a specific deployed contract.
func NewCosmicSignatureNft(address common.Address, backend bind.ContractBackend) (*CosmicSignatureNft, error) {
	contract, err := bindCosmicSignatureNft(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNft{CosmicSignatureNftCaller: CosmicSignatureNftCaller{contract: contract}, CosmicSignatureNftTransactor: CosmicSignatureNftTransactor{contract: contract}, CosmicSignatureNftFilterer: CosmicSignatureNftFilterer{contract: contract}}, nil
}

// NewCosmicSignatureNftCaller creates a new read-only instance of CosmicSignatureNft, bound to a specific deployed contract.
func NewCosmicSignatureNftCaller(address common.Address, caller bind.ContractCaller) (*CosmicSignatureNftCaller, error) {
	contract, err := bindCosmicSignatureNft(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftCaller{contract: contract}, nil
}

// NewCosmicSignatureNftTransactor creates a new write-only instance of CosmicSignatureNft, bound to a specific deployed contract.
func NewCosmicSignatureNftTransactor(address common.Address, transactor bind.ContractTransactor) (*CosmicSignatureNftTransactor, error) {
	contract, err := bindCosmicSignatureNft(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftTransactor{contract: contract}, nil
}

// NewCosmicSignatureNftFilterer creates a new log filterer instance of CosmicSignatureNft, bound to a specific deployed contract.
func NewCosmicSignatureNftFilterer(address common.Address, filterer bind.ContractFilterer) (*CosmicSignatureNftFilterer, error) {
	contract, err := bindCosmicSignatureNft(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftFilterer{contract: contract}, nil
}

// bindCosmicSignatureNft binds a generic wrapper to an already deployed contract.
func bindCosmicSignatureNft(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := CosmicSignatureNftMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_CosmicSignatureNft *CosmicSignatureNftRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _CosmicSignatureNft.Contract.CosmicSignatureNftCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_CosmicSignatureNft *CosmicSignatureNftRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.CosmicSignatureNftTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_CosmicSignatureNft *CosmicSignatureNftRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.CosmicSignatureNftTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_CosmicSignatureNft *CosmicSignatureNftCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _CosmicSignatureNft.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_CosmicSignatureNft *CosmicSignatureNftTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_CosmicSignatureNft *CosmicSignatureNftTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.contract.Transact(opts, method, params...)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) BalanceOf(opts *bind.CallOpts, owner common.Address) (*big.Int, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "balanceOf", owner)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftSession) BalanceOf(owner common.Address) (*big.Int, error) {
	return _CosmicSignatureNft.Contract.BalanceOf(&_CosmicSignatureNft.CallOpts, owner)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) BalanceOf(owner common.Address) (*big.Int, error) {
	return _CosmicSignatureNft.Contract.BalanceOf(&_CosmicSignatureNft.CallOpts, owner)
}

// Game is a free data retrieval call binding the contract method 0xc3fe3e28.
//
// Solidity: function game() view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) Game(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "game")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Game is a free data retrieval call binding the contract method 0xc3fe3e28.
//
// Solidity: function game() view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftSession) Game() (common.Address, error) {
	return _CosmicSignatureNft.Contract.Game(&_CosmicSignatureNft.CallOpts)
}

// Game is a free data retrieval call binding the contract method 0xc3fe3e28.
//
// Solidity: function game() view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) Game() (common.Address, error) {
	return _CosmicSignatureNft.Contract.Game(&_CosmicSignatureNft.CallOpts)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) GetApproved(opts *bind.CallOpts, tokenId *big.Int) (common.Address, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "getApproved", tokenId)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftSession) GetApproved(tokenId *big.Int) (common.Address, error) {
	return _CosmicSignatureNft.Contract.GetApproved(&_CosmicSignatureNft.CallOpts, tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) GetApproved(tokenId *big.Int) (common.Address, error) {
	return _CosmicSignatureNft.Contract.GetApproved(&_CosmicSignatureNft.CallOpts, tokenId)
}

// GetNftInfo is a free data retrieval call binding the contract method 0xd5ec2d83.
//
// Solidity: function getNftInfo(uint256 nftId_) view returns((string,uint256))
func (_CosmicSignatureNft *CosmicSignatureNftCaller) GetNftInfo(opts *bind.CallOpts, nftId_ *big.Int) (ICosmicSignatureNftNftInfo, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "getNftInfo", nftId_)

	if err != nil {
		return *new(ICosmicSignatureNftNftInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(ICosmicSignatureNftNftInfo)).(*ICosmicSignatureNftNftInfo)

	return out0, err

}

// GetNftInfo is a free data retrieval call binding the contract method 0xd5ec2d83.
//
// Solidity: function getNftInfo(uint256 nftId_) view returns((string,uint256))
func (_CosmicSignatureNft *CosmicSignatureNftSession) GetNftInfo(nftId_ *big.Int) (ICosmicSignatureNftNftInfo, error) {
	return _CosmicSignatureNft.Contract.GetNftInfo(&_CosmicSignatureNft.CallOpts, nftId_)
}

// GetNftInfo is a free data retrieval call binding the contract method 0xd5ec2d83.
//
// Solidity: function getNftInfo(uint256 nftId_) view returns((string,uint256))
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) GetNftInfo(nftId_ *big.Int) (ICosmicSignatureNftNftInfo, error) {
	return _CosmicSignatureNft.Contract.GetNftInfo(&_CosmicSignatureNft.CallOpts, nftId_)
}

// GetNftName is a free data retrieval call binding the contract method 0x278ec44f.
//
// Solidity: function getNftName(uint256 nftId_) view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) GetNftName(opts *bind.CallOpts, nftId_ *big.Int) (string, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "getNftName", nftId_)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// GetNftName is a free data retrieval call binding the contract method 0x278ec44f.
//
// Solidity: function getNftName(uint256 nftId_) view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftSession) GetNftName(nftId_ *big.Int) (string, error) {
	return _CosmicSignatureNft.Contract.GetNftName(&_CosmicSignatureNft.CallOpts, nftId_)
}

// GetNftName is a free data retrieval call binding the contract method 0x278ec44f.
//
// Solidity: function getNftName(uint256 nftId_) view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) GetNftName(nftId_ *big.Int) (string, error) {
	return _CosmicSignatureNft.Contract.GetNftName(&_CosmicSignatureNft.CallOpts, nftId_)
}

// GetNftSeed is a free data retrieval call binding the contract method 0xb0c0fe4e.
//
// Solidity: function getNftSeed(uint256 nftId_) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) GetNftSeed(opts *bind.CallOpts, nftId_ *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "getNftSeed", nftId_)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetNftSeed is a free data retrieval call binding the contract method 0xb0c0fe4e.
//
// Solidity: function getNftSeed(uint256 nftId_) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftSession) GetNftSeed(nftId_ *big.Int) (*big.Int, error) {
	return _CosmicSignatureNft.Contract.GetNftSeed(&_CosmicSignatureNft.CallOpts, nftId_)
}

// GetNftSeed is a free data retrieval call binding the contract method 0xb0c0fe4e.
//
// Solidity: function getNftSeed(uint256 nftId_) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) GetNftSeed(nftId_ *big.Int) (*big.Int, error) {
	return _CosmicSignatureNft.Contract.GetNftSeed(&_CosmicSignatureNft.CallOpts, nftId_)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) IsApprovedForAll(opts *bind.CallOpts, owner common.Address, operator common.Address) (bool, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "isApprovedForAll", owner, operator)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_CosmicSignatureNft *CosmicSignatureNftSession) IsApprovedForAll(owner common.Address, operator common.Address) (bool, error) {
	return _CosmicSignatureNft.Contract.IsApprovedForAll(&_CosmicSignatureNft.CallOpts, owner, operator)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) IsApprovedForAll(owner common.Address, operator common.Address) (bool, error) {
	return _CosmicSignatureNft.Contract.IsApprovedForAll(&_CosmicSignatureNft.CallOpts, owner, operator)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) Name(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "name")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftSession) Name() (string, error) {
	return _CosmicSignatureNft.Contract.Name(&_CosmicSignatureNft.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) Name() (string, error) {
	return _CosmicSignatureNft.Contract.Name(&_CosmicSignatureNft.CallOpts)
}

// NftBaseUri is a free data retrieval call binding the contract method 0x6cf92d10.
//
// Solidity: function nftBaseUri() view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) NftBaseUri(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "nftBaseUri")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// NftBaseUri is a free data retrieval call binding the contract method 0x6cf92d10.
//
// Solidity: function nftBaseUri() view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftSession) NftBaseUri() (string, error) {
	return _CosmicSignatureNft.Contract.NftBaseUri(&_CosmicSignatureNft.CallOpts)
}

// NftBaseUri is a free data retrieval call binding the contract method 0x6cf92d10.
//
// Solidity: function nftBaseUri() view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) NftBaseUri() (string, error) {
	return _CosmicSignatureNft.Contract.NftBaseUri(&_CosmicSignatureNft.CallOpts)
}

// NftGenerationScriptUri is a free data retrieval call binding the contract method 0x08ab7be8.
//
// Solidity: function nftGenerationScriptUri() view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) NftGenerationScriptUri(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "nftGenerationScriptUri")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// NftGenerationScriptUri is a free data retrieval call binding the contract method 0x08ab7be8.
//
// Solidity: function nftGenerationScriptUri() view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftSession) NftGenerationScriptUri() (string, error) {
	return _CosmicSignatureNft.Contract.NftGenerationScriptUri(&_CosmicSignatureNft.CallOpts)
}

// NftGenerationScriptUri is a free data retrieval call binding the contract method 0x08ab7be8.
//
// Solidity: function nftGenerationScriptUri() view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) NftGenerationScriptUri() (string, error) {
	return _CosmicSignatureNft.Contract.NftGenerationScriptUri(&_CosmicSignatureNft.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftSession) Owner() (common.Address, error) {
	return _CosmicSignatureNft.Contract.Owner(&_CosmicSignatureNft.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) Owner() (common.Address, error) {
	return _CosmicSignatureNft.Contract.Owner(&_CosmicSignatureNft.CallOpts)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) OwnerOf(opts *bind.CallOpts, tokenId *big.Int) (common.Address, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "ownerOf", tokenId)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftSession) OwnerOf(tokenId *big.Int) (common.Address, error) {
	return _CosmicSignatureNft.Contract.OwnerOf(&_CosmicSignatureNft.CallOpts, tokenId)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) OwnerOf(tokenId *big.Int) (common.Address, error) {
	return _CosmicSignatureNft.Contract.OwnerOf(&_CosmicSignatureNft.CallOpts, tokenId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "supportsInterface", interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_CosmicSignatureNft *CosmicSignatureNftSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _CosmicSignatureNft.Contract.SupportsInterface(&_CosmicSignatureNft.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _CosmicSignatureNft.Contract.SupportsInterface(&_CosmicSignatureNft.CallOpts, interfaceId)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) Symbol(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "symbol")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftSession) Symbol() (string, error) {
	return _CosmicSignatureNft.Contract.Symbol(&_CosmicSignatureNft.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) Symbol() (string, error) {
	return _CosmicSignatureNft.Contract.Symbol(&_CosmicSignatureNft.CallOpts)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 index) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) TokenByIndex(opts *bind.CallOpts, index *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "tokenByIndex", index)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 index) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftSession) TokenByIndex(index *big.Int) (*big.Int, error) {
	return _CosmicSignatureNft.Contract.TokenByIndex(&_CosmicSignatureNft.CallOpts, index)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 index) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) TokenByIndex(index *big.Int) (*big.Int, error) {
	return _CosmicSignatureNft.Contract.TokenByIndex(&_CosmicSignatureNft.CallOpts, index)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address owner, uint256 index) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) TokenOfOwnerByIndex(opts *bind.CallOpts, owner common.Address, index *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "tokenOfOwnerByIndex", owner, index)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address owner, uint256 index) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftSession) TokenOfOwnerByIndex(owner common.Address, index *big.Int) (*big.Int, error) {
	return _CosmicSignatureNft.Contract.TokenOfOwnerByIndex(&_CosmicSignatureNft.CallOpts, owner, index)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address owner, uint256 index) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) TokenOfOwnerByIndex(owner common.Address, index *big.Int) (*big.Int, error) {
	return _CosmicSignatureNft.Contract.TokenOfOwnerByIndex(&_CosmicSignatureNft.CallOpts, owner, index)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 tokenId) view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) TokenURI(opts *bind.CallOpts, tokenId *big.Int) (string, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "tokenURI", tokenId)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 tokenId) view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftSession) TokenURI(tokenId *big.Int) (string, error) {
	return _CosmicSignatureNft.Contract.TokenURI(&_CosmicSignatureNft.CallOpts, tokenId)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 tokenId) view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) TokenURI(tokenId *big.Int) (string, error) {
	return _CosmicSignatureNft.Contract.TokenURI(&_CosmicSignatureNft.CallOpts, tokenId)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftSession) TotalSupply() (*big.Int, error) {
	return _CosmicSignatureNft.Contract.TotalSupply(&_CosmicSignatureNft.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) TotalSupply() (*big.Int, error) {
	return _CosmicSignatureNft.Contract.TotalSupply(&_CosmicSignatureNft.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) Approve(opts *bind.TransactOpts, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "approve", to, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_CosmicSignatureNft *CosmicSignatureNftSession) Approve(to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.Approve(&_CosmicSignatureNft.TransactOpts, to, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) Approve(to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.Approve(&_CosmicSignatureNft.TransactOpts, to, tokenId)
}

// Mint is a paid mutator transaction binding the contract method 0x836a1040.
//
// Solidity: function mint(uint256 roundNum_, address nftOwnerAddress_, uint256 randomNumberSeed_) returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) Mint(opts *bind.TransactOpts, roundNum_ *big.Int, nftOwnerAddress_ common.Address, randomNumberSeed_ *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "mint", roundNum_, nftOwnerAddress_, randomNumberSeed_)
}

// Mint is a paid mutator transaction binding the contract method 0x836a1040.
//
// Solidity: function mint(uint256 roundNum_, address nftOwnerAddress_, uint256 randomNumberSeed_) returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftSession) Mint(roundNum_ *big.Int, nftOwnerAddress_ common.Address, randomNumberSeed_ *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.Mint(&_CosmicSignatureNft.TransactOpts, roundNum_, nftOwnerAddress_, randomNumberSeed_)
}

// Mint is a paid mutator transaction binding the contract method 0x836a1040.
//
// Solidity: function mint(uint256 roundNum_, address nftOwnerAddress_, uint256 randomNumberSeed_) returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) Mint(roundNum_ *big.Int, nftOwnerAddress_ common.Address, randomNumberSeed_ *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.Mint(&_CosmicSignatureNft.TransactOpts, roundNum_, nftOwnerAddress_, randomNumberSeed_)
}

// MintMany is a paid mutator transaction binding the contract method 0x6578f113.
//
// Solidity: function mintMany(uint256 roundNum_, address[] nftOwnerAddresses_, uint256 randomNumberSeed_) returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) MintMany(opts *bind.TransactOpts, roundNum_ *big.Int, nftOwnerAddresses_ []common.Address, randomNumberSeed_ *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "mintMany", roundNum_, nftOwnerAddresses_, randomNumberSeed_)
}

// MintMany is a paid mutator transaction binding the contract method 0x6578f113.
//
// Solidity: function mintMany(uint256 roundNum_, address[] nftOwnerAddresses_, uint256 randomNumberSeed_) returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftSession) MintMany(roundNum_ *big.Int, nftOwnerAddresses_ []common.Address, randomNumberSeed_ *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.MintMany(&_CosmicSignatureNft.TransactOpts, roundNum_, nftOwnerAddresses_, randomNumberSeed_)
}

// MintMany is a paid mutator transaction binding the contract method 0x6578f113.
//
// Solidity: function mintMany(uint256 roundNum_, address[] nftOwnerAddresses_, uint256 randomNumberSeed_) returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) MintMany(roundNum_ *big.Int, nftOwnerAddresses_ []common.Address, randomNumberSeed_ *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.MintMany(&_CosmicSignatureNft.TransactOpts, roundNum_, nftOwnerAddresses_, randomNumberSeed_)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_CosmicSignatureNft *CosmicSignatureNftSession) RenounceOwnership() (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.RenounceOwnership(&_CosmicSignatureNft.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.RenounceOwnership(&_CosmicSignatureNft.TransactOpts)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) SafeTransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "safeTransferFrom", from, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_CosmicSignatureNft *CosmicSignatureNftSession) SafeTransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SafeTransferFrom(&_CosmicSignatureNft.TransactOpts, from, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) SafeTransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SafeTransferFrom(&_CosmicSignatureNft.TransactOpts, from, to, tokenId)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) SafeTransferFrom0(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "safeTransferFrom0", from, to, tokenId, data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_CosmicSignatureNft *CosmicSignatureNftSession) SafeTransferFrom0(from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SafeTransferFrom0(&_CosmicSignatureNft.TransactOpts, from, to, tokenId, data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) SafeTransferFrom0(from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SafeTransferFrom0(&_CosmicSignatureNft.TransactOpts, from, to, tokenId, data)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) SetApprovalForAll(opts *bind.TransactOpts, operator common.Address, approved bool) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "setApprovalForAll", operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_CosmicSignatureNft *CosmicSignatureNftSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SetApprovalForAll(&_CosmicSignatureNft.TransactOpts, operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SetApprovalForAll(&_CosmicSignatureNft.TransactOpts, operator, approved)
}

// SetNftBaseUri is a paid mutator transaction binding the contract method 0xe10a312d.
//
// Solidity: function setNftBaseUri(string newValue_) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) SetNftBaseUri(opts *bind.TransactOpts, newValue_ string) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "setNftBaseUri", newValue_)
}

// SetNftBaseUri is a paid mutator transaction binding the contract method 0xe10a312d.
//
// Solidity: function setNftBaseUri(string newValue_) returns()
func (_CosmicSignatureNft *CosmicSignatureNftSession) SetNftBaseUri(newValue_ string) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SetNftBaseUri(&_CosmicSignatureNft.TransactOpts, newValue_)
}

// SetNftBaseUri is a paid mutator transaction binding the contract method 0xe10a312d.
//
// Solidity: function setNftBaseUri(string newValue_) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) SetNftBaseUri(newValue_ string) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SetNftBaseUri(&_CosmicSignatureNft.TransactOpts, newValue_)
}

// SetNftGenerationScriptUri is a paid mutator transaction binding the contract method 0x11c9f23b.
//
// Solidity: function setNftGenerationScriptUri(string newValue_) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) SetNftGenerationScriptUri(opts *bind.TransactOpts, newValue_ string) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "setNftGenerationScriptUri", newValue_)
}

// SetNftGenerationScriptUri is a paid mutator transaction binding the contract method 0x11c9f23b.
//
// Solidity: function setNftGenerationScriptUri(string newValue_) returns()
func (_CosmicSignatureNft *CosmicSignatureNftSession) SetNftGenerationScriptUri(newValue_ string) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SetNftGenerationScriptUri(&_CosmicSignatureNft.TransactOpts, newValue_)
}

// SetNftGenerationScriptUri is a paid mutator transaction binding the contract method 0x11c9f23b.
//
// Solidity: function setNftGenerationScriptUri(string newValue_) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) SetNftGenerationScriptUri(newValue_ string) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SetNftGenerationScriptUri(&_CosmicSignatureNft.TransactOpts, newValue_)
}

// SetNftName is a paid mutator transaction binding the contract method 0xee056e1d.
//
// Solidity: function setNftName(uint256 nftId_, string nftName_) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) SetNftName(opts *bind.TransactOpts, nftId_ *big.Int, nftName_ string) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "setNftName", nftId_, nftName_)
}

// SetNftName is a paid mutator transaction binding the contract method 0xee056e1d.
//
// Solidity: function setNftName(uint256 nftId_, string nftName_) returns()
func (_CosmicSignatureNft *CosmicSignatureNftSession) SetNftName(nftId_ *big.Int, nftName_ string) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SetNftName(&_CosmicSignatureNft.TransactOpts, nftId_, nftName_)
}

// SetNftName is a paid mutator transaction binding the contract method 0xee056e1d.
//
// Solidity: function setNftName(uint256 nftId_, string nftName_) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) SetNftName(nftId_ *big.Int, nftName_ string) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SetNftName(&_CosmicSignatureNft.TransactOpts, nftId_, nftName_)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "transferFrom", from, to, tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_CosmicSignatureNft *CosmicSignatureNftSession) TransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.TransferFrom(&_CosmicSignatureNft.TransactOpts, from, to, tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) TransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.TransferFrom(&_CosmicSignatureNft.TransactOpts, from, to, tokenId)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_CosmicSignatureNft *CosmicSignatureNftSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.TransferOwnership(&_CosmicSignatureNft.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.TransferOwnership(&_CosmicSignatureNft.TransactOpts, newOwner)
}

// CosmicSignatureNftApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the CosmicSignatureNft contract.
type CosmicSignatureNftApprovalIterator struct {
	Event *CosmicSignatureNftApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureNftApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureNftApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureNftApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureNftApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureNftApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureNftApproval represents a Approval event raised by the CosmicSignatureNft contract.
type CosmicSignatureNftApproval struct {
	Owner    common.Address
	Approved common.Address
	TokenId  *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, approved []common.Address, tokenId []*big.Int) (*CosmicSignatureNftApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.FilterLogs(opts, "Approval", ownerRule, approvedRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftApprovalIterator{contract: _CosmicSignatureNft.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *CosmicSignatureNftApproval, owner []common.Address, approved []common.Address, tokenId []*big.Int) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.WatchLogs(opts, "Approval", ownerRule, approvedRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureNftApproval)
				if err := _CosmicSignatureNft.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) ParseApproval(log types.Log) (*CosmicSignatureNftApproval, error) {
	event := new(CosmicSignatureNftApproval)
	if err := _CosmicSignatureNft.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureNftApprovalForAllIterator is returned from FilterApprovalForAll and is used to iterate over the raw logs and unpacked data for ApprovalForAll events raised by the CosmicSignatureNft contract.
type CosmicSignatureNftApprovalForAllIterator struct {
	Event *CosmicSignatureNftApprovalForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureNftApprovalForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureNftApprovalForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureNftApprovalForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureNftApprovalForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureNftApprovalForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureNftApprovalForAll represents a ApprovalForAll event raised by the CosmicSignatureNft contract.
type CosmicSignatureNftApprovalForAll struct {
	Owner    common.Address
	Operator common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApprovalForAll is a free log retrieval operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) FilterApprovalForAll(opts *bind.FilterOpts, owner []common.Address, operator []common.Address) (*CosmicSignatureNftApprovalForAllIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.FilterLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftApprovalForAllIterator{contract: _CosmicSignatureNft.contract, event: "ApprovalForAll", logs: logs, sub: sub}, nil
}

// WatchApprovalForAll is a free log subscription operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *CosmicSignatureNftApprovalForAll, owner []common.Address, operator []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.WatchLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureNftApprovalForAll)
				if err := _CosmicSignatureNft.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApprovalForAll is a log parse operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) ParseApprovalForAll(log types.Log) (*CosmicSignatureNftApprovalForAll, error) {
	event := new(CosmicSignatureNftApprovalForAll)
	if err := _CosmicSignatureNft.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureNftNftBaseUriChangedIterator is returned from FilterNftBaseUriChanged and is used to iterate over the raw logs and unpacked data for NftBaseUriChanged events raised by the CosmicSignatureNft contract.
type CosmicSignatureNftNftBaseUriChangedIterator struct {
	Event *CosmicSignatureNftNftBaseUriChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureNftNftBaseUriChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureNftNftBaseUriChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureNftNftBaseUriChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureNftNftBaseUriChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureNftNftBaseUriChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureNftNftBaseUriChanged represents a NftBaseUriChanged event raised by the CosmicSignatureNft contract.
type CosmicSignatureNftNftBaseUriChanged struct {
	NewValue string
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterNftBaseUriChanged is a free log retrieval operation binding the contract event 0xbdfd815215fcee5bb949c941ab489c7ead076a7c8acd3527cd1b50f613ac67e6.
//
// Solidity: event NftBaseUriChanged(string newValue)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) FilterNftBaseUriChanged(opts *bind.FilterOpts) (*CosmicSignatureNftNftBaseUriChangedIterator, error) {

	logs, sub, err := _CosmicSignatureNft.contract.FilterLogs(opts, "NftBaseUriChanged")
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftNftBaseUriChangedIterator{contract: _CosmicSignatureNft.contract, event: "NftBaseUriChanged", logs: logs, sub: sub}, nil
}

// WatchNftBaseUriChanged is a free log subscription operation binding the contract event 0xbdfd815215fcee5bb949c941ab489c7ead076a7c8acd3527cd1b50f613ac67e6.
//
// Solidity: event NftBaseUriChanged(string newValue)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) WatchNftBaseUriChanged(opts *bind.WatchOpts, sink chan<- *CosmicSignatureNftNftBaseUriChanged) (event.Subscription, error) {

	logs, sub, err := _CosmicSignatureNft.contract.WatchLogs(opts, "NftBaseUriChanged")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureNftNftBaseUriChanged)
				if err := _CosmicSignatureNft.contract.UnpackLog(event, "NftBaseUriChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseNftBaseUriChanged is a log parse operation binding the contract event 0xbdfd815215fcee5bb949c941ab489c7ead076a7c8acd3527cd1b50f613ac67e6.
//
// Solidity: event NftBaseUriChanged(string newValue)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) ParseNftBaseUriChanged(log types.Log) (*CosmicSignatureNftNftBaseUriChanged, error) {
	event := new(CosmicSignatureNftNftBaseUriChanged)
	if err := _CosmicSignatureNft.contract.UnpackLog(event, "NftBaseUriChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureNftNftGenerationScriptUriChangedIterator is returned from FilterNftGenerationScriptUriChanged and is used to iterate over the raw logs and unpacked data for NftGenerationScriptUriChanged events raised by the CosmicSignatureNft contract.
type CosmicSignatureNftNftGenerationScriptUriChangedIterator struct {
	Event *CosmicSignatureNftNftGenerationScriptUriChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureNftNftGenerationScriptUriChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureNftNftGenerationScriptUriChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureNftNftGenerationScriptUriChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureNftNftGenerationScriptUriChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureNftNftGenerationScriptUriChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureNftNftGenerationScriptUriChanged represents a NftGenerationScriptUriChanged event raised by the CosmicSignatureNft contract.
type CosmicSignatureNftNftGenerationScriptUriChanged struct {
	NewValue string
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterNftGenerationScriptUriChanged is a free log retrieval operation binding the contract event 0x27e2bd70f498920ee0fd7d8204ae8845b75dc81330e3acafa32946be3503730c.
//
// Solidity: event NftGenerationScriptUriChanged(string newValue)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) FilterNftGenerationScriptUriChanged(opts *bind.FilterOpts) (*CosmicSignatureNftNftGenerationScriptUriChangedIterator, error) {

	logs, sub, err := _CosmicSignatureNft.contract.FilterLogs(opts, "NftGenerationScriptUriChanged")
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftNftGenerationScriptUriChangedIterator{contract: _CosmicSignatureNft.contract, event: "NftGenerationScriptUriChanged", logs: logs, sub: sub}, nil
}

// WatchNftGenerationScriptUriChanged is a free log subscription operation binding the contract event 0x27e2bd70f498920ee0fd7d8204ae8845b75dc81330e3acafa32946be3503730c.
//
// Solidity: event NftGenerationScriptUriChanged(string newValue)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) WatchNftGenerationScriptUriChanged(opts *bind.WatchOpts, sink chan<- *CosmicSignatureNftNftGenerationScriptUriChanged) (event.Subscription, error) {

	logs, sub, err := _CosmicSignatureNft.contract.WatchLogs(opts, "NftGenerationScriptUriChanged")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureNftNftGenerationScriptUriChanged)
				if err := _CosmicSignatureNft.contract.UnpackLog(event, "NftGenerationScriptUriChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseNftGenerationScriptUriChanged is a log parse operation binding the contract event 0x27e2bd70f498920ee0fd7d8204ae8845b75dc81330e3acafa32946be3503730c.
//
// Solidity: event NftGenerationScriptUriChanged(string newValue)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) ParseNftGenerationScriptUriChanged(log types.Log) (*CosmicSignatureNftNftGenerationScriptUriChanged, error) {
	event := new(CosmicSignatureNftNftGenerationScriptUriChanged)
	if err := _CosmicSignatureNft.contract.UnpackLog(event, "NftGenerationScriptUriChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureNftNftMintedIterator is returned from FilterNftMinted and is used to iterate over the raw logs and unpacked data for NftMinted events raised by the CosmicSignatureNft contract.
type CosmicSignatureNftNftMintedIterator struct {
	Event *CosmicSignatureNftNftMinted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureNftNftMintedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureNftNftMinted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureNftNftMinted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureNftNftMintedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureNftNftMintedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureNftNftMinted represents a NftMinted event raised by the CosmicSignatureNft contract.
type CosmicSignatureNftNftMinted struct {
	RoundNum        *big.Int
	NftOwnerAddress common.Address
	NftSeed         *big.Int
	NftId           *big.Int
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterNftMinted is a free log retrieval operation binding the contract event 0xc2115f21464937bfdcd1560f96f0e20b70e88accbdcd1069084c80c8797ef106.
//
// Solidity: event NftMinted(uint256 indexed roundNum, address indexed nftOwnerAddress, uint256 nftSeed, uint256 indexed nftId)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) FilterNftMinted(opts *bind.FilterOpts, roundNum []*big.Int, nftOwnerAddress []common.Address, nftId []*big.Int) (*CosmicSignatureNftNftMintedIterator, error) {

	var roundNumRule []interface{}
	for _, roundNumItem := range roundNum {
		roundNumRule = append(roundNumRule, roundNumItem)
	}
	var nftOwnerAddressRule []interface{}
	for _, nftOwnerAddressItem := range nftOwnerAddress {
		nftOwnerAddressRule = append(nftOwnerAddressRule, nftOwnerAddressItem)
	}

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.FilterLogs(opts, "NftMinted", roundNumRule, nftOwnerAddressRule, nftIdRule)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftNftMintedIterator{contract: _CosmicSignatureNft.contract, event: "NftMinted", logs: logs, sub: sub}, nil
}

// WatchNftMinted is a free log subscription operation binding the contract event 0xc2115f21464937bfdcd1560f96f0e20b70e88accbdcd1069084c80c8797ef106.
//
// Solidity: event NftMinted(uint256 indexed roundNum, address indexed nftOwnerAddress, uint256 nftSeed, uint256 indexed nftId)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) WatchNftMinted(opts *bind.WatchOpts, sink chan<- *CosmicSignatureNftNftMinted, roundNum []*big.Int, nftOwnerAddress []common.Address, nftId []*big.Int) (event.Subscription, error) {

	var roundNumRule []interface{}
	for _, roundNumItem := range roundNum {
		roundNumRule = append(roundNumRule, roundNumItem)
	}
	var nftOwnerAddressRule []interface{}
	for _, nftOwnerAddressItem := range nftOwnerAddress {
		nftOwnerAddressRule = append(nftOwnerAddressRule, nftOwnerAddressItem)
	}

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.WatchLogs(opts, "NftMinted", roundNumRule, nftOwnerAddressRule, nftIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureNftNftMinted)
				if err := _CosmicSignatureNft.contract.UnpackLog(event, "NftMinted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseNftMinted is a log parse operation binding the contract event 0xc2115f21464937bfdcd1560f96f0e20b70e88accbdcd1069084c80c8797ef106.
//
// Solidity: event NftMinted(uint256 indexed roundNum, address indexed nftOwnerAddress, uint256 nftSeed, uint256 indexed nftId)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) ParseNftMinted(log types.Log) (*CosmicSignatureNftNftMinted, error) {
	event := new(CosmicSignatureNftNftMinted)
	if err := _CosmicSignatureNft.contract.UnpackLog(event, "NftMinted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureNftNftNameChangedIterator is returned from FilterNftNameChanged and is used to iterate over the raw logs and unpacked data for NftNameChanged events raised by the CosmicSignatureNft contract.
type CosmicSignatureNftNftNameChangedIterator struct {
	Event *CosmicSignatureNftNftNameChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureNftNftNameChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureNftNftNameChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureNftNftNameChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureNftNftNameChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureNftNftNameChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureNftNftNameChanged represents a NftNameChanged event raised by the CosmicSignatureNft contract.
type CosmicSignatureNftNftNameChanged struct {
	NftId   *big.Int
	NftName string
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterNftNameChanged is a free log retrieval operation binding the contract event 0xa14cfb0fe69c0b55eaaa4d9400bdba2a72e1860cade89c2a8a055e6cfde8936d.
//
// Solidity: event NftNameChanged(uint256 indexed nftId, string nftName)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) FilterNftNameChanged(opts *bind.FilterOpts, nftId []*big.Int) (*CosmicSignatureNftNftNameChangedIterator, error) {

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.FilterLogs(opts, "NftNameChanged", nftIdRule)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftNftNameChangedIterator{contract: _CosmicSignatureNft.contract, event: "NftNameChanged", logs: logs, sub: sub}, nil
}

// WatchNftNameChanged is a free log subscription operation binding the contract event 0xa14cfb0fe69c0b55eaaa4d9400bdba2a72e1860cade89c2a8a055e6cfde8936d.
//
// Solidity: event NftNameChanged(uint256 indexed nftId, string nftName)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) WatchNftNameChanged(opts *bind.WatchOpts, sink chan<- *CosmicSignatureNftNftNameChanged, nftId []*big.Int) (event.Subscription, error) {

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.WatchLogs(opts, "NftNameChanged", nftIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureNftNftNameChanged)
				if err := _CosmicSignatureNft.contract.UnpackLog(event, "NftNameChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseNftNameChanged is a log parse operation binding the contract event 0xa14cfb0fe69c0b55eaaa4d9400bdba2a72e1860cade89c2a8a055e6cfde8936d.
//
// Solidity: event NftNameChanged(uint256 indexed nftId, string nftName)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) ParseNftNameChanged(log types.Log) (*CosmicSignatureNftNftNameChanged, error) {
	event := new(CosmicSignatureNftNftNameChanged)
	if err := _CosmicSignatureNft.contract.UnpackLog(event, "NftNameChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureNftOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the CosmicSignatureNft contract.
type CosmicSignatureNftOwnershipTransferredIterator struct {
	Event *CosmicSignatureNftOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureNftOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureNftOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureNftOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureNftOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureNftOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureNftOwnershipTransferred represents a OwnershipTransferred event raised by the CosmicSignatureNft contract.
type CosmicSignatureNftOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*CosmicSignatureNftOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftOwnershipTransferredIterator{contract: _CosmicSignatureNft.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *CosmicSignatureNftOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureNftOwnershipTransferred)
				if err := _CosmicSignatureNft.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) ParseOwnershipTransferred(log types.Log) (*CosmicSignatureNftOwnershipTransferred, error) {
	event := new(CosmicSignatureNftOwnershipTransferred)
	if err := _CosmicSignatureNft.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureNftTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the CosmicSignatureNft contract.
type CosmicSignatureNftTransferIterator struct {
	Event *CosmicSignatureNftTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureNftTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureNftTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureNftTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureNftTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureNftTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureNftTransfer represents a Transfer event raised by the CosmicSignatureNft contract.
type CosmicSignatureNftTransfer struct {
	From    common.Address
	To      common.Address
	TokenId *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenId []*big.Int) (*CosmicSignatureNftTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.FilterLogs(opts, "Transfer", fromRule, toRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftTransferIterator{contract: _CosmicSignatureNft.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *CosmicSignatureNftTransfer, from []common.Address, to []common.Address, tokenId []*big.Int) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.WatchLogs(opts, "Transfer", fromRule, toRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureNftTransfer)
				if err := _CosmicSignatureNft.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) ParseTransfer(log types.Log) (*CosmicSignatureNftTransfer, error) {
	event := new(CosmicSignatureNftTransfer)
	if err := _CosmicSignatureNft.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureNftMetaData contains all meta data concerning the ICosmicSignatureNft contract.
var ICosmicSignatureNftMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newValue\",\"type\":\"string\"}],\"name\":\"NftBaseUriChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newValue\",\"type\":\"string\"}],\"name\":\"NftGenerationScriptUriChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundNum\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftOwnerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftSeed\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"NftMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"nftName\",\"type\":\"string\"}],\"name\":\"NftNameChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId_\",\"type\":\"uint256\"}],\"name\":\"getNftInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"}],\"internalType\":\"structICosmicSignatureNft.NftInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId_\",\"type\":\"uint256\"}],\"name\":\"getNftName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId_\",\"type\":\"uint256\"}],\"name\":\"getNftSeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundNum_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftOwnerAddress_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"randomNumberSeed_\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundNum_\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"nftOwnerAddresses_\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"randomNumberSeed_\",\"type\":\"uint256\"}],\"name\":\"mintMany\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newValue_\",\"type\":\"string\"}],\"name\":\"setNftBaseUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newValue_\",\"type\":\"string\"}],\"name\":\"setNftGenerationScriptUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"nftName_\",\"type\":\"string\"}],\"name\":\"setNftName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// ICosmicSignatureNftABI is the input ABI used to generate the binding from.
// Deprecated: Use ICosmicSignatureNftMetaData.ABI instead.
var ICosmicSignatureNftABI = ICosmicSignatureNftMetaData.ABI

// ICosmicSignatureNft is an auto generated Go binding around an Ethereum contract.
type ICosmicSignatureNft struct {
	ICosmicSignatureNftCaller     // Read-only binding to the contract
	ICosmicSignatureNftTransactor // Write-only binding to the contract
	ICosmicSignatureNftFilterer   // Log filterer for contract events
}

// ICosmicSignatureNftCaller is an auto generated read-only Go binding around an Ethereum contract.
type ICosmicSignatureNftCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ICosmicSignatureNftTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ICosmicSignatureNftTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ICosmicSignatureNftFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ICosmicSignatureNftFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ICosmicSignatureNftSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ICosmicSignatureNftSession struct {
	Contract     *ICosmicSignatureNft // Generic contract binding to set the session for
	CallOpts     bind.CallOpts        // Call options to use throughout this session
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// ICosmicSignatureNftCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ICosmicSignatureNftCallerSession struct {
	Contract *ICosmicSignatureNftCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts              // Call options to use throughout this session
}

// ICosmicSignatureNftTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ICosmicSignatureNftTransactorSession struct {
	Contract     *ICosmicSignatureNftTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts              // Transaction auth options to use throughout this session
}

// ICosmicSignatureNftRaw is an auto generated low-level Go binding around an Ethereum contract.
type ICosmicSignatureNftRaw struct {
	Contract *ICosmicSignatureNft // Generic contract binding to access the raw methods on
}

// ICosmicSignatureNftCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ICosmicSignatureNftCallerRaw struct {
	Contract *ICosmicSignatureNftCaller // Generic read-only contract binding to access the raw methods on
}

// ICosmicSignatureNftTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ICosmicSignatureNftTransactorRaw struct {
	Contract *ICosmicSignatureNftTransactor // Generic write-only contract binding to access the raw methods on
}

// NewICosmicSignatureNft creates a new instance of ICosmicSignatureNft, bound to a specific deployed contract.
func NewICosmicSignatureNft(address common.Address, backend bind.ContractBackend) (*ICosmicSignatureNft, error) {
	contract, err := bindICosmicSignatureNft(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureNft{ICosmicSignatureNftCaller: ICosmicSignatureNftCaller{contract: contract}, ICosmicSignatureNftTransactor: ICosmicSignatureNftTransactor{contract: contract}, ICosmicSignatureNftFilterer: ICosmicSignatureNftFilterer{contract: contract}}, nil
}

// NewICosmicSignatureNftCaller creates a new read-only instance of ICosmicSignatureNft, bound to a specific deployed contract.
func NewICosmicSignatureNftCaller(address common.Address, caller bind.ContractCaller) (*ICosmicSignatureNftCaller, error) {
	contract, err := bindICosmicSignatureNft(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureNftCaller{contract: contract}, nil
}

// NewICosmicSignatureNftTransactor creates a new write-only instance of ICosmicSignatureNft, bound to a specific deployed contract.
func NewICosmicSignatureNftTransactor(address common.Address, transactor bind.ContractTransactor) (*ICosmicSignatureNftTransactor, error) {
	contract, err := bindICosmicSignatureNft(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureNftTransactor{contract: contract}, nil
}

// NewICosmicSignatureNftFilterer creates a new log filterer instance of ICosmicSignatureNft, bound to a specific deployed contract.
func NewICosmicSignatureNftFilterer(address common.Address, filterer bind.ContractFilterer) (*ICosmicSignatureNftFilterer, error) {
	contract, err := bindICosmicSignatureNft(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureNftFilterer{contract: contract}, nil
}

// bindICosmicSignatureNft binds a generic wrapper to an already deployed contract.
func bindICosmicSignatureNft(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ICosmicSignatureNftMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ICosmicSignatureNft *ICosmicSignatureNftRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ICosmicSignatureNft.Contract.ICosmicSignatureNftCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ICosmicSignatureNft *ICosmicSignatureNftRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.ICosmicSignatureNftTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ICosmicSignatureNft *ICosmicSignatureNftRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.ICosmicSignatureNftTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ICosmicSignatureNft *ICosmicSignatureNftCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ICosmicSignatureNft.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.contract.Transact(opts, method, params...)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256 balance)
func (_ICosmicSignatureNft *ICosmicSignatureNftCaller) BalanceOf(opts *bind.CallOpts, owner common.Address) (*big.Int, error) {
	var out []interface{}
	err := _ICosmicSignatureNft.contract.Call(opts, &out, "balanceOf", owner)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256 balance)
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) BalanceOf(owner common.Address) (*big.Int, error) {
	return _ICosmicSignatureNft.Contract.BalanceOf(&_ICosmicSignatureNft.CallOpts, owner)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256 balance)
func (_ICosmicSignatureNft *ICosmicSignatureNftCallerSession) BalanceOf(owner common.Address) (*big.Int, error) {
	return _ICosmicSignatureNft.Contract.BalanceOf(&_ICosmicSignatureNft.CallOpts, owner)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address operator)
func (_ICosmicSignatureNft *ICosmicSignatureNftCaller) GetApproved(opts *bind.CallOpts, tokenId *big.Int) (common.Address, error) {
	var out []interface{}
	err := _ICosmicSignatureNft.contract.Call(opts, &out, "getApproved", tokenId)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address operator)
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) GetApproved(tokenId *big.Int) (common.Address, error) {
	return _ICosmicSignatureNft.Contract.GetApproved(&_ICosmicSignatureNft.CallOpts, tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address operator)
func (_ICosmicSignatureNft *ICosmicSignatureNftCallerSession) GetApproved(tokenId *big.Int) (common.Address, error) {
	return _ICosmicSignatureNft.Contract.GetApproved(&_ICosmicSignatureNft.CallOpts, tokenId)
}

// GetNftInfo is a free data retrieval call binding the contract method 0xd5ec2d83.
//
// Solidity: function getNftInfo(uint256 nftId_) view returns((string,uint256))
func (_ICosmicSignatureNft *ICosmicSignatureNftCaller) GetNftInfo(opts *bind.CallOpts, nftId_ *big.Int) (ICosmicSignatureNftNftInfo, error) {
	var out []interface{}
	err := _ICosmicSignatureNft.contract.Call(opts, &out, "getNftInfo", nftId_)

	if err != nil {
		return *new(ICosmicSignatureNftNftInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(ICosmicSignatureNftNftInfo)).(*ICosmicSignatureNftNftInfo)

	return out0, err

}

// GetNftInfo is a free data retrieval call binding the contract method 0xd5ec2d83.
//
// Solidity: function getNftInfo(uint256 nftId_) view returns((string,uint256))
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) GetNftInfo(nftId_ *big.Int) (ICosmicSignatureNftNftInfo, error) {
	return _ICosmicSignatureNft.Contract.GetNftInfo(&_ICosmicSignatureNft.CallOpts, nftId_)
}

// GetNftInfo is a free data retrieval call binding the contract method 0xd5ec2d83.
//
// Solidity: function getNftInfo(uint256 nftId_) view returns((string,uint256))
func (_ICosmicSignatureNft *ICosmicSignatureNftCallerSession) GetNftInfo(nftId_ *big.Int) (ICosmicSignatureNftNftInfo, error) {
	return _ICosmicSignatureNft.Contract.GetNftInfo(&_ICosmicSignatureNft.CallOpts, nftId_)
}

// GetNftName is a free data retrieval call binding the contract method 0x278ec44f.
//
// Solidity: function getNftName(uint256 nftId_) view returns(string)
func (_ICosmicSignatureNft *ICosmicSignatureNftCaller) GetNftName(opts *bind.CallOpts, nftId_ *big.Int) (string, error) {
	var out []interface{}
	err := _ICosmicSignatureNft.contract.Call(opts, &out, "getNftName", nftId_)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// GetNftName is a free data retrieval call binding the contract method 0x278ec44f.
//
// Solidity: function getNftName(uint256 nftId_) view returns(string)
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) GetNftName(nftId_ *big.Int) (string, error) {
	return _ICosmicSignatureNft.Contract.GetNftName(&_ICosmicSignatureNft.CallOpts, nftId_)
}

// GetNftName is a free data retrieval call binding the contract method 0x278ec44f.
//
// Solidity: function getNftName(uint256 nftId_) view returns(string)
func (_ICosmicSignatureNft *ICosmicSignatureNftCallerSession) GetNftName(nftId_ *big.Int) (string, error) {
	return _ICosmicSignatureNft.Contract.GetNftName(&_ICosmicSignatureNft.CallOpts, nftId_)
}

// GetNftSeed is a free data retrieval call binding the contract method 0xb0c0fe4e.
//
// Solidity: function getNftSeed(uint256 nftId_) view returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftCaller) GetNftSeed(opts *bind.CallOpts, nftId_ *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _ICosmicSignatureNft.contract.Call(opts, &out, "getNftSeed", nftId_)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetNftSeed is a free data retrieval call binding the contract method 0xb0c0fe4e.
//
// Solidity: function getNftSeed(uint256 nftId_) view returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) GetNftSeed(nftId_ *big.Int) (*big.Int, error) {
	return _ICosmicSignatureNft.Contract.GetNftSeed(&_ICosmicSignatureNft.CallOpts, nftId_)
}

// GetNftSeed is a free data retrieval call binding the contract method 0xb0c0fe4e.
//
// Solidity: function getNftSeed(uint256 nftId_) view returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftCallerSession) GetNftSeed(nftId_ *big.Int) (*big.Int, error) {
	return _ICosmicSignatureNft.Contract.GetNftSeed(&_ICosmicSignatureNft.CallOpts, nftId_)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_ICosmicSignatureNft *ICosmicSignatureNftCaller) IsApprovedForAll(opts *bind.CallOpts, owner common.Address, operator common.Address) (bool, error) {
	var out []interface{}
	err := _ICosmicSignatureNft.contract.Call(opts, &out, "isApprovedForAll", owner, operator)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) IsApprovedForAll(owner common.Address, operator common.Address) (bool, error) {
	return _ICosmicSignatureNft.Contract.IsApprovedForAll(&_ICosmicSignatureNft.CallOpts, owner, operator)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_ICosmicSignatureNft *ICosmicSignatureNftCallerSession) IsApprovedForAll(owner common.Address, operator common.Address) (bool, error) {
	return _ICosmicSignatureNft.Contract.IsApprovedForAll(&_ICosmicSignatureNft.CallOpts, owner, operator)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address owner)
func (_ICosmicSignatureNft *ICosmicSignatureNftCaller) OwnerOf(opts *bind.CallOpts, tokenId *big.Int) (common.Address, error) {
	var out []interface{}
	err := _ICosmicSignatureNft.contract.Call(opts, &out, "ownerOf", tokenId)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address owner)
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) OwnerOf(tokenId *big.Int) (common.Address, error) {
	return _ICosmicSignatureNft.Contract.OwnerOf(&_ICosmicSignatureNft.CallOpts, tokenId)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address owner)
func (_ICosmicSignatureNft *ICosmicSignatureNftCallerSession) OwnerOf(tokenId *big.Int) (common.Address, error) {
	return _ICosmicSignatureNft.Contract.OwnerOf(&_ICosmicSignatureNft.CallOpts, tokenId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_ICosmicSignatureNft *ICosmicSignatureNftCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _ICosmicSignatureNft.contract.Call(opts, &out, "supportsInterface", interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _ICosmicSignatureNft.Contract.SupportsInterface(&_ICosmicSignatureNft.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_ICosmicSignatureNft *ICosmicSignatureNftCallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _ICosmicSignatureNft.Contract.SupportsInterface(&_ICosmicSignatureNft.CallOpts, interfaceId)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 index) view returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftCaller) TokenByIndex(opts *bind.CallOpts, index *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _ICosmicSignatureNft.contract.Call(opts, &out, "tokenByIndex", index)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 index) view returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) TokenByIndex(index *big.Int) (*big.Int, error) {
	return _ICosmicSignatureNft.Contract.TokenByIndex(&_ICosmicSignatureNft.CallOpts, index)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 index) view returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftCallerSession) TokenByIndex(index *big.Int) (*big.Int, error) {
	return _ICosmicSignatureNft.Contract.TokenByIndex(&_ICosmicSignatureNft.CallOpts, index)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address owner, uint256 index) view returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftCaller) TokenOfOwnerByIndex(opts *bind.CallOpts, owner common.Address, index *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _ICosmicSignatureNft.contract.Call(opts, &out, "tokenOfOwnerByIndex", owner, index)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address owner, uint256 index) view returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) TokenOfOwnerByIndex(owner common.Address, index *big.Int) (*big.Int, error) {
	return _ICosmicSignatureNft.Contract.TokenOfOwnerByIndex(&_ICosmicSignatureNft.CallOpts, owner, index)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address owner, uint256 index) view returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftCallerSession) TokenOfOwnerByIndex(owner common.Address, index *big.Int) (*big.Int, error) {
	return _ICosmicSignatureNft.Contract.TokenOfOwnerByIndex(&_ICosmicSignatureNft.CallOpts, owner, index)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _ICosmicSignatureNft.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) TotalSupply() (*big.Int, error) {
	return _ICosmicSignatureNft.Contract.TotalSupply(&_ICosmicSignatureNft.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftCallerSession) TotalSupply() (*big.Int, error) {
	return _ICosmicSignatureNft.Contract.TotalSupply(&_ICosmicSignatureNft.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactor) Approve(opts *bind.TransactOpts, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.contract.Transact(opts, "approve", to, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) Approve(to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.Approve(&_ICosmicSignatureNft.TransactOpts, to, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactorSession) Approve(to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.Approve(&_ICosmicSignatureNft.TransactOpts, to, tokenId)
}

// Mint is a paid mutator transaction binding the contract method 0x836a1040.
//
// Solidity: function mint(uint256 roundNum_, address nftOwnerAddress_, uint256 randomNumberSeed_) returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactor) Mint(opts *bind.TransactOpts, roundNum_ *big.Int, nftOwnerAddress_ common.Address, randomNumberSeed_ *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.contract.Transact(opts, "mint", roundNum_, nftOwnerAddress_, randomNumberSeed_)
}

// Mint is a paid mutator transaction binding the contract method 0x836a1040.
//
// Solidity: function mint(uint256 roundNum_, address nftOwnerAddress_, uint256 randomNumberSeed_) returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) Mint(roundNum_ *big.Int, nftOwnerAddress_ common.Address, randomNumberSeed_ *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.Mint(&_ICosmicSignatureNft.TransactOpts, roundNum_, nftOwnerAddress_, randomNumberSeed_)
}

// Mint is a paid mutator transaction binding the contract method 0x836a1040.
//
// Solidity: function mint(uint256 roundNum_, address nftOwnerAddress_, uint256 randomNumberSeed_) returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactorSession) Mint(roundNum_ *big.Int, nftOwnerAddress_ common.Address, randomNumberSeed_ *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.Mint(&_ICosmicSignatureNft.TransactOpts, roundNum_, nftOwnerAddress_, randomNumberSeed_)
}

// MintMany is a paid mutator transaction binding the contract method 0x6578f113.
//
// Solidity: function mintMany(uint256 roundNum_, address[] nftOwnerAddresses_, uint256 randomNumberSeed_) returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactor) MintMany(opts *bind.TransactOpts, roundNum_ *big.Int, nftOwnerAddresses_ []common.Address, randomNumberSeed_ *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.contract.Transact(opts, "mintMany", roundNum_, nftOwnerAddresses_, randomNumberSeed_)
}

// MintMany is a paid mutator transaction binding the contract method 0x6578f113.
//
// Solidity: function mintMany(uint256 roundNum_, address[] nftOwnerAddresses_, uint256 randomNumberSeed_) returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) MintMany(roundNum_ *big.Int, nftOwnerAddresses_ []common.Address, randomNumberSeed_ *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.MintMany(&_ICosmicSignatureNft.TransactOpts, roundNum_, nftOwnerAddresses_, randomNumberSeed_)
}

// MintMany is a paid mutator transaction binding the contract method 0x6578f113.
//
// Solidity: function mintMany(uint256 roundNum_, address[] nftOwnerAddresses_, uint256 randomNumberSeed_) returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactorSession) MintMany(roundNum_ *big.Int, nftOwnerAddresses_ []common.Address, randomNumberSeed_ *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.MintMany(&_ICosmicSignatureNft.TransactOpts, roundNum_, nftOwnerAddresses_, randomNumberSeed_)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactor) SafeTransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.contract.Transact(opts, "safeTransferFrom", from, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) SafeTransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.SafeTransferFrom(&_ICosmicSignatureNft.TransactOpts, from, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactorSession) SafeTransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.SafeTransferFrom(&_ICosmicSignatureNft.TransactOpts, from, to, tokenId)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactor) SafeTransferFrom0(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _ICosmicSignatureNft.contract.Transact(opts, "safeTransferFrom0", from, to, tokenId, data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) SafeTransferFrom0(from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.SafeTransferFrom0(&_ICosmicSignatureNft.TransactOpts, from, to, tokenId, data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactorSession) SafeTransferFrom0(from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.SafeTransferFrom0(&_ICosmicSignatureNft.TransactOpts, from, to, tokenId, data)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactor) SetApprovalForAll(opts *bind.TransactOpts, operator common.Address, approved bool) (*types.Transaction, error) {
	return _ICosmicSignatureNft.contract.Transact(opts, "setApprovalForAll", operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.SetApprovalForAll(&_ICosmicSignatureNft.TransactOpts, operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactorSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.SetApprovalForAll(&_ICosmicSignatureNft.TransactOpts, operator, approved)
}

// SetNftBaseUri is a paid mutator transaction binding the contract method 0xe10a312d.
//
// Solidity: function setNftBaseUri(string newValue_) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactor) SetNftBaseUri(opts *bind.TransactOpts, newValue_ string) (*types.Transaction, error) {
	return _ICosmicSignatureNft.contract.Transact(opts, "setNftBaseUri", newValue_)
}

// SetNftBaseUri is a paid mutator transaction binding the contract method 0xe10a312d.
//
// Solidity: function setNftBaseUri(string newValue_) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) SetNftBaseUri(newValue_ string) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.SetNftBaseUri(&_ICosmicSignatureNft.TransactOpts, newValue_)
}

// SetNftBaseUri is a paid mutator transaction binding the contract method 0xe10a312d.
//
// Solidity: function setNftBaseUri(string newValue_) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactorSession) SetNftBaseUri(newValue_ string) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.SetNftBaseUri(&_ICosmicSignatureNft.TransactOpts, newValue_)
}

// SetNftGenerationScriptUri is a paid mutator transaction binding the contract method 0x11c9f23b.
//
// Solidity: function setNftGenerationScriptUri(string newValue_) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactor) SetNftGenerationScriptUri(opts *bind.TransactOpts, newValue_ string) (*types.Transaction, error) {
	return _ICosmicSignatureNft.contract.Transact(opts, "setNftGenerationScriptUri", newValue_)
}

// SetNftGenerationScriptUri is a paid mutator transaction binding the contract method 0x11c9f23b.
//
// Solidity: function setNftGenerationScriptUri(string newValue_) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) SetNftGenerationScriptUri(newValue_ string) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.SetNftGenerationScriptUri(&_ICosmicSignatureNft.TransactOpts, newValue_)
}

// SetNftGenerationScriptUri is a paid mutator transaction binding the contract method 0x11c9f23b.
//
// Solidity: function setNftGenerationScriptUri(string newValue_) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactorSession) SetNftGenerationScriptUri(newValue_ string) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.SetNftGenerationScriptUri(&_ICosmicSignatureNft.TransactOpts, newValue_)
}

// SetNftName is a paid mutator transaction binding the contract method 0xee056e1d.
//
// Solidity: function setNftName(uint256 nftId_, string nftName_) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactor) SetNftName(opts *bind.TransactOpts, nftId_ *big.Int, nftName_ string) (*types.Transaction, error) {
	return _ICosmicSignatureNft.contract.Transact(opts, "setNftName", nftId_, nftName_)
}

// SetNftName is a paid mutator transaction binding the contract method 0xee056e1d.
//
// Solidity: function setNftName(uint256 nftId_, string nftName_) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) SetNftName(nftId_ *big.Int, nftName_ string) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.SetNftName(&_ICosmicSignatureNft.TransactOpts, nftId_, nftName_)
}

// SetNftName is a paid mutator transaction binding the contract method 0xee056e1d.
//
// Solidity: function setNftName(uint256 nftId_, string nftName_) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactorSession) SetNftName(nftId_ *big.Int, nftName_ string) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.SetNftName(&_ICosmicSignatureNft.TransactOpts, nftId_, nftName_)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.contract.Transact(opts, "transferFrom", from, to, tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) TransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.TransferFrom(&_ICosmicSignatureNft.TransactOpts, from, to, tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactorSession) TransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.TransferFrom(&_ICosmicSignatureNft.TransactOpts, from, to, tokenId)
}

// ICosmicSignatureNftApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftApprovalIterator struct {
	Event *ICosmicSignatureNftApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureNftApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureNftApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureNftApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureNftApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureNftApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureNftApproval represents a Approval event raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftApproval struct {
	Owner    common.Address
	Approved common.Address
	TokenId  *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, approved []common.Address, tokenId []*big.Int) (*ICosmicSignatureNftApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _ICosmicSignatureNft.contract.FilterLogs(opts, "Approval", ownerRule, approvedRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureNftApprovalIterator{contract: _ICosmicSignatureNft.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureNftApproval, owner []common.Address, approved []common.Address, tokenId []*big.Int) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _ICosmicSignatureNft.contract.WatchLogs(opts, "Approval", ownerRule, approvedRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureNftApproval)
				if err := _ICosmicSignatureNft.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) ParseApproval(log types.Log) (*ICosmicSignatureNftApproval, error) {
	event := new(ICosmicSignatureNftApproval)
	if err := _ICosmicSignatureNft.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureNftApprovalForAllIterator is returned from FilterApprovalForAll and is used to iterate over the raw logs and unpacked data for ApprovalForAll events raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftApprovalForAllIterator struct {
	Event *ICosmicSignatureNftApprovalForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureNftApprovalForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureNftApprovalForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureNftApprovalForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureNftApprovalForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureNftApprovalForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureNftApprovalForAll represents a ApprovalForAll event raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftApprovalForAll struct {
	Owner    common.Address
	Operator common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApprovalForAll is a free log retrieval operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) FilterApprovalForAll(opts *bind.FilterOpts, owner []common.Address, operator []common.Address) (*ICosmicSignatureNftApprovalForAllIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _ICosmicSignatureNft.contract.FilterLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureNftApprovalForAllIterator{contract: _ICosmicSignatureNft.contract, event: "ApprovalForAll", logs: logs, sub: sub}, nil
}

// WatchApprovalForAll is a free log subscription operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureNftApprovalForAll, owner []common.Address, operator []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _ICosmicSignatureNft.contract.WatchLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureNftApprovalForAll)
				if err := _ICosmicSignatureNft.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApprovalForAll is a log parse operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) ParseApprovalForAll(log types.Log) (*ICosmicSignatureNftApprovalForAll, error) {
	event := new(ICosmicSignatureNftApprovalForAll)
	if err := _ICosmicSignatureNft.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureNftNftBaseUriChangedIterator is returned from FilterNftBaseUriChanged and is used to iterate over the raw logs and unpacked data for NftBaseUriChanged events raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftNftBaseUriChangedIterator struct {
	Event *ICosmicSignatureNftNftBaseUriChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureNftNftBaseUriChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureNftNftBaseUriChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureNftNftBaseUriChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureNftNftBaseUriChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureNftNftBaseUriChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureNftNftBaseUriChanged represents a NftBaseUriChanged event raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftNftBaseUriChanged struct {
	NewValue string
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterNftBaseUriChanged is a free log retrieval operation binding the contract event 0xbdfd815215fcee5bb949c941ab489c7ead076a7c8acd3527cd1b50f613ac67e6.
//
// Solidity: event NftBaseUriChanged(string newValue)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) FilterNftBaseUriChanged(opts *bind.FilterOpts) (*ICosmicSignatureNftNftBaseUriChangedIterator, error) {

	logs, sub, err := _ICosmicSignatureNft.contract.FilterLogs(opts, "NftBaseUriChanged")
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureNftNftBaseUriChangedIterator{contract: _ICosmicSignatureNft.contract, event: "NftBaseUriChanged", logs: logs, sub: sub}, nil
}

// WatchNftBaseUriChanged is a free log subscription operation binding the contract event 0xbdfd815215fcee5bb949c941ab489c7ead076a7c8acd3527cd1b50f613ac67e6.
//
// Solidity: event NftBaseUriChanged(string newValue)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) WatchNftBaseUriChanged(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureNftNftBaseUriChanged) (event.Subscription, error) {

	logs, sub, err := _ICosmicSignatureNft.contract.WatchLogs(opts, "NftBaseUriChanged")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureNftNftBaseUriChanged)
				if err := _ICosmicSignatureNft.contract.UnpackLog(event, "NftBaseUriChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseNftBaseUriChanged is a log parse operation binding the contract event 0xbdfd815215fcee5bb949c941ab489c7ead076a7c8acd3527cd1b50f613ac67e6.
//
// Solidity: event NftBaseUriChanged(string newValue)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) ParseNftBaseUriChanged(log types.Log) (*ICosmicSignatureNftNftBaseUriChanged, error) {
	event := new(ICosmicSignatureNftNftBaseUriChanged)
	if err := _ICosmicSignatureNft.contract.UnpackLog(event, "NftBaseUriChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureNftNftGenerationScriptUriChangedIterator is returned from FilterNftGenerationScriptUriChanged and is used to iterate over the raw logs and unpacked data for NftGenerationScriptUriChanged events raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftNftGenerationScriptUriChangedIterator struct {
	Event *ICosmicSignatureNftNftGenerationScriptUriChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureNftNftGenerationScriptUriChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureNftNftGenerationScriptUriChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureNftNftGenerationScriptUriChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureNftNftGenerationScriptUriChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureNftNftGenerationScriptUriChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureNftNftGenerationScriptUriChanged represents a NftGenerationScriptUriChanged event raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftNftGenerationScriptUriChanged struct {
	NewValue string
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterNftGenerationScriptUriChanged is a free log retrieval operation binding the contract event 0x27e2bd70f498920ee0fd7d8204ae8845b75dc81330e3acafa32946be3503730c.
//
// Solidity: event NftGenerationScriptUriChanged(string newValue)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) FilterNftGenerationScriptUriChanged(opts *bind.FilterOpts) (*ICosmicSignatureNftNftGenerationScriptUriChangedIterator, error) {

	logs, sub, err := _ICosmicSignatureNft.contract.FilterLogs(opts, "NftGenerationScriptUriChanged")
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureNftNftGenerationScriptUriChangedIterator{contract: _ICosmicSignatureNft.contract, event: "NftGenerationScriptUriChanged", logs: logs, sub: sub}, nil
}

// WatchNftGenerationScriptUriChanged is a free log subscription operation binding the contract event 0x27e2bd70f498920ee0fd7d8204ae8845b75dc81330e3acafa32946be3503730c.
//
// Solidity: event NftGenerationScriptUriChanged(string newValue)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) WatchNftGenerationScriptUriChanged(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureNftNftGenerationScriptUriChanged) (event.Subscription, error) {

	logs, sub, err := _ICosmicSignatureNft.contract.WatchLogs(opts, "NftGenerationScriptUriChanged")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureNftNftGenerationScriptUriChanged)
				if err := _ICosmicSignatureNft.contract.UnpackLog(event, "NftGenerationScriptUriChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseNftGenerationScriptUriChanged is a log parse operation binding the contract event 0x27e2bd70f498920ee0fd7d8204ae8845b75dc81330e3acafa32946be3503730c.
//
// Solidity: event NftGenerationScriptUriChanged(string newValue)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) ParseNftGenerationScriptUriChanged(log types.Log) (*ICosmicSignatureNftNftGenerationScriptUriChanged, error) {
	event := new(ICosmicSignatureNftNftGenerationScriptUriChanged)
	if err := _ICosmicSignatureNft.contract.UnpackLog(event, "NftGenerationScriptUriChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureNftNftMintedIterator is returned from FilterNftMinted and is used to iterate over the raw logs and unpacked data for NftMinted events raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftNftMintedIterator struct {
	Event *ICosmicSignatureNftNftMinted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureNftNftMintedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureNftNftMinted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureNftNftMinted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureNftNftMintedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureNftNftMintedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureNftNftMinted represents a NftMinted event raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftNftMinted struct {
	RoundNum        *big.Int
	NftOwnerAddress common.Address
	NftSeed         *big.Int
	NftId           *big.Int
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterNftMinted is a free log retrieval operation binding the contract event 0xc2115f21464937bfdcd1560f96f0e20b70e88accbdcd1069084c80c8797ef106.
//
// Solidity: event NftMinted(uint256 indexed roundNum, address indexed nftOwnerAddress, uint256 nftSeed, uint256 indexed nftId)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) FilterNftMinted(opts *bind.FilterOpts, roundNum []*big.Int, nftOwnerAddress []common.Address, nftId []*big.Int) (*ICosmicSignatureNftNftMintedIterator, error) {

	var roundNumRule []interface{}
	for _, roundNumItem := range roundNum {
		roundNumRule = append(roundNumRule, roundNumItem)
	}
	var nftOwnerAddressRule []interface{}
	for _, nftOwnerAddressItem := range nftOwnerAddress {
		nftOwnerAddressRule = append(nftOwnerAddressRule, nftOwnerAddressItem)
	}

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}

	logs, sub, err := _ICosmicSignatureNft.contract.FilterLogs(opts, "NftMinted", roundNumRule, nftOwnerAddressRule, nftIdRule)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureNftNftMintedIterator{contract: _ICosmicSignatureNft.contract, event: "NftMinted", logs: logs, sub: sub}, nil
}

// WatchNftMinted is a free log subscription operation binding the contract event 0xc2115f21464937bfdcd1560f96f0e20b70e88accbdcd1069084c80c8797ef106.
//
// Solidity: event NftMinted(uint256 indexed roundNum, address indexed nftOwnerAddress, uint256 nftSeed, uint256 indexed nftId)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) WatchNftMinted(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureNftNftMinted, roundNum []*big.Int, nftOwnerAddress []common.Address, nftId []*big.Int) (event.Subscription, error) {

	var roundNumRule []interface{}
	for _, roundNumItem := range roundNum {
		roundNumRule = append(roundNumRule, roundNumItem)
	}
	var nftOwnerAddressRule []interface{}
	for _, nftOwnerAddressItem := range nftOwnerAddress {
		nftOwnerAddressRule = append(nftOwnerAddressRule, nftOwnerAddressItem)
	}

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}

	logs, sub, err := _ICosmicSignatureNft.contract.WatchLogs(opts, "NftMinted", roundNumRule, nftOwnerAddressRule, nftIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureNftNftMinted)
				if err := _ICosmicSignatureNft.contract.UnpackLog(event, "NftMinted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseNftMinted is a log parse operation binding the contract event 0xc2115f21464937bfdcd1560f96f0e20b70e88accbdcd1069084c80c8797ef106.
//
// Solidity: event NftMinted(uint256 indexed roundNum, address indexed nftOwnerAddress, uint256 nftSeed, uint256 indexed nftId)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) ParseNftMinted(log types.Log) (*ICosmicSignatureNftNftMinted, error) {
	event := new(ICosmicSignatureNftNftMinted)
	if err := _ICosmicSignatureNft.contract.UnpackLog(event, "NftMinted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureNftNftNameChangedIterator is returned from FilterNftNameChanged and is used to iterate over the raw logs and unpacked data for NftNameChanged events raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftNftNameChangedIterator struct {
	Event *ICosmicSignatureNftNftNameChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureNftNftNameChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureNftNftNameChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureNftNftNameChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureNftNftNameChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureNftNftNameChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureNftNftNameChanged represents a NftNameChanged event raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftNftNameChanged struct {
	NftId   *big.Int
	NftName string
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterNftNameChanged is a free log retrieval operation binding the contract event 0xa14cfb0fe69c0b55eaaa4d9400bdba2a72e1860cade89c2a8a055e6cfde8936d.
//
// Solidity: event NftNameChanged(uint256 indexed nftId, string nftName)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) FilterNftNameChanged(opts *bind.FilterOpts, nftId []*big.Int) (*ICosmicSignatureNftNftNameChangedIterator, error) {

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}

	logs, sub, err := _ICosmicSignatureNft.contract.FilterLogs(opts, "NftNameChanged", nftIdRule)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureNftNftNameChangedIterator{contract: _ICosmicSignatureNft.contract, event: "NftNameChanged", logs: logs, sub: sub}, nil
}

// WatchNftNameChanged is a free log subscription operation binding the contract event 0xa14cfb0fe69c0b55eaaa4d9400bdba2a72e1860cade89c2a8a055e6cfde8936d.
//
// Solidity: event NftNameChanged(uint256 indexed nftId, string nftName)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) WatchNftNameChanged(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureNftNftNameChanged, nftId []*big.Int) (event.Subscription, error) {

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}

	logs, sub, err := _ICosmicSignatureNft.contract.WatchLogs(opts, "NftNameChanged", nftIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureNftNftNameChanged)
				if err := _ICosmicSignatureNft.contract.UnpackLog(event, "NftNameChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseNftNameChanged is a log parse operation binding the contract event 0xa14cfb0fe69c0b55eaaa4d9400bdba2a72e1860cade89c2a8a055e6cfde8936d.
//
// Solidity: event NftNameChanged(uint256 indexed nftId, string nftName)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) ParseNftNameChanged(log types.Log) (*ICosmicSignatureNftNftNameChanged, error) {
	event := new(ICosmicSignatureNftNftNameChanged)
	if err := _ICosmicSignatureNft.contract.UnpackLog(event, "NftNameChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureNftTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftTransferIterator struct {
	Event *ICosmicSignatureNftTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureNftTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureNftTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureNftTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureNftTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureNftTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureNftTransfer represents a Transfer event raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftTransfer struct {
	From    common.Address
	To      common.Address
	TokenId *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenId []*big.Int) (*ICosmicSignatureNftTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _ICosmicSignatureNft.contract.FilterLogs(opts, "Transfer", fromRule, toRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureNftTransferIterator{contract: _ICosmicSignatureNft.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureNftTransfer, from []common.Address, to []common.Address, tokenId []*big.Int) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _ICosmicSignatureNft.contract.WatchLogs(opts, "Transfer", fromRule, toRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureNftTransfer)
				if err := _ICosmicSignatureNft.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) ParseTransfer(log types.Log) (*ICosmicSignatureNftTransfer, error) {
	event := new(ICosmicSignatureNftTransfer)
	if err := _ICosmicSignatureNft.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
