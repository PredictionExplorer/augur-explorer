--- uniswap-v3-core/contracts/UniswapV3Pool.sol	2021-07-14 21:32:42.397745808 -0500
+++ uniswap-v3-core-mine/contracts/UniswapV3Pool.sol	2022-07-07 21:06:15.647998250 -0500
@@ -636,7 +636,7 @@
                 protocolFee: 0,
                 liquidity: cache.liquidityStart
             });
-
+		emit DBG_SWAP_HEAD(address(this),zeroForOne,amountSpecified,slot0Start.sqrtPriceX96,sqrtPriceLimitX96,state.tick)
         // continue swapping as long as we haven't used the entire input/output and haven't reached the price limit
         while (state.amountSpecifiedRemaining != 0 && state.sqrtPriceX96 != sqrtPriceLimitX96) {
             StepComputations memory step;
@@ -658,7 +658,6 @@
 
             // get the price for the next tick
             step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);
-
             // compute values to swap to the target tick, price limit, or point where input/output amount is exhausted
             (state.sqrtPriceX96, step.amountIn, step.amountOut, step.feeAmount) = SwapMath.computeSwapStep(
                 state.sqrtPriceX96,
@@ -689,6 +688,7 @@
             if (state.liquidity > 0)
                 state.feeGrowthGlobalX128 += FullMath.mulDiv(step.feeAmount, FixedPoint128.Q128, state.liquidity);
 
+			emit DBG_LOOP(address(this),state.sqrtPriceX96,step.sqrtPriceStartX96,step.sqrtPriceNextX96,state.tick,cache.tickCumulative,step.initialized,step.stepAmountIn,step.stepAmountOut,amountCalculated,step.feeAmount,liquidity,exactInput,state.feeGrowthGlobalX128)
             // shift tick if we reached the next price
             if (state.sqrtPriceX96 == step.sqrtPriceNextX96) {
                 // if the tick is initialized, run the tick transition
@@ -782,7 +782,7 @@
             IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(amount0, amount1, data);
             require(balance1Before.add(uint256(amount1)) <= balance1(), 'IIA');
         }
-
+		emit DBG_SWAP_TAIL(address(this),feeGrowthGlobal0X128,feeGrowthGlobal1X128,state.tick,state,sqrtPriceX96,slot0.sqrtPriceX96,state.liquidity,(state.liquidity-cache.liquidityStart))
         emit Swap(msg.sender, recipient, amount0, amount1, state.sqrtPriceX96, state.liquidity, state.tick);
         slot0.unlocked = true;
     }
