--- go-ethereum-1.10.26-orig/core/evm.go	2022-11-03 04:59:33.000000000 -0600
+++ go-ethereum-1.10.26/core/evm.go	2022-11-10 11:08:06.715732912 -0600
@@ -17,6 +17,7 @@
 package core
 
 import (
+	"fmt"
 	"math/big"
 
 	"github.com/ethereum/go-ethereum/common"
@@ -119,11 +120,13 @@
 // CanTransfer checks whether there are enough funds in the address' account to make a transfer.
 // This does not take the necessary gas in to account to make the transfer valid.
 func CanTransfer(db vm.StateDB, addr common.Address, amount *big.Int) bool {
+	fmt.Printf("CanTransfer(): addr %v balance %v amount %v can? = %v\n",addr.String(),db.GetBalance(addr).String(),amount.String(),db.GetBalance(addr).Cmp(amount) >= 0)
 	return db.GetBalance(addr).Cmp(amount) >= 0
 }
 
 // Transfer subtracts amount from sender and adds amount to recipient using the given Db
 func Transfer(db vm.StateDB, sender, recipient common.Address, amount *big.Int) {
+	fmt.Printf("transferring %v from %v to %v\n",amount.String(),sender.String(),recipient.String())
 	db.SubBalance(sender, amount)
 	db.AddBalance(recipient, amount)
 }
--- go-ethereum-1.10.26-orig/core/vm/interpreter.go	2022-11-03 04:59:33.000000000 -0600
+++ go-ethereum-1.10.26/core/vm/interpreter.go	2022-11-09 12:00:40.692866407 -0600
@@ -17,6 +17,7 @@
 package vm
 
 import (
+	"fmt"
 	"hash"
 
 	"github.com/ethereum/go-ethereum/common"
@@ -185,6 +186,7 @@
 		// Get the operation from the jump table and validate the stack to ensure there are
 		// enough stack items available to perform the operation.
 		op = contract.GetOp(pc)
+		fmt.Printf("%v\t%v\n",pc,op)
 		operation := in.cfg.JumpTable[op]
 		cost = operation.constantGas // For tracing
 		// Validate stack
--- go-ethereum-1.10.26-orig/core/vm/instructions.go	2022-11-03 04:59:33.000000000 -0600
+++ go-ethereum-1.10.26/core/vm/instructions.go	2023-01-10 19:06:50.916465082 -0600
@@ -17,7 +17,9 @@
 package vm
 
 import (
+	"fmt"
 	"sync/atomic"
+	"encoding/hex"
 
 	"github.com/ethereum/go-ethereum/common"
 	"github.com/ethereum/go-ethereum/core/types"
@@ -88,6 +90,7 @@
 
 func opLt(pc *uint64, interpreter *EVMInterpreter, scope *ScopeContext) ([]byte, error) {
 	x, y := scope.Stack.pop(), scope.Stack.peek()
+	fmt.Printf("\t\topLt x=%v, y=%v\n",x,y)
 	if x.Lt(y) {
 		y.SetOne()
 	} else {
@@ -276,6 +279,7 @@
 
 func opCallValue(pc *uint64, interpreter *EVMInterpreter, scope *ScopeContext) ([]byte, error) {
 	v, _ := uint256.FromBig(scope.Contract.value)
+	fmt.Printf("\t\topCallValue() pushing value %v to the stack\n",v.String())
 	scope.Stack.push(v)
 	return nil, nil
 }
@@ -337,13 +341,16 @@
 	if overflow || uint64(len(interpreter.returnData)) < end64 {
 		return nil, ErrReturnDataOutOfBounds
 	}
+	fmt.Printf("\topReturnDataCopy() data: \n",interpreter.returnData[offset64:end64])
 	scope.Memory.Set(memOffset.Uint64(), length.Uint64(), interpreter.returnData[offset64:end64])
 	return nil, nil
 }
 
 func opExtCodeSize(pc *uint64, interpreter *EVMInterpreter, scope *ScopeContext) ([]byte, error) {
 	slot := scope.Stack.peek()
-	slot.SetUint64(uint64(interpreter.evm.StateDB.GetCodeSize(slot.Bytes20())))
+	addr := slot.Bytes20()
+	fmt.Printf("\topExtCodeSize() on addr %v\n",hex.EncodeToString(addr[:]))
+	slot.SetUint64(uint64(interpreter.evm.StateDB.GetCodeSize(addr)))
 	return nil, nil
 }
 
@@ -503,6 +510,7 @@
 func opMstore(pc *uint64, interpreter *EVMInterpreter, scope *ScopeContext) ([]byte, error) {
 	// pop value of the stack
 	mStart, val := scope.Stack.pop(), scope.Stack.pop()
+	fmt.Printf("\topMStore() setting value %v (integer %v) at offset %v\n",val.String(),val.Uint64(),mStart.String())
 	scope.Memory.Set32(mStart.Uint64(), &val)
 	return nil, nil
 }
@@ -540,6 +548,7 @@
 	if !scope.Contract.validJumpdest(&pos) {
 		return nil, ErrInvalidJump
 	}
+	fmt.Printf("\t\topJump() new pc = %v (integer %v)\n",pos,pos.Uint64())
 	*pc = pos.Uint64() - 1 // pc will be increased by the interpreter loop
 	return nil, nil
 }
@@ -549,6 +558,7 @@
 		return nil, errStopToken
 	}
 	pos, cond := scope.Stack.pop(), scope.Stack.pop()
+	fmt.Printf("\t\topJumpi() new pc = %v (integer %v)\n",pos,pos.Uint64())
 	if !cond.IsZero() {
 		if !scope.Contract.validJumpdest(&pos) {
 			return nil, ErrInvalidJump
@@ -876,8 +886,10 @@
 	)
 	*pc += 1
 	if *pc < codeLen {
+		fmt.Printf("\t\topPush1() pushing value %v\n",scope.Contract.Code[*pc])
 		scope.Stack.push(integer.SetUint64(uint64(scope.Contract.Code[*pc])))
 	} else {
+		fmt.Printf("\t\topPush1() pushing 0\n")
 		scope.Stack.push(integer.Clear())
 	}
 	return nil, nil
@@ -899,8 +911,11 @@
 		}
 
 		integer := new(uint256.Int)
-		scope.Stack.push(integer.SetBytes(common.RightPadBytes(
-			scope.Contract.Code[startMin:endMin], pushByteSize)))
+		bytes_to_push := integer.SetBytes(common.RightPadBytes(scope.Contract.Code[startMin:endMin], pushByteSize))
+		fmt.Printf("\t\tpushN() integer = %v\n",integer)
+		fmt.Printf("\t\tstartMin=%v, endMin=%v , int64=%v\n",startMin,endMin,integer.Uint64())
+		fmt.Printf("\t\tpushN() bytes to push: %v\n",bytes_to_push.Hex())
+		scope.Stack.push(bytes_to_push)
 
 		*pc += size
 		return nil, nil
--- go-ethereum-1.10.26-orig/core/state/statedb.go	2022-11-03 04:59:33.000000000 -0600
+++ go-ethereum-1.10.26/core/state/statedb.go	2022-11-15 12:41:54.703083185 -0600
@@ -262,6 +262,7 @@
 
 // GetBalance retrieves the balance from the given address or 0 if object not found
 func (s *StateDB) GetBalance(addr common.Address) *big.Int {
+	fmt.Printf("statedb.GetBalance() addr %v\n",addr.String())
 	stateObject := s.getStateObject(addr)
 	if stateObject != nil {
 		return stateObject.Balance()
@@ -309,6 +310,7 @@
 
 // GetState retrieves a value from the given account's storage trie.
 func (s *StateDB) GetState(addr common.Address, hash common.Hash) common.Hash {
+	fmt.Printf("statedb.GetState() addr %v hash %v\n",addr.String(),hash.String())
 	stateObject := s.getStateObject(addr)
 	if stateObject != nil {
 		return stateObject.GetState(s.db, hash)
@@ -562,9 +564,13 @@
 
 // GetOrNewStateObject retrieves a state object or create a new state object if nil.
 func (s *StateDB) GetOrNewStateObject(addr common.Address) *stateObject {
+	fmt.Printf("statedb.GetOrNewStateObject() addr %v\n",addr.String())
 	stateObject := s.getStateObject(addr)
 	if stateObject == nil {
 		stateObject, _ = s.createObject(addr)
+		fmt.Printf("statedb.GetOrNewStateObject() object not existed but created\n")
+	} else {
+		fmt.Printf("statedb.GetOrNewStateObject() object already existed\n")
 	}
 	return stateObject
 }
@@ -572,6 +578,7 @@
 // createObject creates a new state object. If there is an existing account with
 // the given address, it is overwritten and returned as the second return value.
 func (s *StateDB) createObject(addr common.Address) (newobj, prev *stateObject) {
+	fmt.Printf("statedb.createObject() addr %v\n",addr.String())
 	prev = s.getDeletedStateObject(addr) // Note, prev might have been deleted, we need that!
 
 	var prevdestruct bool
@@ -897,6 +904,7 @@
 // Commit writes the state to the underlying in-memory trie database.
 func (s *StateDB) Commit(deleteEmptyObjects bool) (common.Hash, error) {
 	if s.dbErr != nil {
+		fmt.Printf("statedb.Commit() returns on s.dbErr\n")
 		return common.Hash{}, fmt.Errorf("commit aborted due to earlier error: %v", s.dbErr)
 	}
 	// Finalize any pending changes and merge everything into the tries
@@ -919,11 +927,13 @@
 			// Write any storage changes in the state object to its storage trie
 			set, err := obj.CommitTrie(s.db)
 			if err != nil {
+				fmt.Printf("statedb.Commit() returns on obj.CommitTrie()\n")
 				return common.Hash{}, err
 			}
 			// Merge the dirty nodes of storage trie into global set
 			if set != nil {
 				if err := nodes.Merge(set); err != nil {
+					fmt.Printf("statedb.Commit() returns on nodes.Merge()\n")
 					return common.Hash{}, err
 				}
 				storageTrieNodes += set.Len()
@@ -945,11 +955,13 @@
 	}
 	root, set, err := s.trie.Commit(true)
 	if err != nil {
+		fmt.Printf("statedb.Commit() returns on error in trie.Commit()\n")
 		return common.Hash{}, err
 	}
 	// Merge the dirty nodes of account trie into global set
 	if set != nil {
 		if err := nodes.Merge(set); err != nil {
+			fmt.Printf("statedb.Commit() returns on nodes.Merge()\n")
 			return common.Hash{}, err
 		}
 		accountTrieNodes = set.Len()
@@ -987,8 +999,10 @@
 		s.snap, s.snapDestructs, s.snapAccounts, s.snapStorage = nil, nil, nil, nil
 	}
 	if err := s.db.TrieDB().Update(nodes); err != nil {
+		fmt.Printf("Error on db.TrieDB().Update(): %v\n",err)
 		return common.Hash{}, err
 	}
+	fmt.Printf("statedb.Commit(): root = %v\n",root.String())
 	s.originalRoot = root
 	return root, err
 }
--- go-ethereum-1.10.26-orig/core/state/state_object.go	2022-11-03 04:59:33.000000000 -0600
+++ go-ethereum-1.10.26/core/state/state_object.go	2022-11-10 10:11:24.749984323 -0600
@@ -406,6 +406,7 @@
 		}
 		return
 	}
+	fmt.Printf("state.AddBalance() address=%v , balance %v , amount %v\n",s.address.String(),s.Balance().String(),amount.String())
 	s.SetBalance(new(big.Int).Add(s.Balance(), amount))
 }
 
--- go-ethereum-1.10.26-orig/core/state/dump.go	2022-11-03 04:59:33.000000000 -0600
+++ go-ethereum-1.10.26/core/state/dump.go	2022-11-16 19:04:09.669843597 -0600
@@ -18,6 +18,7 @@
 
 import (
 	"encoding/json"
+	"encoding/hex"
 	"fmt"
 	"time"
 
@@ -73,6 +74,7 @@
 
 // OnAccount implements DumpCollector interface
 func (d *Dump) OnAccount(addr common.Address, account DumpAccount) {
+	fmt.Printf("Dump::OnAccount() addr=%v , dump.AccountAddress=%+v\n",hex.EncodeToString(addr.Bytes()),account.Address)
 	d.Accounts[addr] = account
 }
 
@@ -113,6 +115,7 @@
 	if addr != (common.Address{}) {
 		dumpAccount.Address = &addr
 	}
+	fmt.Printf("IterativeDump: OnAccount() addr=%v , dump.AccountAddress=%+v\n",hex.EncodeToString(addr.Bytes()))
 	d.Encode(dumpAccount)
 }
 
@@ -136,7 +139,8 @@
 		start            = time.Now()
 		logged           = time.Now()
 	)
-	log.Info("Trie dumping started", "root", s.trie.Hash())
+	fmt.Printf("Trie dumping started root=%v\n",s.trie.Hash().String())
+	log.Info("state.DumpToCollector(): Trie dumping started", "root", s.trie.Hash())
 	c.OnRoot(s.trie.Hash())
 
 	it := trie.NewIterator(s.trie.NodeIterator(conf.Start))
@@ -154,14 +158,17 @@
 		}
 		addrBytes := s.trie.GetKey(it.Key)
 		if addrBytes == nil {
+			fmt.Printf("state.DumpToCollector(): addBytes is nil\n")
 			// Preimage missing
 			missingPreimages++
 			if conf.OnlyWithAddresses {
+				fmt.Printf("onlyWithAddresses is set, 'continue'-ing")
 				continue
 			}
 			account.SecureKey = it.Key
 		}
 		addr := common.BytesToAddress(addrBytes)
+		fmt.Printf("state.DumpToCollector(): account %v nonce %v balance %v root %v\n",addr.String(),data.Nonce,data.Balance.String(),hex.EncodeToString(data.Root[:]))
 		obj := newObject(s, addr, data)
 		if !conf.SkipCode {
 			account.Code = obj.Code(s.db)
@@ -195,6 +202,7 @@
 	if missingPreimages > 0 {
 		log.Warn("Dump incomplete due to missing preimages", "missing", missingPreimages)
 	}
+	fmt.Printf("state.DumpToCollector() finished\n")
 	log.Info("Trie dumping complete", "accounts", accounts,
 		"elapsed", common.PrettyDuration(time.Since(start)))
 
--- go-ethereum-1.10.26-orig/core/vm/evm.go	2022-11-03 04:59:33.000000000 -0600
+++ go-ethereum-1.10.26/core/vm/evm.go	2023-01-10 10:04:29.537095488 -0600
@@ -20,6 +20,8 @@
 	"math/big"
 	"sync/atomic"
 	"time"
+	"fmt"
+	"encoding/hex"
 
 	"github.com/ethereum/go-ethereum/common"
 	"github.com/ethereum/go-ethereum/crypto"
@@ -167,6 +169,10 @@
 // execution error or failed value transfer.
 func (evm *EVM) Call(caller ContractRef, addr common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) {
 	// Fail if we're trying to execute above the call depth limit
+	fmt.Printf("executing evm.Call(addr=%v)\n",addr.String())
+	input_len := len(input)
+	if input_len > 64 { input_len = 64 }
+	fmt.Printf("first 64 bytes of input: %v\n",hex.EncodeToString(input[0:input_len]))
 	if evm.depth > int(params.CallCreateDepth) {
 		return nil, gas, ErrDepth
 	}
@@ -217,6 +223,7 @@
 		// Initialise a new contract and set the code that is to be used by the EVM.
 		// The contract is a scoped environment for this execution context only.
 		code := evm.StateDB.GetCode(addr)
+		fmt.Printf("evm.Call() length of code to execute: %v bytes\n",len(code))
 		if len(code) == 0 {
 			ret, err = nil, nil // gas is unchanged
 		} else {
@@ -241,6 +248,10 @@
 		//} else {
 		//	evm.StateDB.DiscardSnapshot(snapshot)
 	}
+	lret := len(ret)
+	if lret > 64 { lret = 64 }
+	fmt.Printf("Call() returns output: %v\n",hex.EncodeToString(ret[0:lret]))
+	fmt.Printf("evm.Call() returns (err=%v)\n",err)
 	return ret, gas, err
 }
 
@@ -253,6 +264,10 @@
 // code with the caller as context.
 func (evm *EVM) CallCode(caller ContractRef, addr common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) {
 	// Fail if we're trying to execute above the call depth limit
+	fmt.Printf("executing evm.CallCode(addr=%v)\n",addr.String())
+	input_len := len(input)
+	if input_len > 64 { input_len = 64 }
+	fmt.Printf("first 64 bytes of input: %v\n",hex.EncodeToString(input[0:input_len]))
 	if evm.depth > int(params.CallCreateDepth) {
 		return nil, gas, ErrDepth
 	}
@@ -291,6 +306,10 @@
 			gas = 0
 		}
 	}
+	lret := len(ret)
+	if lret > 64 { lret = 64 }
+	fmt.Printf("CallCode() returns output: %v\n",hex.EncodeToString(ret[0:lret]))
+	fmt.Printf("evm.CallCode() returns (err=%v)\n",err)
 	return ret, gas, err
 }
 
@@ -300,6 +319,10 @@
 // DelegateCall differs from CallCode in the sense that it executes the given address'
 // code with the caller as context and the caller is set to the caller of the caller.
 func (evm *EVM) DelegateCall(caller ContractRef, addr common.Address, input []byte, gas uint64) (ret []byte, leftOverGas uint64, err error) {
+	fmt.Printf("executing evm.DelegateCall(addr=%v)\n",addr.String())
+	input_len := len(input)
+	if input_len > 64 { input_len = 64 }
+	fmt.Printf("first 64 bytes of input: %v\n",hex.EncodeToString(input[0:input_len]))
 	// Fail if we're trying to execute above the call depth limit
 	if evm.depth > int(params.CallCreateDepth) {
 		return nil, gas, ErrDepth
@@ -331,6 +354,10 @@
 			gas = 0
 		}
 	}
+	lret := len(ret)
+	if lret > 64 { lret = 64 }
+	fmt.Printf("DelegateCall() returns output: %v\n",hex.EncodeToString(ret[0:lret]))
+	fmt.Printf("evm.DelegateCall() returns (err=%v)\n",err)
 	return ret, gas, err
 }
 
@@ -340,6 +367,10 @@
 // instead of performing the modifications.
 func (evm *EVM) StaticCall(caller ContractRef, addr common.Address, input []byte, gas uint64) (ret []byte, leftOverGas uint64, err error) {
 	// Fail if we're trying to execute above the call depth limit
+	fmt.Printf("executing evm.StaticCall(addr=%v)\n",addr.String())
+	input_len := len(input)
+	if input_len > 64 { input_len = 64 }
+	fmt.Printf("first 64 bytes of input: %v\n",hex.EncodeToString(input[0:input_len]))
 	if evm.depth > int(params.CallCreateDepth) {
 		return nil, gas, ErrDepth
 	}
@@ -387,6 +418,10 @@
 			gas = 0
 		}
 	}
+	lret := len(ret)
+	if lret > 64 { lret = 64 }
+	fmt.Printf("StaticCall() returns output: %v\n",hex.EncodeToString(ret[0:lret]))
+	fmt.Printf("evm.StaticCall() returns (err=%v)\n",err)
 	return ret, gas, err
 }
 
@@ -492,6 +527,9 @@
 			evm.Config.Tracer.CaptureExit(ret, gas-contract.Gas, err)
 		}
 	}
+	lret := len(ret)
+	if lret > 64 { lret = 64 }
+	fmt.Printf("Create() returns output: %v\n",hex.EncodeToString(ret[0:lret]))
 	return ret, address, contract.Gas, err
 }
 
@@ -508,8 +546,13 @@
 func (evm *EVM) Create2(caller ContractRef, code []byte, gas uint64, endowment *big.Int, salt *uint256.Int) (ret []byte, contractAddr common.Address, leftOverGas uint64, err error) {
 	codeAndHash := &codeAndHash{code: code}
 	contractAddr = crypto.CreateAddress2(caller.Address(), salt.Bytes32(), codeAndHash.Hash().Bytes())
+	fmt.Printf("Create2() generated contract address: %v\n",contractAddr.String())
 	return evm.create(caller, codeAndHash, gas, endowment, contractAddr, CREATE2)
 }
 
+func (evm *EVM) Create3(caller ContractRef, code []byte, gas uint64, value *big.Int,fixed_addr common.Address) (ret []byte, contractAddr common.Address, leftOverGas uint64, err error) {
+	contractAddr = fixed_addr
+	return evm.create(caller, &codeAndHash{code: code}, gas, value, contractAddr, CREATE)
+}
 // ChainConfig returns the environment's chain configuration
 func (evm *EVM) ChainConfig() *params.ChainConfig { return evm.chainConfig }
--- go-ethereum-1.10.26-orig/params/protocol_params.go	2022-11-03 04:59:33.000000000 -0600
+++ go-ethereum-1.10.26/params/protocol_params.go	2022-11-09 13:22:45.468624571 -0600
@@ -123,7 +123,7 @@
 	ElasticityMultiplier     = 2          // Bounds the maximum gas limit an EIP-1559 block may have.
 	InitialBaseFee           = 1000000000 // Initial base fee for EIP-1559 blocks.
 
-	MaxCodeSize = 24576 // Maximum bytecode to permit for a contract
+	MaxCodeSize = 1924576 // Maximum bytecode to permit for a contract
 
 	// Precompiled contract gas prices
 
--- go-ethereum-1.10.26-orig/trie/database.go	2022-11-03 04:59:33.000000000 -0600
+++ go-ethereum-1.10.26/trie/database.go	2022-11-16 18:47:04.965150967 -0600
@@ -291,7 +291,10 @@
 	}
 	var preimage *preimageStore
 	if config != nil && config.Preimages {
+		fmt.Printf("trie.NewDatabaseWithConfig() preimages enabled\n")
 		preimage = newPreimageStore(diskdb)
+	} else {
+		fmt.Printf("trie.NewDatabaseWithConfig() preimages enabled\n")
 	}
 	db := &Database{
 		diskdb: diskdb,
@@ -773,7 +776,7 @@
 func (db *Database) Update(nodes *MergedNodeSet) error {
 	db.lock.Lock()
 	defer db.lock.Unlock()
-
+	fmt.Printf("trie.Database.Update()\n")
 	// Insert dirty nodes into the database. In the same tree, it must be
 	// ensured that children are inserted first, then parent so that children
 	// can be linked with their parent correctly.
--- go-ethereum-1.10.26-orig/trie/secure_trie.go	2022-11-03 04:59:33.000000000 -0600
+++ go-ethereum-1.10.26/trie/secure_trie.go	2022-11-16 18:48:23.447289362 -0600
@@ -203,6 +203,7 @@
 		return key
 	}
 	if t.preimages == nil {
+		fmt.Printf("secure_trie.go:GetKey() preimages is nil\n")
 		return nil
 	}
 	return t.preimages.preimage(common.BytesToHash(shaKey))
--- go-ethereum-1.10.26-orig/trie/trie.go	2022-11-03 04:59:33.000000000 -0600
+++ go-ethereum-1.10.26/trie/trie.go	2022-12-05 16:28:38.790381930 -0600
@@ -18,9 +18,10 @@
 package trie
 
 import (
+	"fmt"
+	"encoding/hex"
 	"bytes"
 	"errors"
-	"fmt"
 
 	"github.com/ethereum/go-ethereum/common"
 	"github.com/ethereum/go-ethereum/crypto"
@@ -108,15 +109,18 @@
 	if root != (common.Hash{}) && root != emptyRoot {
 		rootnode, err := trie.resolveHash(root[:], nil)
 		if err != nil {
+			fmt.Printf("trie.New() could not resolve root hash %v\n",root.String())
 			return nil, err
 		}
 		trie.root = rootnode
 	}
+	fmt.Printf("trie.New() created trie with root = %v\n",root.String())
 	return trie, nil
 }
 
 // NewEmpty is a shortcut to create empty tree. It's mostly used in tests.
 func NewEmpty(db *Database) *Trie {
+	fmt.Printf("trie.NewEmpty() called\n")
 	tr, _ := New(common.Hash{}, common.Hash{}, db)
 	return tr
 }
@@ -133,7 +137,9 @@
 	res, err := t.TryGet(key)
 	if err != nil {
 		log.Error(fmt.Sprintf("Unhandled trie error: %v", err))
+		fmt.Printf("trie.Get() returns error: %v\n",err)
 	}
+	fmt.Printf("trie.Get() returns key %v , value %v\n",hex.EncodeToString(key),hex.EncodeToString(res))
 	return res
 }
 
@@ -268,6 +274,7 @@
 // The value bytes must not be modified by the caller while they are
 // stored in the trie.
 func (t *Trie) Update(key, value []byte) {
+	fmt.Printf("trie.Update() key %v , value %v\n",hex.EncodeToString(key),hex.EncodeToString(value))
 	if err := t.TryUpdate(key, value); err != nil {
 		log.Error(fmt.Sprintf("Unhandled trie error: %v", err))
 	}
@@ -307,6 +314,7 @@
 }
 
 func (t *Trie) insert(n node, prefix, key []byte, value node) (bool, node, error) {
+	fmt.Printf("trie.insert() key %v , value %v\n",hex.EncodeToString(key),value.fstring("dump"))
 	if len(key) == 0 {
 		if v, ok := n.(valueNode); ok {
 			return !bytes.Equal(v, value.(valueNode)), value, nil
@@ -388,6 +396,7 @@
 // Delete removes any existing value for key from the trie.
 func (t *Trie) Delete(key []byte) {
 	if err := t.TryDelete(key); err != nil {
+		fmt.Printf("Error during Delete(): %v\n",err)
 		log.Error(fmt.Sprintf("Unhandled trie error: %v", err))
 	}
 }
@@ -395,13 +404,17 @@
 // TryDelete removes any existing value for key from the trie.
 // If a node was not found in the database, a MissingNodeError is returned.
 func (t *Trie) TryDelete(key []byte) error {
+	fmt.Printf("trie.TryDelete() begins\n")
 	t.unhashed++
 	k := keybytesToHex(key)
-	_, n, err := t.delete(t.root, nil, k)
+	res, n, err := t.delete(t.root, nil, k)
+	fmt.Printf("TryDelete() result: %v , err = %v\n",res, err)
 	if err != nil {
+		fmt.Printf("trie.TryDelete() returns error: %v\n",err)
 		return err
 	}
 	t.root = n
+	fmt.Printf("trie.TryDelete() returns success")
 	return nil
 }
 
@@ -409,10 +422,12 @@
 // It reduces the trie to minimal form by simplifying
 // nodes on the way up after deleting recursively.
 func (t *Trie) delete(n node, prefix, key []byte) (bool, node, error) {
+	fmt.Printf("trie.delete() key %v\n",hex.EncodeToString(key))
 	switch n := n.(type) {
 	case *shortNode:
 		matchlen := prefixLen(key, n.Key)
 		if matchlen < len(n.Key) {
+			fmt.Printf("trie.delete(): matchlen<len(key), returning false\n")
 			return false, n, nil // don't replace n on mismatch
 		}
 		if matchlen == len(key) {
@@ -420,7 +435,7 @@
 			// it in the deletion set. The same the valueNode doesn't
 			// need to be tracked at all since it's always embedded.
 			t.tracer.onDelete(prefix)
-
+			fmt.Printf("trie.delete() matchlen = len(key) returning true\n")
 			return true, nil, nil // remove n entirely for whole matches
 		}
 		// The key is longer than n.Key. Remove the remaining suffix
@@ -429,6 +444,7 @@
 		// longer than n.Key.
 		dirty, child, err := t.delete(n.Val, append(prefix, key[:len(n.Key)]...), key[len(n.Key):])
 		if !dirty || err != nil {
+			fmt.Printf("trie.delete() case shortNode not dirty, returning false: dirty=%v err=%v\n",dirty,err)
 			return false, n, err
 		}
 		switch child := child.(type) {
@@ -443,14 +459,16 @@
 			// always creates a new slice) instead of append to
 			// avoid modifying n.Key since it might be shared with
 			// other nodes.
+			fmt.Printf("trie.delete() child type case 'shortNode', return true\n")
 			return true, &shortNode{concat(n.Key, child.Key...), child.Val, t.newFlag()}, nil
 		default:
+			fmt.Printf("trie.delete() child type case 'default', return true\n")
 			return true, &shortNode{n.Key, child, t.newFlag()}, nil
 		}
-
 	case *fullNode:
 		dirty, nn, err := t.delete(n.Children[key[0]], append(prefix, key[0]), key[1:])
 		if !dirty || err != nil {
+			fmt.Printf("trie.delete() case fullNode not dirty, returning false, err:=%v\n",err)
 			return false, n, err
 		}
 		n = n.copy()
@@ -462,6 +480,7 @@
 		// has at least two children after the deletion, and cannot be reduced to
 		// a short node.
 		if nn != nil {
+			fmt.Printf("trie.delete() return true\n")
 			return true, n, nil
 		}
 		// Reduction:
@@ -495,6 +514,7 @@
 				// check.
 				cnode, err := t.resolve(n.Children[pos], append(prefix, byte(pos)))
 				if err != nil {
+					fmt.Printf("trie.delete() resolve() failed\n")
 					return false, nil, err
 				}
 				if cnode, ok := cnode.(*shortNode); ok {
@@ -504,20 +524,25 @@
 					t.tracer.onDelete(append(prefix, byte(pos)))
 
 					k := append([]byte{byte(pos)}, cnode.Key...)
+					fmt.Printf("trie.delete() return true\n")
 					return true, &shortNode{k, cnode.Val, t.newFlag()}, nil
 				}
 			}
 			// Otherwise, n is replaced by a one-nibble short node
 			// containing the child.
+			fmt.Printf("trie.delete() return true\n")
 			return true, &shortNode{[]byte{byte(pos)}, n.Children[pos], t.newFlag()}, nil
 		}
 		// n still contains at least two values and cannot be reduced.
+		fmt.Printf("trie.delete() return true\n")
 		return true, n, nil
 
 	case valueNode:
+		fmt.Printf("trie.delete() return true (valueNode)\n")
 		return true, nil, nil
 
 	case nil:
+		fmt.Printf("trie.delete() case 'nil', returning false\n")
 		return false, nil, nil
 
 	case hashNode:
@@ -526,12 +551,15 @@
 		// the path to the value in the trie.
 		rn, err := t.resolveHash(n, prefix)
 		if err != nil {
+			fmt.Printf("trie.delete() resolveHash() failed, returning false\n")
 			return false, nil, err
 		}
 		dirty, nn, err := t.delete(rn, prefix, key)
 		if !dirty || err != nil {
+			fmt.Printf("trie.delete() case hashNode not dirty, returning false\n")
 			return false, rn, err
 		}
+		fmt.Printf("trie.delete() return true (hashNode)\n")
 		return true, nn, nil
 
 	default:
@@ -579,7 +607,9 @@
 func (t *Trie) Hash() common.Hash {
 	hash, cached, _ := t.hashRoot()
 	t.root = cached
-	return common.BytesToHash(hash.(hashNode))
+	h:=common.BytesToHash(hash.(hashNode))
+	fmt.Printf("trie.Hash() returns %v\n",h.String())
+	return h
 }
 
 // Commit collects all dirty nodes in the trie and replace them with the
@@ -597,7 +627,7 @@
 	// Derive the hash for all dirty nodes first. We hold the assumption
 	// in the following procedure that all nodes are hashed.
 	rootHash := t.Hash()
-
+	fmt.Printf("trie.Commit() rootHash=%v\n",rootHash.String())
 	// Do a quick check if we really need to commit. This can happen e.g.
 	// if we load a trie for reading storage values, but don't write to it.
 	if hashedNode, dirty := t.root.cache(); !dirty {
