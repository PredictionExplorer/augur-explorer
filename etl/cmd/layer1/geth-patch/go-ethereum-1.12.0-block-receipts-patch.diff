--- go-ethereum-1.12.0/ethclient/ethclient.go	2023-05-25 10:01:00.000000000 +0000
+++ go-ethereum-1.12.0-patched/ethclient/ethclient.go	2023-06-20 15:15:12.109104785 +0000
@@ -305,6 +305,18 @@
 	return r, err
 }
 
+func (ec *Client) GetBlockReceipts(ctx context.Context, txHash common.Hash) (types.Receipts, error) {
+        var r types.Receipts
+        err := ec.c.CallContext(ctx, &r, "eth_getBlockReceipts", txHash)
+        if err == nil {
+                if r == nil {
+                        return nil, ethereum.NotFound
+                }
+        }
+        return r, err
+}
+
+
 // SyncProgress retrieves the current progress of the sync algorithm. If there's
 // no sync currently running, it returns nil.
 func (ec *Client) SyncProgress(ctx context.Context) (*ethereum.SyncProgress, error) {
--- go-ethereum-1.12.0/internal/ethapi/api.go	2023-05-25 10:01:00.000000000 +0000
+++ go-ethereum-1.12.0-patched/internal/ethapi/api.go	2023-06-20 16:08:27.210945546 +0000
@@ -1694,6 +1694,77 @@
 	return fields, nil
 }
 
+func (s *TransactionAPI) GetBlockReceipts(ctx context.Context, blocks_hash common.Hash) (types.ReceiptsPackage, error) {
+	var output types.ReceiptsPackage
+	receipts, err := s.b.GetReceipts(ctx, blocks_hash )
+	if err != nil {
+		return output, err
+	}
+	header, err := s.b.HeaderByHash(ctx, blocks_hash)
+	if err != nil {
+		return output, err
+	}
+	if header == nil {
+		return output,errors.New(fmt.Sprintf(("Header not found for provided block hash")))
+	}
+	output.Receipts = make([]types.PackedReceipt,0,512)
+	for i:=0; i<len(receipts);i++ {
+		// note: the body of this loop was copied from GetTransactionReceipt() function
+		receipt := receipts[i]
+		tx, blockHash, blockNumber, index, err := s.b.GetTransaction(ctx, receipt.TxHash)
+		if err != nil {
+			return output,err
+		}
+		if tx == nil {
+			return output,errors.New("Transaction not present in database")
+		}
+		if uint(len(receipts)) <= receipt.TransactionIndex {
+			return output,errors.New(fmt.Sprintf("Transaction index overflow for receipt %v\n",i))
+		}
+		// Derive the sender.
+		bigblock := new(big.Int).SetUint64(blockNumber)
+		signer := types.MakeSigner(s.b.ChainConfig(), bigblock, header.Time)
+		from, _ := types.Sender(signer, tx)
+
+		fields := map[string]interface{}{
+			"blockHash":         blockHash,
+			"blockNumber":       hexutil.Uint64(blockNumber),
+			"transactionHash":   receipt.TxHash,
+			"transactionIndex":  hexutil.Uint64(index),
+			"from":              from,
+			"to":                tx.To(),
+			"gasUsed":           hexutil.Uint64(receipt.GasUsed),
+			"cumulativeGasUsed": hexutil.Uint64(receipt.CumulativeGasUsed),
+			"contractAddress":   nil,
+			"logs":              receipt.Logs,
+			"logsBloom":         receipt.Bloom,
+			"type":              hexutil.Uint(tx.Type()),
+		}
+		// Assign the effective gas price paid
+		if !s.b.ChainConfig().IsLondon(bigblock) {
+			fields["effectiveGasPrice"] = hexutil.Uint64(tx.GasPrice().Uint64())
+		} else {
+			gasPrice := new(big.Int).Add(header.BaseFee, tx.EffectiveGasTipValue(header.BaseFee))
+			fields["effectiveGasPrice"] = hexutil.Uint64(gasPrice.Uint64())
+		}
+		// Assign receipt status or post state.
+		if len(receipt.PostState) > 0 {
+			fields["root"] = hexutil.Bytes(receipt.PostState)
+		} else {
+			fields["status"] = hexutil.Uint(receipt.Status)
+		}
+		if receipt.Logs == nil {
+			fields["logs"] = [][]*types.Log{}
+		}
+		// If the ContractAddress is 20 0x0 bytes, assume it is not a contract creation
+		if receipt.ContractAddress != (common.Address{}) {
+			fields["contractAddress"] = receipt.ContractAddress
+		}
+		output.Receipts = append(output.Receipts,fields)
+	}
+	return output,nil
+}
+
 // sign is a helper function that signs a transaction with the private key of the given address.
 func (s *TransactionAPI) sign(addr common.Address, tx *types.Transaction) (*types.Transaction, error) {
 	// Look up the wallet containing the requested signer
--- go-ethereum-1.12.0/core/types/receipt.go	2023-05-25 10:01:00.000000000 +0000
+++ go-ethereum-1.12.0-patched/core/types/receipt.go	2023-06-20 15:15:12.109104785 +0000
@@ -70,7 +70,10 @@
 	BlockNumber      *big.Int    `json:"blockNumber,omitempty"`
 	TransactionIndex uint        `json:"transactionIndex"`
 }
-
+type PackedReceipt map[string]interface{}
+type ReceiptsPackage struct {
+	Receipts		[]PackedReceipt
+}
 type receiptMarshaling struct {
 	Type              hexutil.Uint64
 	PostState         hexutil.Bytes
