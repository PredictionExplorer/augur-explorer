// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package contracts

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// ICosmicSignatureNftNftInfo is an auto generated low-level Go binding around an user-defined struct.
type ICosmicSignatureNftNftInfo struct {
	Name string
	Seed *big.Int
}

// CosmicSignatureNftMetaData contains all meta data concerning the CosmicSignatureNft contract.
var CosmicSignatureNftMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"game_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ERC721EnumerableForbiddenBatchMint\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ERC721IncorrectOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ERC721InsufficientApproval\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"ERC721InvalidApprover\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"ERC721InvalidOperator\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ERC721InvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ERC721InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ERC721InvalidSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ERC721NonexistentToken\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"ERC721OutOfBoundsIndex\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"errStr\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"nftNameLength\",\"type\":\"uint256\"}],\"name\":\"TooLongNftName\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"errStr\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"callerAddress\",\"type\":\"address\"}],\"name\":\"UnauthorizedCaller\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"errStr\",\"type\":\"string\"}],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newValue\",\"type\":\"string\"}],\"name\":\"NftBaseUriChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newValue\",\"type\":\"string\"}],\"name\":\"NftGenerationScriptUriChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundNum\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftOwnerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftSeed\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"NftMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"nftName\",\"type\":\"string\"}],\"name\":\"NftNameChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"game\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId_\",\"type\":\"uint256\"}],\"name\":\"getNftInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"}],\"internalType\":\"structICosmicSignatureNft.NftInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId_\",\"type\":\"uint256\"}],\"name\":\"getNftName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId_\",\"type\":\"uint256\"}],\"name\":\"getNftSeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundNum_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftOwnerAddress_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"randomNumberSeed_\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundNum_\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"nftOwnerAddresses_\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"randomNumberSeed_\",\"type\":\"uint256\"}],\"name\":\"mintMany\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftGenerationScriptUri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newValue_\",\"type\":\"string\"}],\"name\":\"setNftBaseUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newValue_\",\"type\":\"string\"}],\"name\":\"setNftGenerationScriptUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"nftName_\",\"type\":\"string\"}],\"name\":\"setNftName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x60a0604052346100465761001961001461010b565b610471565b61002161004b565b6134086108398239608051818181610d280152818161176b01526119d4015261340890f35b610051565b60405190565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b9061007d90610055565b810190811060018060401b0382111761009557604052565b61005f565b906100ad6100a661004b565b9283610073565b565b5f80fd5b60018060a01b031690565b6100c7906100b3565b90565b6100d3816100be565b036100da57565b5f80fd5b905051906100eb826100ca565b565b9060208282031261010657610103915f016100de565b90565b6100af565b610129613c418038038061011e8161009a565b9283398101906100ed565b90565b60018060401b03811161014857610144602091610055565b0190565b61005f565b9061015f61015a8361012c565b61009a565b918252565b5f7f436f736d69635369676e61747572654e66740000000000000000000000000000910152565b610195601261014d565b906101a260208301610164565b565b6101ac61018b565b90565b5f7f4353530000000000000000000000000000000000000000000000000000000000910152565b6101e0600361014d565b906101ed602083016101af565b565b6101f76101d6565b90565b634e487b7160e01b5f52602260045260245ffd5b906001600283049216801561022e575b602083101461022957565b6101fa565b91607f169161021e565b5f5260205f2090565b601f602091010490565b1b90565b9190600861026a9102916102645f198461024b565b9261024b565b9181191691161790565b90565b90565b61028e61028961029392610274565b610277565b610274565b90565b90565b91906102af6102aa6102b79361027a565b610296565b90835461024f565b9055565b5f90565b6102d1916102cb6102bb565b91610299565b565b5b8181106102df575050565b806102ec5f6001936102bf565b016102d4565b9190601f8111610302575b505050565b61030e61033393610238565b90602061031a84610241565b8301931061033b575b61032c90610241565b01906102d3565b5f80806102fd565b915061032c81929050610323565b61035e600a610358835461020e565b836102f2565b60147f697066733a2f2f54424400000000000000000000000000000000000000000000019055565b61038f90610349565b565b90565b6103a86103a36103ad92610391565b610277565b6100b3565b90565b6103b990610394565b90565b60209181520190565b5f7f5468652070726f76696465642061646472657373206973207a65726f2e000000910152565b6103f9601d6020926103bc565b610402816103c5565b0190565b61041b9060208101905f8183039101526103ec565b90565b8061043961043361042e5f6103b0565b6100be565b916100be565b14610449576104479061046c565b565b61045161004b565b63eac0d38960e01b81528061046860048201610406565b0390fd5b608052565b6104a5906104966104806101a4565b6104886101ef565b61049061071f565b916104a7565b6104a0600c610386565b61041e565b565b906104b292916104b4565b565b906104bf92916104c1565b565b906104cc92916104ce565b565b906104d992916104db565b565b906104e69291610650565b565b5190565b5f5260205f2090565b9190601f8111610505575b505050565b610511610536936104ec565b90602061051d84610241565b8301931061053e575b61052f90610241565b01906102d3565b5f8080610500565b915061052f81929050610526565b1c90565b90610560905f199060080261054c565b191690565b8161056f91610550565b906002021790565b90610581816104e8565b9060018060401b03821161063f576105a38261059d855461020e565b856104f5565b602090601f83116001146105d7579180916105c6935f926105cb575b5050610565565b90555b565b90915001515f806105bf565b601f198316916105e6856104ec565b925f5b8181106106275750916002939185600196941061060d575b505050020190556105c9565b61061d910151601f841690610550565b90555f8080610601565b919360206001819287870151815501950192016105e9565b61005f565b9061064e91610577565b565b6106679061066061066e94610670565b6001610644565b6002610644565b565b6106799061067b565b565b61068490610686565b565b61068f90610691565b565b61069a9061069c565b565b6106a5906106c9565b565b6106b0906100be565b9052565b91906106c7905f602085019401906106a7565b565b806106e46106de6106d95f6103b0565b6100be565b916100be565b146106f4576106f2906107d9565b565b6107176107005f6103b0565b5f918291631e4fbdf760e01b8352600483016106b4565b0390fd5b5f90565b61072761071b565b503390565b5f1c90565b60018060a01b031690565b61074861074d9161072c565b610731565b90565b61075a905461073c565b90565b5f1b90565b9061077360018060a01b039161075d565b9181191691161790565b61079161078c610796926100b3565b610277565b6100b3565b90565b6107a29061077d565b90565b6107ae90610799565b90565b90565b906107c96107c46107d0926107a5565b6107b1565b8254610762565b9055565b5f0190565b6107e25f610750565b6107ec825f6107b4565b9061082061081a7f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0936107a5565b916107a5565b9161082961004b565b80610833816107d4565b0390a356fe60806040526004361015610013575b610fae565b61001d5f356101ec565b806301ffc9a7146101e757806306fdde03146101e2578063081812fc146101dd57806308ab7be8146101d8578063095ea7b3146101d357806311c9f23b146101ce57806318160ddd146101c957806323b872dd146101c4578063278ec44f146101bf5780632f745c59146101ba57806342842e0e146101b55780634f6ccce7146101b05780636352211e146101ab5780636578f113146101a657806370a08231146101a1578063715018a61461019c578063836a1040146101975780638da5cb5b1461019257806395d89b411461018d578063a22cb46514610188578063b0c0fe4e14610183578063b88d4fde1461017e578063c3fe3e2814610179578063c87b56dd14610174578063d5ec2d831461016f578063e10a312d1461016a578063e985e9c514610165578063ee056e1d146101605763f2fde38b0361000e57610f7b565b610f47565b610ecc565b610e6c565b610e37565b610d7f565b610d4a565b610cef565b610bdf565b610bab565b610b26565b610af1565b610abb565b610a4e565b610a19565b6109c2565b6108f3565b6108be565b61088a565b610854565b61081f565b6107eb565b61077c565b610727565b61061a565b610590565b6103d9565b610327565b610278565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b63ffffffff60e01b1690565b61021981610204565b0361022057565b5f80fd5b9050359061023182610210565b565b9060208282031261024c57610249915f01610224565b90565b6101fc565b151590565b61025f90610251565b9052565b9190610276905f60208501940190610256565b565b346102a8576102a461029361028e366004610233565b610fb6565b61029b6101f2565b91829182610263565b0390f35b6101f8565b5f9103126102b757565b6101fc565b5190565b60209181520190565b90825f9392825e0152565b601f801991011690565b6102fd61030660209361030b936102f4816102bc565b938480936102c0565b958691016102c9565b6102d4565b0190565b6103249160208201915f8184039101526102de565b90565b34610357576103373660046102ad565b610353610342611007565b61034a6101f2565b9182918261030f565b0390f35b6101f8565b90565b6103688161035c565b0361036f57565b5f80fd5b905035906103808261035f565b565b9060208282031261039b57610398915f01610373565b90565b6101fc565b60018060a01b031690565b6103b4906103a0565b90565b6103c0906103ab565b9052565b91906103d7905f602085019401906103b7565b565b34610409576104056103f46103ef366004610382565b611021565b6103fc6101f2565b918291826103c4565b0390f35b6101f8565b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52602260045260245ffd5b9060016002830492168015610455575b602083101461045057565b610421565b91607f1691610445565b60209181520190565b5f5260205f2090565b905f929180549061048b61048483610435565b809461045f565b916001811690815f146104e257506001146104a6575b505050565b6104b39192939450610468565b915f925b8184106104ca57505001905f80806104a1565b600181602092959395548486015201910192906104b7565b92949550505060ff19168252151560200201905f80806104a1565b9061050791610471565b90565b634e487b7160e01b5f52604160045260245ffd5b90610528906102d4565b810190811067ffffffffffffffff82111761054257604052565b61050a565b90610567610560926105576101f2565b938480926104fd565b038361051e565b565b905f1061057c5761057990610547565b90565b61040e565b61058d600c5f90610569565b90565b346105c0576105a03660046102ad565b6105bc6105ab610581565b6105b36101f2565b9182918261030f565b0390f35b6101f8565b6105ce816103ab565b036105d557565b5f80fd5b905035906105e6826105c5565b565b9190604083820312610610578061060461060d925f86016105d9565b93602001610373565b90565b6101fc565b5f0190565b346106495761063361062d3660046105e8565b90611040565b61063b6101f2565b8061064581610615565b0390f35b6101f8565b5f80fd5b5f80fd5b906106696106626101f2565b928361051e565b565b67ffffffffffffffff8111610689576106856020916102d4565b0190565b61050a565b90825f939282370152565b909291926106ae6106a98261066b565b610656565b938185526020850190828401116106ca576106c89261068e565b565b610652565b9080601f830112156106ed578160206106ea93359101610699565b90565b61064e565b90602082820312610722575f82013567ffffffffffffffff811161071d5761071a92016106cf565b90565b610200565b6101fc565b346107555761073f61073a3660046106f2565b6112ba565b6107476101f2565b8061075181610615565b0390f35b6101f8565b6107639061035c565b9052565b919061077a905f6020850194019061075a565b565b346107ac5761078c3660046102ad565b6107a86107976112c9565b61079f6101f2565b91829182610767565b0390f35b6101f8565b90916060828403126107e6576107e36107cc845f85016105d9565b936107da81602086016105d9565b93604001610373565b90565b6101fc565b3461081a576108046107fe3660046107b1565b9161133c565b61080c6101f2565b8061081681610615565b0390f35b6101f8565b3461084f5761084b61083a610835366004610382565b611424565b6108426101f2565b9182918261030f565b0390f35b6101f8565b346108855761088161087061086a3660046105e8565b906114f2565b6108786101f2565b91829182610767565b0390f35b6101f8565b346108b9576108a361089d3660046107b1565b91611587565b6108ab6101f2565b806108b581610615565b0390f35b6101f8565b346108ee576108ea6108d96108d4366004610382565b6115f4565b6108e16101f2565b91829182610767565b0390f35b6101f8565b346109235761091f61090e610909366004610382565b61165b565b6109166101f2565b918291826103c4565b0390f35b6101f8565b5f80fd5b5f80fd5b909182601f8301121561096a5781359167ffffffffffffffff831161096557602001926020830284011161096057565b61092c565b610928565b61064e565b906060828203126109bd57610986815f8401610373565b92602083013567ffffffffffffffff81116109b8576109aa836109b5928601610930565b939094604001610373565b90565b610200565b6101fc565b346109f6576109f26109e16109d836600461096f565b929190916118f8565b6109e96101f2565b91829182610767565b0390f35b6101f8565b90602082820312610a1457610a11915f016105d9565b90565b6101fc565b34610a4957610a45610a34610a2f3660046109fb565b611925565b610a3c6101f2565b91829182610767565b0390f35b6101f8565b34610a7c57610a5e3660046102ad565b610a666119b0565b610a6e6101f2565b80610a7881610615565b0390f35b6101f8565b9091606082840312610ab657610ab3610a9c845f8501610373565b93610aaa81602086016105d9565b93604001610373565b90565b6101fc565b34610aec57610ae8610ad7610ad1366004610a81565b91611a27565b610adf6101f2565b91829182610767565b0390f35b6101f8565b34610b2157610b013660046102ad565b610b1d610b0c611a69565b610b146101f2565b918291826103c4565b0390f35b6101f8565b34610b5657610b363660046102ad565b610b52610b41611a7e565b610b496101f2565b9182918261030f565b0390f35b6101f8565b610b6481610251565b03610b6b57565b5f80fd5b90503590610b7c82610b5b565b565b9190604083820312610ba65780610b9a610ba3925f86016105d9565b93602001610b6f565b90565b6101fc565b34610bda57610bc4610bbe366004610b7e565b90611a94565b610bcc6101f2565b80610bd681610615565b0390f35b6101f8565b34610c0f57610c0b610bfa610bf5366004610382565b611aaa565b610c026101f2565b91829182610767565b0390f35b6101f8565b67ffffffffffffffff8111610c3257610c2e6020916102d4565b0190565b61050a565b90929192610c4c610c4782610c14565b610656565b93818552602085019082840111610c6857610c669261068e565b565b610652565b9080601f83011215610c8b57816020610c8893359101610c37565b90565b61064e565b90608082820312610cea57610ca7815f84016105d9565b92610cb582602085016105d9565b92610cc38360408301610373565b92606082013567ffffffffffffffff8111610ce557610ce29201610c6d565b90565b610200565b6101fc565b34610d2157610d0b610d02366004610c90565b92919091611acd565b610d136101f2565b80610d1d81610615565b0390f35b6101f8565b7f000000000000000000000000000000000000000000000000000000000000000090565b34610d7a57610d5a3660046102ad565b610d76610d65610d26565b610d6d6101f2565b918291826103c4565b0390f35b6101f8565b34610daf57610dab610d9a610d95366004610382565b611b6f565b610da26101f2565b9182918261030f565b0390f35b6101f8565b610dd3610ddc602093610de193610dca816102bc565b9384809361045f565b958691016102c9565b6102d4565b0190565b610dee9061035c565b9052565b90610e1c90602080610e11604084015f8701518582035f870152610db4565b940151910190610de5565b90565b610e349160208201915f818403910152610df2565b90565b34610e6757610e63610e52610e4d366004610382565b611c78565b610e5a6101f2565b91829182610e1f565b0390f35b6101f8565b34610e9a57610e84610e7f3660046106f2565b611cf1565b610e8c6101f2565b80610e9681610615565b0390f35b6101f8565b9190604083820312610ec75780610ebb610ec4925f86016105d9565b936020016105d9565b90565b6101fc565b34610efd57610ef9610ee8610ee2366004610e9f565b90611d4f565b610ef06101f2565b91829182610263565b0390f35b6101f8565b919091604081840312610f4257610f1b835f8301610373565b92602082013567ffffffffffffffff8111610f3d57610f3a92016106cf565b90565b610200565b6101fc565b34610f7657610f60610f5a366004610f02565b90611e37565b610f686101f2565b80610f7281610615565b0390f35b6101f8565b34610fa957610f93610f8e3660046109fb565b611f59565b610f9b6101f2565b80610fa581610615565b0390f35b6101f8565b5f80fd5b5f90565b610fbe610fb2565b5080610fd9610fd363780e9d6360e01b610204565b91610204565b14908115610fe6575b5090565b610ff09150611f64565b5f610fe2565b606090565b61100490610547565b90565b61100f610ff6565b5061101a6001610ffb565b90565b5f90565b61103d9061102d61101d565b5061103781611fcc565b50612038565b90565b90611054919061104e612057565b91612064565b565b61106790611062612074565b611274565b565b601f602091010490565b1b90565b9190600861109291029161108c5f1984611073565b92611073565b9181191691161790565b90565b6110b36110ae6110b89261035c565b61109c565b61035c565b90565b90565b91906110d46110cf6110dc9361109f565b6110bb565b908354611077565b9055565b5f90565b6110f6916110f06110e0565b916110be565b565b5b818110611104575050565b806111115f6001936110e4565b016110f9565b9190601f8111611127575b505050565b61113361115893610468565b90602061113f84611069565b83019310611160575b61115190611069565b01906110f8565b5f8080611122565b915061115181929050611148565b1c90565b90611182905f199060080261116e565b191690565b8161119191611172565b906002021790565b906111a3816102bc565b9067ffffffffffffffff8211611263576111c7826111c18554610435565b85611117565b602090601f83116001146111fb579180916111ea935f926111ef575b5050611187565b90555b565b90915001515f806111e3565b601f1983169161120a85610468565b925f5b81811061124b57509160029391856001969410611231575b505050020190556111ed565b611241910151601f841690611172565b90555f8080611225565b9193602060018192878701518155019501920161120d565b61050a565b9061127291611199565b565b61127f81600c611268565b6112b57f27e2bd70f498920ee0fd7d8204ae8845b75dc81330e3acafa32946be3503730c916112ac6101f2565b9182918261030f565b0390a1565b6112c390611056565b565b5490565b6112d16110e0565b506112dc60096112c5565b90565b90565b6112f66112f16112fb926112df565b61109c565b6103a0565b90565b611307906112e2565b90565b60409061133361133a949695939661132960608401985f8501906103b7565b602083019061075a565b01906103b7565b565b91908061135961135361134e5f6112fe565b6103ab565b916103ab565b146113b057611371908261136b612057565b916120c2565b918261138561137f836103ab565b916103ab565b0361138f57505050565b6113ac9091925f9384936364283d7b60e01b85526004850161130a565b0390fd5b6113d36113bc5f6112fe565b5f918291633250574960e11b8352600483016103c4565b0390fd5b634e487b7160e01b5f52603260045260245ffd5b506801000000000000000090565b90565b611405816113eb565b82101561141f576114176002916113f9565b910201905f90565b6113d7565b5f61143c61144392611434610ff6565b50600d6113fc565b5001610ffb565b90565b91602061146792949361146060408201965f8301906103b7565b019061075a565b565b61147d611478611482926103a0565b61109c565b6103a0565b90565b61148e90611469565b90565b61149a90611485565b90565b906114a790611491565b5f5260205260405f2090565b906114bd9061109f565b5f5260205260405f2090565b5f1c90565b90565b6114dd6114e2916114c9565b6114ce565b90565b6114ef90546114d1565b90565b6114fa6110e0565b508161151661151061150b84611925565b61035c565b9161035c565b101561153b576115389161152e61153392600761149d565b6114b3565b6114e5565b90565b6115555f92839263295f44f760e21b845260048401611446565b0390fd5b9061156b6115668361066b565b610656565b918252565b6115795f611559565b90565b611584611570565b90565b9161159b929161159561157c565b92611acd565b565b5f5260205f2090565b6115af816112c5565b8210156115c9576115c160019161159d565b910201905f90565b6113d7565b6115de9060086115e3930261116e565b6114ce565b90565b906115f191546115ce565b90565b6115fc6110e0565b508061161761161161160c6112c9565b61035c565b9161035c565b10156116345761162b6116319160096115a6565b906115e6565b90565b61163d5f6112fe565b6116575f92839263295f44f760e21b845260048401611446565b0390fd5b61166d9061166761101d565b50611fcc565b90565b60407f6d6574686f642e00000000000000000000000000000000000000000000000000917f4f6e6c792074686520436f736d69635369676e617475726547616d6520636f6e5f8201527f7472616374206973207065726d697474656420746f2063616c6c20746869732060208201520152565b6116f060476060926102c0565b6116f981611670565b0190565b9190611720906020611718604086018681035f8801526116e3565b9401906103b7565b565b1561172a5750565b61174c906117366101f2565b91829163ced50f6760e01b8352600483016116fd565b0390fd5b906117a9949392916117a4611763612057565b61179561178f7f00000000000000000000000000000000000000000000000000000000000000006103ab565b916103ab565b1461179e612057565b90611722565b61181c565b90565b5090565b6117c46117bf6117c9926112df565b61109c565b61035c565b90565b91908110156117dc576020020190565b6113d7565b356117eb816105c5565b90565b90565b61180561180061180a926117ee565b61109c565b61035c565b90565b6001611819910161035c565b90565b92909192506118296110e0565b936118358483906117ac565b6118476118415f6117b0565b9161035c565b11611854575b5050505090565b9091929493506118818361187a611875888661186f5f6117b0565b916117cc565b6117e1565b83916121d1565b9361188c60016117f1565b915b826118ab6118a56118a08a88906117ac565b61035c565b9161035c565b10156118e9576118bd6118e39161180d565b926118dd866118d66118d18b8986916117cc565b6117e1565b86916121d1565b5061180d565b9161188e565b5094505050505f80808061184d565b9061190c9392916119076110e0565b611750565b90565b9061191990611491565b5f5260205260405f2090565b61192d6110e0565b508061194961194361193e5f6112fe565b6103ab565b916103ab565b146119645761195c61196191600461190f565b6114e5565b90565b6119876119705f6112fe565b5f9182916322718ad960e21b8352600483016103c4565b0390fd5b611993612074565b61199b61199d565b565b6119ae6119a95f6112fe565b6122a9565b565b6119b861198b565b565b90611a12939291611a0d6119cc612057565b6119fe6119f87f00000000000000000000000000000000000000000000000000000000000000006103ab565b916103ab565b14611a07612057565b90611722565b611a15565b90565b90611a249391509190916121d1565b90565b90611a3a9291611a356110e0565b6119ba565b90565b60018060a01b031690565b611a54611a59916114c9565b611a3d565b90565b611a669054611a48565b90565b611a7161101d565b50611a7b5f611a5c565b90565b611a86610ff6565b50611a916002610ffb565b90565b611aa891611aa0612057565b91909161234d565b565b6001611ac3611aca92611abb6110e0565b50600d6113fc565b50016114e5565b90565b91611ae9939192611ae08185849161133c565b92909192612517565b565b90565b5190565b611afa611570565b90565b905090565b611b27611b1e92602092611b15816102bc565b94858093611afd565b938491016102c9565b0190565b611b3990611b3f9392611b02565b90611b02565b90565b611b619291611b6d91611b536101f2565b948592602084019283611b2b565b9081038252038361051e565b565b611b77610ff6565b50611b8181611fcc565b50611b8a612672565b90611b9c611b9783611aeb565b611aee565b611bae611ba85f6117b0565b9161035c565b115f14611bcc57611bc2611bc89291612726565b90611b42565b5b90565b5050611bd6611af2565b611bc9565b611be56040610656565b90565b606090565b5f90565b611bf9611bdb565b9060208083611c06611be8565b815201611c11611bed565b81525050565b611c1f611bf1565b90565b52565b90611c2f9061035c565b9052565b90611c6a611c616001611c44611bdb565b94611c5b611c535f8301610547565b5f8801611c22565b016114e5565b60208401611c25565b565b611c7590611c33565b90565b611c8f611c9591611c87611c17565b50600d6113fc565b50611c6c565b90565b611ca990611ca4612074565b611cab565b565b611cb681600b611268565b611cec7fbdfd815215fcee5bb949c941ab489c7ead076a7c8acd3527cd1b50f613ac67e691611ce36101f2565b9182918261030f565b0390a1565b611cfa90611c98565b565b90611d0690611491565b5f5260205260405f2090565b90611d1c90611491565b5f5260205260405f2090565b60ff1690565b611d3a611d3f916114c9565b611d28565b90565b611d4c9054611d2e565b90565b611d7491611d6a611d6f92611d62610fb2565b506006611cfc565b611d12565b611d42565b90565b90565b611d8e611d89611d9392611d77565b61109c565b61035c565b90565b611da06020611d7a565b90565b5f7f4e4654206e616d6520697320746f6f206c6f6e672e0000000000000000000000910152565b611dd760156020926102c0565b611de081611da3565b0190565b9190611e07906020611dff604086018681035f880152611dca565b94019061075a565b565b15611e115750565b611e3390611e1d6101f2565b91829163c237685160e01b835260048301611de4565b0390fd5b611e52611e43826127cf565b611e4b612057565b83916127ee565b611e98611e66611e6184611aeb565b611aee565b611e7f611e79611e74611d96565b61035c565b9161035c565b1115611e92611e8d85611aeb565b611aee565b90611e09565b611eb0825f611ea9600d85906113fc565b5001611268565b611eef611edd7fa14cfb0fe69c0b55eaaa4d9400bdba2a72e1860cade89c2a8a055e6cfde8936d9261109f565b92611ee66101f2565b9182918261030f565b0390a2565b611f0590611f00612074565b611f07565b565b80611f22611f1c611f175f6112fe565b6103ab565b916103ab565b14611f3257611f30906122a9565b565b611f55611f3e5f6112fe565b5f918291631e4fbdf760e01b8352600483016103c4565b0390fd5b611f6290611ef4565b565b611f6c610fb2565b5080611f87611f816380ac58cd60e01b610204565b91610204565b148015611fab575b908115611f9b575b5090565b611fa5915061286a565b5f611f97565b5080611fc6611fc0635b5e139f60e01b610204565b91610204565b14611f8f565b611fd461101d565b50611fde816127cf565b9081611ffa611ff4611fef5f6112fe565b6103ab565b916103ab565b14612003575090565b61201e905f918291637e27328960e01b835260048301610767565b0390fd5b9061202c9061109f565b5f5260205260405f2090565b61204f6120549161204761101d565b506005612022565b611a5c565b90565b61205f61101d565b503390565b916120729291600192612890565b565b61207c611a69565b61209561208f61208a612057565b6103ab565b916103ab565b0361209c57565b6120be6120a7612057565b5f91829163118cdaa760e01b8352600483016103c4565b0390fd5b90916120db906120d061101d565b5082908490916129e8565b91826120f76120f16120ec5f6112fe565b6103ab565b916103ab565b145f146121685761210781612c98565b5b8161212361211d6121185f6112fe565b6103ab565b916103ab565b145f14612138576121349150612d99565b5b90565b8261214b612145846103ab565b916103ab565b03612158575b5050612135565b61216191612d04565b5f80612151565b8261217b612175846103ab565b916103ab565b03612186575b612108565b612191838290612b69565b612181565b5f1b90565b906121a75f1991612196565b9181191691161790565b906121c66121c16121cd9261109f565b6110bb565b825461219b565b9055565b906121da6110e0565b506121f76121e66112c9565b936121f2838690612e30565b612ed4565b9161221183600161220a600d88906113fc565b50016121b1565b90839161226561225361224d6122477fc2115f21464937bfdcd1560f96f0e20b70e88accbdcd1069084c80c8797ef1069461109f565b94611491565b9461109f565b9461225c6101f2565b91829182610767565b0390a490565b9061227c60018060a01b0391612196565b9181191691161790565b90565b9061229e6122996122a592611491565b612286565b825461226b565b9055565b6122b25f611a5c565b6122bc825f612289565b906122f06122ea7f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e093611491565b91611491565b916122f96101f2565b8061230381610615565b0390a3565b9061231460ff91612196565b9181191691161790565b61232790610251565b90565b90565b9061234261233d6123499261231e565b61232a565b8254612308565b9055565b9190918261236b6123656123605f6112fe565b6103ab565b916103ab565b146123df5761238f8261238a61238360068590611cfc565b8690611d12565b61232d565b9190916123da6123c86123c27f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c3193611491565b93611491565b936123d16101f2565b91829182610263565b0390a3565b6123fa835f918291630b61174360e31b8352600483016103c4565b0390fd5b61240790611469565b90565b612413906123fe565b90565b61241f90611485565b90565b60e01b90565b9050519061243582610210565b565b906020828203126124505761244d915f01612428565b90565b6101fc565b60209181520190565b61247d61248660209361248b9361247481611aee565b93848093612455565b958691016102c9565b6102d4565b0190565b90926124c2906124b86124cf96946124ae60808601975f8701906103b7565b60208501906103b7565b604083019061075a565b606081840391015261245e565b90565b906124e46124df83610c14565b610656565b918252565b606090565b3d5f14612509576124fe3d6124d2565b903d5f602084013e5b565b6125116124e9565b90612507565b929092833b61252e6125285f6117b0565b9161035c565b1161253a575b50505050565b60209161257a5f61255261254d8861240a565b612416565b9261258563150b7a0291612564612057565b969861256e6101f2565b998a9889978896612422565b86526004860161248f565b03925af180915f92612642575b50155f146125ff575060016125ac57505b5f808080612534565b6125b46124ee565b906125be82611aee565b6125d06125ca5f6117b0565b9161035c565b145f146125f6576125f2905f918291633250574960e11b8352600483016103c4565b0390fd5b50805190602001fd5b612618612612630a85bd0160e11b610204565b91610204565b0361262357506125a3565b61263e905f918291633250574960e11b8352600483016103c4565b0390fd5b61266491925060203d811161266b575b61265c818361051e565b810190612437565b905f612592565b503d612652565b61267a610ff6565b50612685600b610ffb565b90565b90612693910161035c565b90565b369037565b906126c06126a883611559565b926020806126b6869361066b565b9201910390612696565b565b60016126ce910361035c565b90565b90565b6126e86126e36126ed926126d1565b61109c565b61035c565b90565b634e487b7160e01b5f52601260045260245ffd5b6127106127169161035c565b9161035c565b908115612721570490565b6126f0565b61272e610ff6565b5061274b61273b8261303e565b61274560016117f1565b90612688565b906127558261269b565b9161275e6110e0565b5060200182015b6001156127c8576127786127a4916126c2565b916f181899199a1a9b1b9c1cb0b131b232b360811b600a82061a835361279e600a6126d4565b90612704565b806127b76127b15f6117b0565b9161035c565b146127c25790612765565b50505b90565b50506127c5565b6127e66127eb916127de61101d565b506003612022565b611a5c565b90565b6128036127fd8284869161329f565b15610251565b61280c57505050565b61282661282061281b5f6112fe565b6103ab565b916103ab565b145f1461284c57612848825f918291637e27328960e01b835260048301610767565b0390fd5b6128665f92839263177e802f60e01b845260048401611446565b0390fd5b612872610fb2565b5061288c6128866301ffc9a760e01b610204565b91610204565b1490565b9190928080156129b7575b6128b9575b5050906128b26128b792916005612022565b612289565b565b6128c284611fcc565b91806128de6128d86128d35f6112fe565b6103ab565b916103ab565b14158061299c575b80612982575b6129635750916128b2916128b79493612908575b5091926128a0565b81849061294761294161293b7f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92595611491565b92611491565b9261109f565b926129506101f2565b8061295a81610615565b0390a45f612900565b61297e905f91829163a9fbf51f60e01b8352600483016103c4565b0390fd5b50612997612991848390611d4f565b15610251565b6128ec565b50826129b06129aa836103ab565b916103ab565b14156128e6565b50816129d36129cd6129c85f6112fe565b6103ab565b916103ab565b141561289b565b906129e5910361035c565b90565b906129f161101d565b506129fb816127cf565b9280612a17612a11612a0c5f6112fe565b6103ab565b916103ab565b03612b56575b5082612a39612a33612a2e5f6112fe565b6103ab565b916103ab565b03612b02575b81612a5a612a54612a4f5f6112fe565b6103ab565b916103ab565b03612acc575b612a7582612a7060038490612022565b612289565b8291612ab3612aad612aa77fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef95611491565b92611491565b9261109f565b92612abc6101f2565b80612ac681610615565b0390a490565b612afd612ad960016117f1565b612af7612ae86004869061190f565b91612af2836114e5565b612688565b906121b1565b612a60565b612b20612b0e5f6112fe565b82612b185f6112fe565b905f92612890565b612b51612b2d60016117f1565b612b4b612b3c6004879061190f565b91612b46836114e5565b6129da565b906121b1565b612a3f565b612b6390849083916127ee565b5f612a1d565b612bcc612bd192612bc75f93612bc085612bbb612b8584611925565b95612b9a612b95600883906114b3565b6114e5565b80612bad612ba78a61035c565b9161035c565b03612bd3575b5060086114b3565b6110e4565b600761149d565b6114b3565b6110e4565b565b612c2590612c20612bf8612bf3612bec60078b9061149d565b8c906114b3565b6114e5565b91612c1883612c13612c0c60078d9061149d565b84906114b3565b6121b1565b9160086114b3565b6121b1565b5f612bb3565b90565b5f5260205f2090565b5490565b612c4481612c37565b821015612c5e57612c56600191612c2e565b910201905f90565b6113d7565b9081549168010000000000000000831015612c935782612c8b916001612c9195018155612c3b565b906110be565b565b61050a565b612cc990612cba612ca960096112c5565b612cb5600a84906114b3565b6121b1565b612cc46009612c2b565b612c63565b565b634e487b7160e01b5f52601160045260245ffd5b612cee612cf49193929361035c565b9261035c565b8203918211612cff57565b612ccb565b90612d4f612d5492612d47612d2b612d1b83611925565b612d2560016117f1565b90612cdf565b91612d42612d3b8692600761149d565b84906114b3565b6121b1565b9160086114b3565b6121b1565b565b634e487b7160e01b5f52603160045260245ffd5b612d7381612c37565b8015612d94576001900390612d91612d8b8383612c3b565b906110e4565b55565b612d56565b5f612e17612e1c92612e10612dc1612db160096112c5565b612dbb60016117f1565b90612cdf565b612e0b612dec612de6612dde612dd9600a88906114b3565b6114e5565b9360096115a6565b906115e6565b91612e0383612dfd600984906115a6565b906110be565b91600a6114b3565b6121b1565b600a6114b3565b6110e4565b612e2e612e296009612c2b565b612d6a565b565b9081612e4c612e46612e415f6112fe565b6103ab565b916103ab565b14612ead57612e659190612e5f5f6112fe565b916120c2565b612e7f612e79612e745f6112fe565b6103ab565b916103ab565b03612e8657565b612ea9612e925f6112fe565b5f9182916339e3563760e11b8352600483016103c4565b0390fd5b612ed0612eb95f6112fe565b5f918291633250574960e11b8352600483016103c4565b0390fd5b612ee690612ee06110e0565b50613381565b90565b90565b612f00612efb612f0592612ee9565b61109c565b61035c565b90565b90565b612f1f612f1a612f2492612f08565b61109c565b61035c565b90565b90565b612f3e612f39612f4392612f27565b61109c565b61035c565b90565b90565b612f5d612f58612f6292612f46565b61109c565b61035c565b90565b90565b612f7c612f77612f8192612f65565b61109c565b61035c565b90565b90565b612f9b612f96612fa092612f84565b61109c565b61035c565b90565b90565b612fba612fb5612fbf92612fa3565b61109c565b61035c565b90565b90565b612fd9612fd4612fde92612fc2565b61109c565b61035c565b90565b90565b612ff8612ff3612ffd92612fe1565b61109c565b61035c565b90565b90565b61301761301261301c92613000565b61109c565b61035c565b90565b90565b61303661303161303b9261301f565b61109c565b61035c565b90565b6130466110e0565b506130505f6117b0565b908061307f6130797a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000612eec565b9161035c565b1015613257575b806130a76130a16d04ee2d6d415b85acef8100000000612f2a565b9161035c565b101561321c575b806130c86130c2662386f26fc10000612f49565b9161035c565b10156131e8575b806130e66130e06305f5e100612f87565b9161035c565b10156131b7575b806131026130fc612710612fc5565b9161035c565b1015613188575b8061311d6131176064613003565b9161035c565b101561315a575b613137613131600a6126d4565b9161035c565b1015613141575b90565b6131559061314f60016117f1565b90612688565b61313e565b6131716131829161316b6064613003565b90612704565b9161317c6002613022565b90612688565b90613124565b6131a06131b19161319a612710612fc5565b90612704565b916131ab6004612fe4565b90612688565b90613109565b6131d16131e2916131cb6305f5e100612f87565b90612704565b916131dc6008612fa6565b90612688565b906130ed565b613205613216916131ff662386f26fc10000612f49565b90612704565b916132106010612f68565b90612688565b906130cf565b6132406132519161323a6d04ee2d6d415b85acef8100000000612f2a565b90612704565b9161324b6020611d7a565b90612688565b906130ae565b613288613299916132827a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000612eec565b90612704565b916132936040612f0b565b90612688565b90613086565b91906132a9610fb2565b50806132c56132bf6132ba5f6112fe565b6103ab565b916103ab565b141592836132d4575b50505090565b80919293506132eb6132e5846103ab565b916103ab565b1490811561332d575b50918215613307575b50505f80806132ce565b61332591925061331961331f91612038565b926103ab565b916103ab565b145f806132fd565b61333991508290611d4f565b5f6132f4565b90565b61334e6133539161035c565b61333f565b9052565b61336381602093613342565b0190565b60200190565b61337961337e916114c9565b61109f565b90565b6133a86133b76133cf926133936110e0565b5061339c6101f2565b92839160208301613357565b6020820181038252038261051e565b6133c96133c382611aee565b91613367565b2061336d565b9056fea26469706673582212205203fdf8f23890a1ed5c093b92eb92a8ecbbddb31387598f7df680975513bb7e64736f6c634300081c0033",
}

// CosmicSignatureNftABI is the input ABI used to generate the binding from.
// Deprecated: Use CosmicSignatureNftMetaData.ABI instead.
var CosmicSignatureNftABI = CosmicSignatureNftMetaData.ABI

// CosmicSignatureNftBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use CosmicSignatureNftMetaData.Bin instead.
var CosmicSignatureNftBin = CosmicSignatureNftMetaData.Bin

// DeployCosmicSignatureNft deploys a new Ethereum contract, binding an instance of CosmicSignatureNft to it.
func DeployCosmicSignatureNft(auth *bind.TransactOpts, backend bind.ContractBackend, game_ common.Address) (common.Address, *types.Transaction, *CosmicSignatureNft, error) {
	parsed, err := CosmicSignatureNftMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(CosmicSignatureNftBin), backend, game_)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &CosmicSignatureNft{CosmicSignatureNftCaller: CosmicSignatureNftCaller{contract: contract}, CosmicSignatureNftTransactor: CosmicSignatureNftTransactor{contract: contract}, CosmicSignatureNftFilterer: CosmicSignatureNftFilterer{contract: contract}}, nil
}

// CosmicSignatureNft is an auto generated Go binding around an Ethereum contract.
type CosmicSignatureNft struct {
	CosmicSignatureNftCaller     // Read-only binding to the contract
	CosmicSignatureNftTransactor // Write-only binding to the contract
	CosmicSignatureNftFilterer   // Log filterer for contract events
}

// CosmicSignatureNftCaller is an auto generated read-only Go binding around an Ethereum contract.
type CosmicSignatureNftCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CosmicSignatureNftTransactor is an auto generated write-only Go binding around an Ethereum contract.
type CosmicSignatureNftTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CosmicSignatureNftFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type CosmicSignatureNftFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CosmicSignatureNftSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type CosmicSignatureNftSession struct {
	Contract     *CosmicSignatureNft // Generic contract binding to set the session for
	CallOpts     bind.CallOpts       // Call options to use throughout this session
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// CosmicSignatureNftCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type CosmicSignatureNftCallerSession struct {
	Contract *CosmicSignatureNftCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts             // Call options to use throughout this session
}

// CosmicSignatureNftTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type CosmicSignatureNftTransactorSession struct {
	Contract     *CosmicSignatureNftTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts             // Transaction auth options to use throughout this session
}

// CosmicSignatureNftRaw is an auto generated low-level Go binding around an Ethereum contract.
type CosmicSignatureNftRaw struct {
	Contract *CosmicSignatureNft // Generic contract binding to access the raw methods on
}

// CosmicSignatureNftCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type CosmicSignatureNftCallerRaw struct {
	Contract *CosmicSignatureNftCaller // Generic read-only contract binding to access the raw methods on
}

// CosmicSignatureNftTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type CosmicSignatureNftTransactorRaw struct {
	Contract *CosmicSignatureNftTransactor // Generic write-only contract binding to access the raw methods on
}

// NewCosmicSignatureNft creates a new instance of CosmicSignatureNft, bound to a specific deployed contract.
func NewCosmicSignatureNft(address common.Address, backend bind.ContractBackend) (*CosmicSignatureNft, error) {
	contract, err := bindCosmicSignatureNft(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNft{CosmicSignatureNftCaller: CosmicSignatureNftCaller{contract: contract}, CosmicSignatureNftTransactor: CosmicSignatureNftTransactor{contract: contract}, CosmicSignatureNftFilterer: CosmicSignatureNftFilterer{contract: contract}}, nil
}

// NewCosmicSignatureNftCaller creates a new read-only instance of CosmicSignatureNft, bound to a specific deployed contract.
func NewCosmicSignatureNftCaller(address common.Address, caller bind.ContractCaller) (*CosmicSignatureNftCaller, error) {
	contract, err := bindCosmicSignatureNft(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftCaller{contract: contract}, nil
}

// NewCosmicSignatureNftTransactor creates a new write-only instance of CosmicSignatureNft, bound to a specific deployed contract.
func NewCosmicSignatureNftTransactor(address common.Address, transactor bind.ContractTransactor) (*CosmicSignatureNftTransactor, error) {
	contract, err := bindCosmicSignatureNft(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftTransactor{contract: contract}, nil
}

// NewCosmicSignatureNftFilterer creates a new log filterer instance of CosmicSignatureNft, bound to a specific deployed contract.
func NewCosmicSignatureNftFilterer(address common.Address, filterer bind.ContractFilterer) (*CosmicSignatureNftFilterer, error) {
	contract, err := bindCosmicSignatureNft(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftFilterer{contract: contract}, nil
}

// bindCosmicSignatureNft binds a generic wrapper to an already deployed contract.
func bindCosmicSignatureNft(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := CosmicSignatureNftMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_CosmicSignatureNft *CosmicSignatureNftRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _CosmicSignatureNft.Contract.CosmicSignatureNftCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_CosmicSignatureNft *CosmicSignatureNftRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.CosmicSignatureNftTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_CosmicSignatureNft *CosmicSignatureNftRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.CosmicSignatureNftTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_CosmicSignatureNft *CosmicSignatureNftCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _CosmicSignatureNft.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_CosmicSignatureNft *CosmicSignatureNftTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_CosmicSignatureNft *CosmicSignatureNftTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.contract.Transact(opts, method, params...)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) BalanceOf(opts *bind.CallOpts, owner common.Address) (*big.Int, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "balanceOf", owner)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftSession) BalanceOf(owner common.Address) (*big.Int, error) {
	return _CosmicSignatureNft.Contract.BalanceOf(&_CosmicSignatureNft.CallOpts, owner)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) BalanceOf(owner common.Address) (*big.Int, error) {
	return _CosmicSignatureNft.Contract.BalanceOf(&_CosmicSignatureNft.CallOpts, owner)
}

// Game is a free data retrieval call binding the contract method 0xc3fe3e28.
//
// Solidity: function game() view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) Game(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "game")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Game is a free data retrieval call binding the contract method 0xc3fe3e28.
//
// Solidity: function game() view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftSession) Game() (common.Address, error) {
	return _CosmicSignatureNft.Contract.Game(&_CosmicSignatureNft.CallOpts)
}

// Game is a free data retrieval call binding the contract method 0xc3fe3e28.
//
// Solidity: function game() view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) Game() (common.Address, error) {
	return _CosmicSignatureNft.Contract.Game(&_CosmicSignatureNft.CallOpts)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) GetApproved(opts *bind.CallOpts, tokenId *big.Int) (common.Address, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "getApproved", tokenId)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftSession) GetApproved(tokenId *big.Int) (common.Address, error) {
	return _CosmicSignatureNft.Contract.GetApproved(&_CosmicSignatureNft.CallOpts, tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) GetApproved(tokenId *big.Int) (common.Address, error) {
	return _CosmicSignatureNft.Contract.GetApproved(&_CosmicSignatureNft.CallOpts, tokenId)
}

// GetNftInfo is a free data retrieval call binding the contract method 0xd5ec2d83.
//
// Solidity: function getNftInfo(uint256 nftId_) view returns((string,uint256))
func (_CosmicSignatureNft *CosmicSignatureNftCaller) GetNftInfo(opts *bind.CallOpts, nftId_ *big.Int) (ICosmicSignatureNftNftInfo, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "getNftInfo", nftId_)

	if err != nil {
		return *new(ICosmicSignatureNftNftInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(ICosmicSignatureNftNftInfo)).(*ICosmicSignatureNftNftInfo)

	return out0, err

}

// GetNftInfo is a free data retrieval call binding the contract method 0xd5ec2d83.
//
// Solidity: function getNftInfo(uint256 nftId_) view returns((string,uint256))
func (_CosmicSignatureNft *CosmicSignatureNftSession) GetNftInfo(nftId_ *big.Int) (ICosmicSignatureNftNftInfo, error) {
	return _CosmicSignatureNft.Contract.GetNftInfo(&_CosmicSignatureNft.CallOpts, nftId_)
}

// GetNftInfo is a free data retrieval call binding the contract method 0xd5ec2d83.
//
// Solidity: function getNftInfo(uint256 nftId_) view returns((string,uint256))
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) GetNftInfo(nftId_ *big.Int) (ICosmicSignatureNftNftInfo, error) {
	return _CosmicSignatureNft.Contract.GetNftInfo(&_CosmicSignatureNft.CallOpts, nftId_)
}

// GetNftName is a free data retrieval call binding the contract method 0x278ec44f.
//
// Solidity: function getNftName(uint256 nftId_) view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) GetNftName(opts *bind.CallOpts, nftId_ *big.Int) (string, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "getNftName", nftId_)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// GetNftName is a free data retrieval call binding the contract method 0x278ec44f.
//
// Solidity: function getNftName(uint256 nftId_) view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftSession) GetNftName(nftId_ *big.Int) (string, error) {
	return _CosmicSignatureNft.Contract.GetNftName(&_CosmicSignatureNft.CallOpts, nftId_)
}

// GetNftName is a free data retrieval call binding the contract method 0x278ec44f.
//
// Solidity: function getNftName(uint256 nftId_) view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) GetNftName(nftId_ *big.Int) (string, error) {
	return _CosmicSignatureNft.Contract.GetNftName(&_CosmicSignatureNft.CallOpts, nftId_)
}

// GetNftSeed is a free data retrieval call binding the contract method 0xb0c0fe4e.
//
// Solidity: function getNftSeed(uint256 nftId_) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) GetNftSeed(opts *bind.CallOpts, nftId_ *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "getNftSeed", nftId_)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetNftSeed is a free data retrieval call binding the contract method 0xb0c0fe4e.
//
// Solidity: function getNftSeed(uint256 nftId_) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftSession) GetNftSeed(nftId_ *big.Int) (*big.Int, error) {
	return _CosmicSignatureNft.Contract.GetNftSeed(&_CosmicSignatureNft.CallOpts, nftId_)
}

// GetNftSeed is a free data retrieval call binding the contract method 0xb0c0fe4e.
//
// Solidity: function getNftSeed(uint256 nftId_) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) GetNftSeed(nftId_ *big.Int) (*big.Int, error) {
	return _CosmicSignatureNft.Contract.GetNftSeed(&_CosmicSignatureNft.CallOpts, nftId_)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) IsApprovedForAll(opts *bind.CallOpts, owner common.Address, operator common.Address) (bool, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "isApprovedForAll", owner, operator)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_CosmicSignatureNft *CosmicSignatureNftSession) IsApprovedForAll(owner common.Address, operator common.Address) (bool, error) {
	return _CosmicSignatureNft.Contract.IsApprovedForAll(&_CosmicSignatureNft.CallOpts, owner, operator)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) IsApprovedForAll(owner common.Address, operator common.Address) (bool, error) {
	return _CosmicSignatureNft.Contract.IsApprovedForAll(&_CosmicSignatureNft.CallOpts, owner, operator)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) Name(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "name")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftSession) Name() (string, error) {
	return _CosmicSignatureNft.Contract.Name(&_CosmicSignatureNft.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) Name() (string, error) {
	return _CosmicSignatureNft.Contract.Name(&_CosmicSignatureNft.CallOpts)
}

// NftGenerationScriptUri is a free data retrieval call binding the contract method 0x08ab7be8.
//
// Solidity: function nftGenerationScriptUri() view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) NftGenerationScriptUri(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "nftGenerationScriptUri")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// NftGenerationScriptUri is a free data retrieval call binding the contract method 0x08ab7be8.
//
// Solidity: function nftGenerationScriptUri() view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftSession) NftGenerationScriptUri() (string, error) {
	return _CosmicSignatureNft.Contract.NftGenerationScriptUri(&_CosmicSignatureNft.CallOpts)
}

// NftGenerationScriptUri is a free data retrieval call binding the contract method 0x08ab7be8.
//
// Solidity: function nftGenerationScriptUri() view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) NftGenerationScriptUri() (string, error) {
	return _CosmicSignatureNft.Contract.NftGenerationScriptUri(&_CosmicSignatureNft.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftSession) Owner() (common.Address, error) {
	return _CosmicSignatureNft.Contract.Owner(&_CosmicSignatureNft.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) Owner() (common.Address, error) {
	return _CosmicSignatureNft.Contract.Owner(&_CosmicSignatureNft.CallOpts)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) OwnerOf(opts *bind.CallOpts, tokenId *big.Int) (common.Address, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "ownerOf", tokenId)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftSession) OwnerOf(tokenId *big.Int) (common.Address, error) {
	return _CosmicSignatureNft.Contract.OwnerOf(&_CosmicSignatureNft.CallOpts, tokenId)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) OwnerOf(tokenId *big.Int) (common.Address, error) {
	return _CosmicSignatureNft.Contract.OwnerOf(&_CosmicSignatureNft.CallOpts, tokenId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "supportsInterface", interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_CosmicSignatureNft *CosmicSignatureNftSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _CosmicSignatureNft.Contract.SupportsInterface(&_CosmicSignatureNft.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _CosmicSignatureNft.Contract.SupportsInterface(&_CosmicSignatureNft.CallOpts, interfaceId)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) Symbol(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "symbol")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftSession) Symbol() (string, error) {
	return _CosmicSignatureNft.Contract.Symbol(&_CosmicSignatureNft.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) Symbol() (string, error) {
	return _CosmicSignatureNft.Contract.Symbol(&_CosmicSignatureNft.CallOpts)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 index) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) TokenByIndex(opts *bind.CallOpts, index *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "tokenByIndex", index)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 index) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftSession) TokenByIndex(index *big.Int) (*big.Int, error) {
	return _CosmicSignatureNft.Contract.TokenByIndex(&_CosmicSignatureNft.CallOpts, index)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 index) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) TokenByIndex(index *big.Int) (*big.Int, error) {
	return _CosmicSignatureNft.Contract.TokenByIndex(&_CosmicSignatureNft.CallOpts, index)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address owner, uint256 index) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) TokenOfOwnerByIndex(opts *bind.CallOpts, owner common.Address, index *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "tokenOfOwnerByIndex", owner, index)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address owner, uint256 index) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftSession) TokenOfOwnerByIndex(owner common.Address, index *big.Int) (*big.Int, error) {
	return _CosmicSignatureNft.Contract.TokenOfOwnerByIndex(&_CosmicSignatureNft.CallOpts, owner, index)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address owner, uint256 index) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) TokenOfOwnerByIndex(owner common.Address, index *big.Int) (*big.Int, error) {
	return _CosmicSignatureNft.Contract.TokenOfOwnerByIndex(&_CosmicSignatureNft.CallOpts, owner, index)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 tokenId) view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) TokenURI(opts *bind.CallOpts, tokenId *big.Int) (string, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "tokenURI", tokenId)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 tokenId) view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftSession) TokenURI(tokenId *big.Int) (string, error) {
	return _CosmicSignatureNft.Contract.TokenURI(&_CosmicSignatureNft.CallOpts, tokenId)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 tokenId) view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) TokenURI(tokenId *big.Int) (string, error) {
	return _CosmicSignatureNft.Contract.TokenURI(&_CosmicSignatureNft.CallOpts, tokenId)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftSession) TotalSupply() (*big.Int, error) {
	return _CosmicSignatureNft.Contract.TotalSupply(&_CosmicSignatureNft.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) TotalSupply() (*big.Int, error) {
	return _CosmicSignatureNft.Contract.TotalSupply(&_CosmicSignatureNft.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) Approve(opts *bind.TransactOpts, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "approve", to, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_CosmicSignatureNft *CosmicSignatureNftSession) Approve(to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.Approve(&_CosmicSignatureNft.TransactOpts, to, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) Approve(to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.Approve(&_CosmicSignatureNft.TransactOpts, to, tokenId)
}

// Mint is a paid mutator transaction binding the contract method 0x836a1040.
//
// Solidity: function mint(uint256 roundNum_, address nftOwnerAddress_, uint256 randomNumberSeed_) returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) Mint(opts *bind.TransactOpts, roundNum_ *big.Int, nftOwnerAddress_ common.Address, randomNumberSeed_ *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "mint", roundNum_, nftOwnerAddress_, randomNumberSeed_)
}

// Mint is a paid mutator transaction binding the contract method 0x836a1040.
//
// Solidity: function mint(uint256 roundNum_, address nftOwnerAddress_, uint256 randomNumberSeed_) returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftSession) Mint(roundNum_ *big.Int, nftOwnerAddress_ common.Address, randomNumberSeed_ *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.Mint(&_CosmicSignatureNft.TransactOpts, roundNum_, nftOwnerAddress_, randomNumberSeed_)
}

// Mint is a paid mutator transaction binding the contract method 0x836a1040.
//
// Solidity: function mint(uint256 roundNum_, address nftOwnerAddress_, uint256 randomNumberSeed_) returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) Mint(roundNum_ *big.Int, nftOwnerAddress_ common.Address, randomNumberSeed_ *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.Mint(&_CosmicSignatureNft.TransactOpts, roundNum_, nftOwnerAddress_, randomNumberSeed_)
}

// MintMany is a paid mutator transaction binding the contract method 0x6578f113.
//
// Solidity: function mintMany(uint256 roundNum_, address[] nftOwnerAddresses_, uint256 randomNumberSeed_) returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) MintMany(opts *bind.TransactOpts, roundNum_ *big.Int, nftOwnerAddresses_ []common.Address, randomNumberSeed_ *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "mintMany", roundNum_, nftOwnerAddresses_, randomNumberSeed_)
}

// MintMany is a paid mutator transaction binding the contract method 0x6578f113.
//
// Solidity: function mintMany(uint256 roundNum_, address[] nftOwnerAddresses_, uint256 randomNumberSeed_) returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftSession) MintMany(roundNum_ *big.Int, nftOwnerAddresses_ []common.Address, randomNumberSeed_ *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.MintMany(&_CosmicSignatureNft.TransactOpts, roundNum_, nftOwnerAddresses_, randomNumberSeed_)
}

// MintMany is a paid mutator transaction binding the contract method 0x6578f113.
//
// Solidity: function mintMany(uint256 roundNum_, address[] nftOwnerAddresses_, uint256 randomNumberSeed_) returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) MintMany(roundNum_ *big.Int, nftOwnerAddresses_ []common.Address, randomNumberSeed_ *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.MintMany(&_CosmicSignatureNft.TransactOpts, roundNum_, nftOwnerAddresses_, randomNumberSeed_)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_CosmicSignatureNft *CosmicSignatureNftSession) RenounceOwnership() (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.RenounceOwnership(&_CosmicSignatureNft.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.RenounceOwnership(&_CosmicSignatureNft.TransactOpts)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) SafeTransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "safeTransferFrom", from, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_CosmicSignatureNft *CosmicSignatureNftSession) SafeTransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SafeTransferFrom(&_CosmicSignatureNft.TransactOpts, from, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) SafeTransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SafeTransferFrom(&_CosmicSignatureNft.TransactOpts, from, to, tokenId)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) SafeTransferFrom0(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "safeTransferFrom0", from, to, tokenId, data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_CosmicSignatureNft *CosmicSignatureNftSession) SafeTransferFrom0(from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SafeTransferFrom0(&_CosmicSignatureNft.TransactOpts, from, to, tokenId, data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) SafeTransferFrom0(from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SafeTransferFrom0(&_CosmicSignatureNft.TransactOpts, from, to, tokenId, data)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) SetApprovalForAll(opts *bind.TransactOpts, operator common.Address, approved bool) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "setApprovalForAll", operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_CosmicSignatureNft *CosmicSignatureNftSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SetApprovalForAll(&_CosmicSignatureNft.TransactOpts, operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SetApprovalForAll(&_CosmicSignatureNft.TransactOpts, operator, approved)
}

// SetNftBaseUri is a paid mutator transaction binding the contract method 0xe10a312d.
//
// Solidity: function setNftBaseUri(string newValue_) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) SetNftBaseUri(opts *bind.TransactOpts, newValue_ string) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "setNftBaseUri", newValue_)
}

// SetNftBaseUri is a paid mutator transaction binding the contract method 0xe10a312d.
//
// Solidity: function setNftBaseUri(string newValue_) returns()
func (_CosmicSignatureNft *CosmicSignatureNftSession) SetNftBaseUri(newValue_ string) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SetNftBaseUri(&_CosmicSignatureNft.TransactOpts, newValue_)
}

// SetNftBaseUri is a paid mutator transaction binding the contract method 0xe10a312d.
//
// Solidity: function setNftBaseUri(string newValue_) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) SetNftBaseUri(newValue_ string) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SetNftBaseUri(&_CosmicSignatureNft.TransactOpts, newValue_)
}

// SetNftGenerationScriptUri is a paid mutator transaction binding the contract method 0x11c9f23b.
//
// Solidity: function setNftGenerationScriptUri(string newValue_) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) SetNftGenerationScriptUri(opts *bind.TransactOpts, newValue_ string) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "setNftGenerationScriptUri", newValue_)
}

// SetNftGenerationScriptUri is a paid mutator transaction binding the contract method 0x11c9f23b.
//
// Solidity: function setNftGenerationScriptUri(string newValue_) returns()
func (_CosmicSignatureNft *CosmicSignatureNftSession) SetNftGenerationScriptUri(newValue_ string) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SetNftGenerationScriptUri(&_CosmicSignatureNft.TransactOpts, newValue_)
}

// SetNftGenerationScriptUri is a paid mutator transaction binding the contract method 0x11c9f23b.
//
// Solidity: function setNftGenerationScriptUri(string newValue_) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) SetNftGenerationScriptUri(newValue_ string) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SetNftGenerationScriptUri(&_CosmicSignatureNft.TransactOpts, newValue_)
}

// SetNftName is a paid mutator transaction binding the contract method 0xee056e1d.
//
// Solidity: function setNftName(uint256 nftId_, string nftName_) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) SetNftName(opts *bind.TransactOpts, nftId_ *big.Int, nftName_ string) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "setNftName", nftId_, nftName_)
}

// SetNftName is a paid mutator transaction binding the contract method 0xee056e1d.
//
// Solidity: function setNftName(uint256 nftId_, string nftName_) returns()
func (_CosmicSignatureNft *CosmicSignatureNftSession) SetNftName(nftId_ *big.Int, nftName_ string) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SetNftName(&_CosmicSignatureNft.TransactOpts, nftId_, nftName_)
}

// SetNftName is a paid mutator transaction binding the contract method 0xee056e1d.
//
// Solidity: function setNftName(uint256 nftId_, string nftName_) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) SetNftName(nftId_ *big.Int, nftName_ string) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SetNftName(&_CosmicSignatureNft.TransactOpts, nftId_, nftName_)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "transferFrom", from, to, tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_CosmicSignatureNft *CosmicSignatureNftSession) TransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.TransferFrom(&_CosmicSignatureNft.TransactOpts, from, to, tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) TransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.TransferFrom(&_CosmicSignatureNft.TransactOpts, from, to, tokenId)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_CosmicSignatureNft *CosmicSignatureNftSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.TransferOwnership(&_CosmicSignatureNft.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.TransferOwnership(&_CosmicSignatureNft.TransactOpts, newOwner)
}

// CosmicSignatureNftApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the CosmicSignatureNft contract.
type CosmicSignatureNftApprovalIterator struct {
	Event *CosmicSignatureNftApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureNftApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureNftApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureNftApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureNftApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureNftApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureNftApproval represents a Approval event raised by the CosmicSignatureNft contract.
type CosmicSignatureNftApproval struct {
	Owner    common.Address
	Approved common.Address
	TokenId  *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, approved []common.Address, tokenId []*big.Int) (*CosmicSignatureNftApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.FilterLogs(opts, "Approval", ownerRule, approvedRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftApprovalIterator{contract: _CosmicSignatureNft.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *CosmicSignatureNftApproval, owner []common.Address, approved []common.Address, tokenId []*big.Int) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.WatchLogs(opts, "Approval", ownerRule, approvedRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureNftApproval)
				if err := _CosmicSignatureNft.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) ParseApproval(log types.Log) (*CosmicSignatureNftApproval, error) {
	event := new(CosmicSignatureNftApproval)
	if err := _CosmicSignatureNft.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureNftApprovalForAllIterator is returned from FilterApprovalForAll and is used to iterate over the raw logs and unpacked data for ApprovalForAll events raised by the CosmicSignatureNft contract.
type CosmicSignatureNftApprovalForAllIterator struct {
	Event *CosmicSignatureNftApprovalForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureNftApprovalForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureNftApprovalForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureNftApprovalForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureNftApprovalForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureNftApprovalForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureNftApprovalForAll represents a ApprovalForAll event raised by the CosmicSignatureNft contract.
type CosmicSignatureNftApprovalForAll struct {
	Owner    common.Address
	Operator common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApprovalForAll is a free log retrieval operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) FilterApprovalForAll(opts *bind.FilterOpts, owner []common.Address, operator []common.Address) (*CosmicSignatureNftApprovalForAllIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.FilterLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftApprovalForAllIterator{contract: _CosmicSignatureNft.contract, event: "ApprovalForAll", logs: logs, sub: sub}, nil
}

// WatchApprovalForAll is a free log subscription operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *CosmicSignatureNftApprovalForAll, owner []common.Address, operator []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.WatchLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureNftApprovalForAll)
				if err := _CosmicSignatureNft.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApprovalForAll is a log parse operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) ParseApprovalForAll(log types.Log) (*CosmicSignatureNftApprovalForAll, error) {
	event := new(CosmicSignatureNftApprovalForAll)
	if err := _CosmicSignatureNft.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureNftNftBaseUriChangedIterator is returned from FilterNftBaseUriChanged and is used to iterate over the raw logs and unpacked data for NftBaseUriChanged events raised by the CosmicSignatureNft contract.
type CosmicSignatureNftNftBaseUriChangedIterator struct {
	Event *CosmicSignatureNftNftBaseUriChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureNftNftBaseUriChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureNftNftBaseUriChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureNftNftBaseUriChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureNftNftBaseUriChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureNftNftBaseUriChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureNftNftBaseUriChanged represents a NftBaseUriChanged event raised by the CosmicSignatureNft contract.
type CosmicSignatureNftNftBaseUriChanged struct {
	NewValue string
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterNftBaseUriChanged is a free log retrieval operation binding the contract event 0xbdfd815215fcee5bb949c941ab489c7ead076a7c8acd3527cd1b50f613ac67e6.
//
// Solidity: event NftBaseUriChanged(string newValue)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) FilterNftBaseUriChanged(opts *bind.FilterOpts) (*CosmicSignatureNftNftBaseUriChangedIterator, error) {

	logs, sub, err := _CosmicSignatureNft.contract.FilterLogs(opts, "NftBaseUriChanged")
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftNftBaseUriChangedIterator{contract: _CosmicSignatureNft.contract, event: "NftBaseUriChanged", logs: logs, sub: sub}, nil
}

// WatchNftBaseUriChanged is a free log subscription operation binding the contract event 0xbdfd815215fcee5bb949c941ab489c7ead076a7c8acd3527cd1b50f613ac67e6.
//
// Solidity: event NftBaseUriChanged(string newValue)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) WatchNftBaseUriChanged(opts *bind.WatchOpts, sink chan<- *CosmicSignatureNftNftBaseUriChanged) (event.Subscription, error) {

	logs, sub, err := _CosmicSignatureNft.contract.WatchLogs(opts, "NftBaseUriChanged")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureNftNftBaseUriChanged)
				if err := _CosmicSignatureNft.contract.UnpackLog(event, "NftBaseUriChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseNftBaseUriChanged is a log parse operation binding the contract event 0xbdfd815215fcee5bb949c941ab489c7ead076a7c8acd3527cd1b50f613ac67e6.
//
// Solidity: event NftBaseUriChanged(string newValue)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) ParseNftBaseUriChanged(log types.Log) (*CosmicSignatureNftNftBaseUriChanged, error) {
	event := new(CosmicSignatureNftNftBaseUriChanged)
	if err := _CosmicSignatureNft.contract.UnpackLog(event, "NftBaseUriChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureNftNftGenerationScriptUriChangedIterator is returned from FilterNftGenerationScriptUriChanged and is used to iterate over the raw logs and unpacked data for NftGenerationScriptUriChanged events raised by the CosmicSignatureNft contract.
type CosmicSignatureNftNftGenerationScriptUriChangedIterator struct {
	Event *CosmicSignatureNftNftGenerationScriptUriChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureNftNftGenerationScriptUriChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureNftNftGenerationScriptUriChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureNftNftGenerationScriptUriChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureNftNftGenerationScriptUriChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureNftNftGenerationScriptUriChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureNftNftGenerationScriptUriChanged represents a NftGenerationScriptUriChanged event raised by the CosmicSignatureNft contract.
type CosmicSignatureNftNftGenerationScriptUriChanged struct {
	NewValue string
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterNftGenerationScriptUriChanged is a free log retrieval operation binding the contract event 0x27e2bd70f498920ee0fd7d8204ae8845b75dc81330e3acafa32946be3503730c.
//
// Solidity: event NftGenerationScriptUriChanged(string newValue)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) FilterNftGenerationScriptUriChanged(opts *bind.FilterOpts) (*CosmicSignatureNftNftGenerationScriptUriChangedIterator, error) {

	logs, sub, err := _CosmicSignatureNft.contract.FilterLogs(opts, "NftGenerationScriptUriChanged")
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftNftGenerationScriptUriChangedIterator{contract: _CosmicSignatureNft.contract, event: "NftGenerationScriptUriChanged", logs: logs, sub: sub}, nil
}

// WatchNftGenerationScriptUriChanged is a free log subscription operation binding the contract event 0x27e2bd70f498920ee0fd7d8204ae8845b75dc81330e3acafa32946be3503730c.
//
// Solidity: event NftGenerationScriptUriChanged(string newValue)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) WatchNftGenerationScriptUriChanged(opts *bind.WatchOpts, sink chan<- *CosmicSignatureNftNftGenerationScriptUriChanged) (event.Subscription, error) {

	logs, sub, err := _CosmicSignatureNft.contract.WatchLogs(opts, "NftGenerationScriptUriChanged")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureNftNftGenerationScriptUriChanged)
				if err := _CosmicSignatureNft.contract.UnpackLog(event, "NftGenerationScriptUriChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseNftGenerationScriptUriChanged is a log parse operation binding the contract event 0x27e2bd70f498920ee0fd7d8204ae8845b75dc81330e3acafa32946be3503730c.
//
// Solidity: event NftGenerationScriptUriChanged(string newValue)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) ParseNftGenerationScriptUriChanged(log types.Log) (*CosmicSignatureNftNftGenerationScriptUriChanged, error) {
	event := new(CosmicSignatureNftNftGenerationScriptUriChanged)
	if err := _CosmicSignatureNft.contract.UnpackLog(event, "NftGenerationScriptUriChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureNftNftMintedIterator is returned from FilterNftMinted and is used to iterate over the raw logs and unpacked data for NftMinted events raised by the CosmicSignatureNft contract.
type CosmicSignatureNftNftMintedIterator struct {
	Event *CosmicSignatureNftNftMinted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureNftNftMintedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureNftNftMinted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureNftNftMinted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureNftNftMintedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureNftNftMintedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureNftNftMinted represents a NftMinted event raised by the CosmicSignatureNft contract.
type CosmicSignatureNftNftMinted struct {
	RoundNum        *big.Int
	NftOwnerAddress common.Address
	NftSeed         *big.Int
	NftId           *big.Int
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterNftMinted is a free log retrieval operation binding the contract event 0xc2115f21464937bfdcd1560f96f0e20b70e88accbdcd1069084c80c8797ef106.
//
// Solidity: event NftMinted(uint256 indexed roundNum, address indexed nftOwnerAddress, uint256 nftSeed, uint256 indexed nftId)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) FilterNftMinted(opts *bind.FilterOpts, roundNum []*big.Int, nftOwnerAddress []common.Address, nftId []*big.Int) (*CosmicSignatureNftNftMintedIterator, error) {

	var roundNumRule []interface{}
	for _, roundNumItem := range roundNum {
		roundNumRule = append(roundNumRule, roundNumItem)
	}
	var nftOwnerAddressRule []interface{}
	for _, nftOwnerAddressItem := range nftOwnerAddress {
		nftOwnerAddressRule = append(nftOwnerAddressRule, nftOwnerAddressItem)
	}

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.FilterLogs(opts, "NftMinted", roundNumRule, nftOwnerAddressRule, nftIdRule)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftNftMintedIterator{contract: _CosmicSignatureNft.contract, event: "NftMinted", logs: logs, sub: sub}, nil
}

// WatchNftMinted is a free log subscription operation binding the contract event 0xc2115f21464937bfdcd1560f96f0e20b70e88accbdcd1069084c80c8797ef106.
//
// Solidity: event NftMinted(uint256 indexed roundNum, address indexed nftOwnerAddress, uint256 nftSeed, uint256 indexed nftId)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) WatchNftMinted(opts *bind.WatchOpts, sink chan<- *CosmicSignatureNftNftMinted, roundNum []*big.Int, nftOwnerAddress []common.Address, nftId []*big.Int) (event.Subscription, error) {

	var roundNumRule []interface{}
	for _, roundNumItem := range roundNum {
		roundNumRule = append(roundNumRule, roundNumItem)
	}
	var nftOwnerAddressRule []interface{}
	for _, nftOwnerAddressItem := range nftOwnerAddress {
		nftOwnerAddressRule = append(nftOwnerAddressRule, nftOwnerAddressItem)
	}

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.WatchLogs(opts, "NftMinted", roundNumRule, nftOwnerAddressRule, nftIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureNftNftMinted)
				if err := _CosmicSignatureNft.contract.UnpackLog(event, "NftMinted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseNftMinted is a log parse operation binding the contract event 0xc2115f21464937bfdcd1560f96f0e20b70e88accbdcd1069084c80c8797ef106.
//
// Solidity: event NftMinted(uint256 indexed roundNum, address indexed nftOwnerAddress, uint256 nftSeed, uint256 indexed nftId)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) ParseNftMinted(log types.Log) (*CosmicSignatureNftNftMinted, error) {
	event := new(CosmicSignatureNftNftMinted)
	if err := _CosmicSignatureNft.contract.UnpackLog(event, "NftMinted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureNftNftNameChangedIterator is returned from FilterNftNameChanged and is used to iterate over the raw logs and unpacked data for NftNameChanged events raised by the CosmicSignatureNft contract.
type CosmicSignatureNftNftNameChangedIterator struct {
	Event *CosmicSignatureNftNftNameChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureNftNftNameChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureNftNftNameChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureNftNftNameChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureNftNftNameChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureNftNftNameChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureNftNftNameChanged represents a NftNameChanged event raised by the CosmicSignatureNft contract.
type CosmicSignatureNftNftNameChanged struct {
	NftId   *big.Int
	NftName string
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterNftNameChanged is a free log retrieval operation binding the contract event 0xa14cfb0fe69c0b55eaaa4d9400bdba2a72e1860cade89c2a8a055e6cfde8936d.
//
// Solidity: event NftNameChanged(uint256 indexed nftId, string nftName)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) FilterNftNameChanged(opts *bind.FilterOpts, nftId []*big.Int) (*CosmicSignatureNftNftNameChangedIterator, error) {

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.FilterLogs(opts, "NftNameChanged", nftIdRule)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftNftNameChangedIterator{contract: _CosmicSignatureNft.contract, event: "NftNameChanged", logs: logs, sub: sub}, nil
}

// WatchNftNameChanged is a free log subscription operation binding the contract event 0xa14cfb0fe69c0b55eaaa4d9400bdba2a72e1860cade89c2a8a055e6cfde8936d.
//
// Solidity: event NftNameChanged(uint256 indexed nftId, string nftName)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) WatchNftNameChanged(opts *bind.WatchOpts, sink chan<- *CosmicSignatureNftNftNameChanged, nftId []*big.Int) (event.Subscription, error) {

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.WatchLogs(opts, "NftNameChanged", nftIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureNftNftNameChanged)
				if err := _CosmicSignatureNft.contract.UnpackLog(event, "NftNameChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseNftNameChanged is a log parse operation binding the contract event 0xa14cfb0fe69c0b55eaaa4d9400bdba2a72e1860cade89c2a8a055e6cfde8936d.
//
// Solidity: event NftNameChanged(uint256 indexed nftId, string nftName)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) ParseNftNameChanged(log types.Log) (*CosmicSignatureNftNftNameChanged, error) {
	event := new(CosmicSignatureNftNftNameChanged)
	if err := _CosmicSignatureNft.contract.UnpackLog(event, "NftNameChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureNftOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the CosmicSignatureNft contract.
type CosmicSignatureNftOwnershipTransferredIterator struct {
	Event *CosmicSignatureNftOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureNftOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureNftOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureNftOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureNftOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureNftOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureNftOwnershipTransferred represents a OwnershipTransferred event raised by the CosmicSignatureNft contract.
type CosmicSignatureNftOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*CosmicSignatureNftOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftOwnershipTransferredIterator{contract: _CosmicSignatureNft.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *CosmicSignatureNftOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureNftOwnershipTransferred)
				if err := _CosmicSignatureNft.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) ParseOwnershipTransferred(log types.Log) (*CosmicSignatureNftOwnershipTransferred, error) {
	event := new(CosmicSignatureNftOwnershipTransferred)
	if err := _CosmicSignatureNft.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureNftTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the CosmicSignatureNft contract.
type CosmicSignatureNftTransferIterator struct {
	Event *CosmicSignatureNftTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureNftTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureNftTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureNftTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureNftTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureNftTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureNftTransfer represents a Transfer event raised by the CosmicSignatureNft contract.
type CosmicSignatureNftTransfer struct {
	From    common.Address
	To      common.Address
	TokenId *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenId []*big.Int) (*CosmicSignatureNftTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.FilterLogs(opts, "Transfer", fromRule, toRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftTransferIterator{contract: _CosmicSignatureNft.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *CosmicSignatureNftTransfer, from []common.Address, to []common.Address, tokenId []*big.Int) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.WatchLogs(opts, "Transfer", fromRule, toRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureNftTransfer)
				if err := _CosmicSignatureNft.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) ParseTransfer(log types.Log) (*CosmicSignatureNftTransfer, error) {
	event := new(CosmicSignatureNftTransfer)
	if err := _CosmicSignatureNft.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureNftMetaData contains all meta data concerning the ICosmicSignatureNft contract.
var ICosmicSignatureNftMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newValue\",\"type\":\"string\"}],\"name\":\"NftBaseUriChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newValue\",\"type\":\"string\"}],\"name\":\"NftGenerationScriptUriChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundNum\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftOwnerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftSeed\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"NftMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"nftName\",\"type\":\"string\"}],\"name\":\"NftNameChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId_\",\"type\":\"uint256\"}],\"name\":\"getNftInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"}],\"internalType\":\"structICosmicSignatureNft.NftInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId_\",\"type\":\"uint256\"}],\"name\":\"getNftName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId_\",\"type\":\"uint256\"}],\"name\":\"getNftSeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundNum_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftOwnerAddress_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"randomNumberSeed_\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundNum_\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"nftOwnerAddresses_\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"randomNumberSeed_\",\"type\":\"uint256\"}],\"name\":\"mintMany\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newValue_\",\"type\":\"string\"}],\"name\":\"setNftBaseUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newValue_\",\"type\":\"string\"}],\"name\":\"setNftGenerationScriptUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"nftName_\",\"type\":\"string\"}],\"name\":\"setNftName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// ICosmicSignatureNftABI is the input ABI used to generate the binding from.
// Deprecated: Use ICosmicSignatureNftMetaData.ABI instead.
var ICosmicSignatureNftABI = ICosmicSignatureNftMetaData.ABI

// ICosmicSignatureNft is an auto generated Go binding around an Ethereum contract.
type ICosmicSignatureNft struct {
	ICosmicSignatureNftCaller     // Read-only binding to the contract
	ICosmicSignatureNftTransactor // Write-only binding to the contract
	ICosmicSignatureNftFilterer   // Log filterer for contract events
}

// ICosmicSignatureNftCaller is an auto generated read-only Go binding around an Ethereum contract.
type ICosmicSignatureNftCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ICosmicSignatureNftTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ICosmicSignatureNftTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ICosmicSignatureNftFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ICosmicSignatureNftFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ICosmicSignatureNftSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ICosmicSignatureNftSession struct {
	Contract     *ICosmicSignatureNft // Generic contract binding to set the session for
	CallOpts     bind.CallOpts        // Call options to use throughout this session
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// ICosmicSignatureNftCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ICosmicSignatureNftCallerSession struct {
	Contract *ICosmicSignatureNftCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts              // Call options to use throughout this session
}

// ICosmicSignatureNftTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ICosmicSignatureNftTransactorSession struct {
	Contract     *ICosmicSignatureNftTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts              // Transaction auth options to use throughout this session
}

// ICosmicSignatureNftRaw is an auto generated low-level Go binding around an Ethereum contract.
type ICosmicSignatureNftRaw struct {
	Contract *ICosmicSignatureNft // Generic contract binding to access the raw methods on
}

// ICosmicSignatureNftCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ICosmicSignatureNftCallerRaw struct {
	Contract *ICosmicSignatureNftCaller // Generic read-only contract binding to access the raw methods on
}

// ICosmicSignatureNftTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ICosmicSignatureNftTransactorRaw struct {
	Contract *ICosmicSignatureNftTransactor // Generic write-only contract binding to access the raw methods on
}

// NewICosmicSignatureNft creates a new instance of ICosmicSignatureNft, bound to a specific deployed contract.
func NewICosmicSignatureNft(address common.Address, backend bind.ContractBackend) (*ICosmicSignatureNft, error) {
	contract, err := bindICosmicSignatureNft(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureNft{ICosmicSignatureNftCaller: ICosmicSignatureNftCaller{contract: contract}, ICosmicSignatureNftTransactor: ICosmicSignatureNftTransactor{contract: contract}, ICosmicSignatureNftFilterer: ICosmicSignatureNftFilterer{contract: contract}}, nil
}

// NewICosmicSignatureNftCaller creates a new read-only instance of ICosmicSignatureNft, bound to a specific deployed contract.
func NewICosmicSignatureNftCaller(address common.Address, caller bind.ContractCaller) (*ICosmicSignatureNftCaller, error) {
	contract, err := bindICosmicSignatureNft(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureNftCaller{contract: contract}, nil
}

// NewICosmicSignatureNftTransactor creates a new write-only instance of ICosmicSignatureNft, bound to a specific deployed contract.
func NewICosmicSignatureNftTransactor(address common.Address, transactor bind.ContractTransactor) (*ICosmicSignatureNftTransactor, error) {
	contract, err := bindICosmicSignatureNft(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureNftTransactor{contract: contract}, nil
}

// NewICosmicSignatureNftFilterer creates a new log filterer instance of ICosmicSignatureNft, bound to a specific deployed contract.
func NewICosmicSignatureNftFilterer(address common.Address, filterer bind.ContractFilterer) (*ICosmicSignatureNftFilterer, error) {
	contract, err := bindICosmicSignatureNft(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureNftFilterer{contract: contract}, nil
}

// bindICosmicSignatureNft binds a generic wrapper to an already deployed contract.
func bindICosmicSignatureNft(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ICosmicSignatureNftMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ICosmicSignatureNft *ICosmicSignatureNftRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ICosmicSignatureNft.Contract.ICosmicSignatureNftCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ICosmicSignatureNft *ICosmicSignatureNftRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.ICosmicSignatureNftTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ICosmicSignatureNft *ICosmicSignatureNftRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.ICosmicSignatureNftTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ICosmicSignatureNft *ICosmicSignatureNftCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ICosmicSignatureNft.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.contract.Transact(opts, method, params...)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256 balance)
func (_ICosmicSignatureNft *ICosmicSignatureNftCaller) BalanceOf(opts *bind.CallOpts, owner common.Address) (*big.Int, error) {
	var out []interface{}
	err := _ICosmicSignatureNft.contract.Call(opts, &out, "balanceOf", owner)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256 balance)
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) BalanceOf(owner common.Address) (*big.Int, error) {
	return _ICosmicSignatureNft.Contract.BalanceOf(&_ICosmicSignatureNft.CallOpts, owner)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256 balance)
func (_ICosmicSignatureNft *ICosmicSignatureNftCallerSession) BalanceOf(owner common.Address) (*big.Int, error) {
	return _ICosmicSignatureNft.Contract.BalanceOf(&_ICosmicSignatureNft.CallOpts, owner)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address operator)
func (_ICosmicSignatureNft *ICosmicSignatureNftCaller) GetApproved(opts *bind.CallOpts, tokenId *big.Int) (common.Address, error) {
	var out []interface{}
	err := _ICosmicSignatureNft.contract.Call(opts, &out, "getApproved", tokenId)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address operator)
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) GetApproved(tokenId *big.Int) (common.Address, error) {
	return _ICosmicSignatureNft.Contract.GetApproved(&_ICosmicSignatureNft.CallOpts, tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address operator)
func (_ICosmicSignatureNft *ICosmicSignatureNftCallerSession) GetApproved(tokenId *big.Int) (common.Address, error) {
	return _ICosmicSignatureNft.Contract.GetApproved(&_ICosmicSignatureNft.CallOpts, tokenId)
}

// GetNftInfo is a free data retrieval call binding the contract method 0xd5ec2d83.
//
// Solidity: function getNftInfo(uint256 nftId_) view returns((string,uint256))
func (_ICosmicSignatureNft *ICosmicSignatureNftCaller) GetNftInfo(opts *bind.CallOpts, nftId_ *big.Int) (ICosmicSignatureNftNftInfo, error) {
	var out []interface{}
	err := _ICosmicSignatureNft.contract.Call(opts, &out, "getNftInfo", nftId_)

	if err != nil {
		return *new(ICosmicSignatureNftNftInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(ICosmicSignatureNftNftInfo)).(*ICosmicSignatureNftNftInfo)

	return out0, err

}

// GetNftInfo is a free data retrieval call binding the contract method 0xd5ec2d83.
//
// Solidity: function getNftInfo(uint256 nftId_) view returns((string,uint256))
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) GetNftInfo(nftId_ *big.Int) (ICosmicSignatureNftNftInfo, error) {
	return _ICosmicSignatureNft.Contract.GetNftInfo(&_ICosmicSignatureNft.CallOpts, nftId_)
}

// GetNftInfo is a free data retrieval call binding the contract method 0xd5ec2d83.
//
// Solidity: function getNftInfo(uint256 nftId_) view returns((string,uint256))
func (_ICosmicSignatureNft *ICosmicSignatureNftCallerSession) GetNftInfo(nftId_ *big.Int) (ICosmicSignatureNftNftInfo, error) {
	return _ICosmicSignatureNft.Contract.GetNftInfo(&_ICosmicSignatureNft.CallOpts, nftId_)
}

// GetNftName is a free data retrieval call binding the contract method 0x278ec44f.
//
// Solidity: function getNftName(uint256 nftId_) view returns(string)
func (_ICosmicSignatureNft *ICosmicSignatureNftCaller) GetNftName(opts *bind.CallOpts, nftId_ *big.Int) (string, error) {
	var out []interface{}
	err := _ICosmicSignatureNft.contract.Call(opts, &out, "getNftName", nftId_)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// GetNftName is a free data retrieval call binding the contract method 0x278ec44f.
//
// Solidity: function getNftName(uint256 nftId_) view returns(string)
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) GetNftName(nftId_ *big.Int) (string, error) {
	return _ICosmicSignatureNft.Contract.GetNftName(&_ICosmicSignatureNft.CallOpts, nftId_)
}

// GetNftName is a free data retrieval call binding the contract method 0x278ec44f.
//
// Solidity: function getNftName(uint256 nftId_) view returns(string)
func (_ICosmicSignatureNft *ICosmicSignatureNftCallerSession) GetNftName(nftId_ *big.Int) (string, error) {
	return _ICosmicSignatureNft.Contract.GetNftName(&_ICosmicSignatureNft.CallOpts, nftId_)
}

// GetNftSeed is a free data retrieval call binding the contract method 0xb0c0fe4e.
//
// Solidity: function getNftSeed(uint256 nftId_) view returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftCaller) GetNftSeed(opts *bind.CallOpts, nftId_ *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _ICosmicSignatureNft.contract.Call(opts, &out, "getNftSeed", nftId_)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetNftSeed is a free data retrieval call binding the contract method 0xb0c0fe4e.
//
// Solidity: function getNftSeed(uint256 nftId_) view returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) GetNftSeed(nftId_ *big.Int) (*big.Int, error) {
	return _ICosmicSignatureNft.Contract.GetNftSeed(&_ICosmicSignatureNft.CallOpts, nftId_)
}

// GetNftSeed is a free data retrieval call binding the contract method 0xb0c0fe4e.
//
// Solidity: function getNftSeed(uint256 nftId_) view returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftCallerSession) GetNftSeed(nftId_ *big.Int) (*big.Int, error) {
	return _ICosmicSignatureNft.Contract.GetNftSeed(&_ICosmicSignatureNft.CallOpts, nftId_)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_ICosmicSignatureNft *ICosmicSignatureNftCaller) IsApprovedForAll(opts *bind.CallOpts, owner common.Address, operator common.Address) (bool, error) {
	var out []interface{}
	err := _ICosmicSignatureNft.contract.Call(opts, &out, "isApprovedForAll", owner, operator)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) IsApprovedForAll(owner common.Address, operator common.Address) (bool, error) {
	return _ICosmicSignatureNft.Contract.IsApprovedForAll(&_ICosmicSignatureNft.CallOpts, owner, operator)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_ICosmicSignatureNft *ICosmicSignatureNftCallerSession) IsApprovedForAll(owner common.Address, operator common.Address) (bool, error) {
	return _ICosmicSignatureNft.Contract.IsApprovedForAll(&_ICosmicSignatureNft.CallOpts, owner, operator)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address owner)
func (_ICosmicSignatureNft *ICosmicSignatureNftCaller) OwnerOf(opts *bind.CallOpts, tokenId *big.Int) (common.Address, error) {
	var out []interface{}
	err := _ICosmicSignatureNft.contract.Call(opts, &out, "ownerOf", tokenId)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address owner)
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) OwnerOf(tokenId *big.Int) (common.Address, error) {
	return _ICosmicSignatureNft.Contract.OwnerOf(&_ICosmicSignatureNft.CallOpts, tokenId)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address owner)
func (_ICosmicSignatureNft *ICosmicSignatureNftCallerSession) OwnerOf(tokenId *big.Int) (common.Address, error) {
	return _ICosmicSignatureNft.Contract.OwnerOf(&_ICosmicSignatureNft.CallOpts, tokenId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_ICosmicSignatureNft *ICosmicSignatureNftCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _ICosmicSignatureNft.contract.Call(opts, &out, "supportsInterface", interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _ICosmicSignatureNft.Contract.SupportsInterface(&_ICosmicSignatureNft.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_ICosmicSignatureNft *ICosmicSignatureNftCallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _ICosmicSignatureNft.Contract.SupportsInterface(&_ICosmicSignatureNft.CallOpts, interfaceId)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 index) view returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftCaller) TokenByIndex(opts *bind.CallOpts, index *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _ICosmicSignatureNft.contract.Call(opts, &out, "tokenByIndex", index)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 index) view returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) TokenByIndex(index *big.Int) (*big.Int, error) {
	return _ICosmicSignatureNft.Contract.TokenByIndex(&_ICosmicSignatureNft.CallOpts, index)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 index) view returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftCallerSession) TokenByIndex(index *big.Int) (*big.Int, error) {
	return _ICosmicSignatureNft.Contract.TokenByIndex(&_ICosmicSignatureNft.CallOpts, index)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address owner, uint256 index) view returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftCaller) TokenOfOwnerByIndex(opts *bind.CallOpts, owner common.Address, index *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _ICosmicSignatureNft.contract.Call(opts, &out, "tokenOfOwnerByIndex", owner, index)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address owner, uint256 index) view returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) TokenOfOwnerByIndex(owner common.Address, index *big.Int) (*big.Int, error) {
	return _ICosmicSignatureNft.Contract.TokenOfOwnerByIndex(&_ICosmicSignatureNft.CallOpts, owner, index)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address owner, uint256 index) view returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftCallerSession) TokenOfOwnerByIndex(owner common.Address, index *big.Int) (*big.Int, error) {
	return _ICosmicSignatureNft.Contract.TokenOfOwnerByIndex(&_ICosmicSignatureNft.CallOpts, owner, index)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _ICosmicSignatureNft.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) TotalSupply() (*big.Int, error) {
	return _ICosmicSignatureNft.Contract.TotalSupply(&_ICosmicSignatureNft.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftCallerSession) TotalSupply() (*big.Int, error) {
	return _ICosmicSignatureNft.Contract.TotalSupply(&_ICosmicSignatureNft.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactor) Approve(opts *bind.TransactOpts, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.contract.Transact(opts, "approve", to, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) Approve(to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.Approve(&_ICosmicSignatureNft.TransactOpts, to, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactorSession) Approve(to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.Approve(&_ICosmicSignatureNft.TransactOpts, to, tokenId)
}

// Mint is a paid mutator transaction binding the contract method 0x836a1040.
//
// Solidity: function mint(uint256 roundNum_, address nftOwnerAddress_, uint256 randomNumberSeed_) returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactor) Mint(opts *bind.TransactOpts, roundNum_ *big.Int, nftOwnerAddress_ common.Address, randomNumberSeed_ *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.contract.Transact(opts, "mint", roundNum_, nftOwnerAddress_, randomNumberSeed_)
}

// Mint is a paid mutator transaction binding the contract method 0x836a1040.
//
// Solidity: function mint(uint256 roundNum_, address nftOwnerAddress_, uint256 randomNumberSeed_) returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) Mint(roundNum_ *big.Int, nftOwnerAddress_ common.Address, randomNumberSeed_ *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.Mint(&_ICosmicSignatureNft.TransactOpts, roundNum_, nftOwnerAddress_, randomNumberSeed_)
}

// Mint is a paid mutator transaction binding the contract method 0x836a1040.
//
// Solidity: function mint(uint256 roundNum_, address nftOwnerAddress_, uint256 randomNumberSeed_) returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactorSession) Mint(roundNum_ *big.Int, nftOwnerAddress_ common.Address, randomNumberSeed_ *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.Mint(&_ICosmicSignatureNft.TransactOpts, roundNum_, nftOwnerAddress_, randomNumberSeed_)
}

// MintMany is a paid mutator transaction binding the contract method 0x6578f113.
//
// Solidity: function mintMany(uint256 roundNum_, address[] nftOwnerAddresses_, uint256 randomNumberSeed_) returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactor) MintMany(opts *bind.TransactOpts, roundNum_ *big.Int, nftOwnerAddresses_ []common.Address, randomNumberSeed_ *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.contract.Transact(opts, "mintMany", roundNum_, nftOwnerAddresses_, randomNumberSeed_)
}

// MintMany is a paid mutator transaction binding the contract method 0x6578f113.
//
// Solidity: function mintMany(uint256 roundNum_, address[] nftOwnerAddresses_, uint256 randomNumberSeed_) returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) MintMany(roundNum_ *big.Int, nftOwnerAddresses_ []common.Address, randomNumberSeed_ *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.MintMany(&_ICosmicSignatureNft.TransactOpts, roundNum_, nftOwnerAddresses_, randomNumberSeed_)
}

// MintMany is a paid mutator transaction binding the contract method 0x6578f113.
//
// Solidity: function mintMany(uint256 roundNum_, address[] nftOwnerAddresses_, uint256 randomNumberSeed_) returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactorSession) MintMany(roundNum_ *big.Int, nftOwnerAddresses_ []common.Address, randomNumberSeed_ *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.MintMany(&_ICosmicSignatureNft.TransactOpts, roundNum_, nftOwnerAddresses_, randomNumberSeed_)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactor) SafeTransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.contract.Transact(opts, "safeTransferFrom", from, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) SafeTransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.SafeTransferFrom(&_ICosmicSignatureNft.TransactOpts, from, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactorSession) SafeTransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.SafeTransferFrom(&_ICosmicSignatureNft.TransactOpts, from, to, tokenId)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactor) SafeTransferFrom0(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _ICosmicSignatureNft.contract.Transact(opts, "safeTransferFrom0", from, to, tokenId, data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) SafeTransferFrom0(from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.SafeTransferFrom0(&_ICosmicSignatureNft.TransactOpts, from, to, tokenId, data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactorSession) SafeTransferFrom0(from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.SafeTransferFrom0(&_ICosmicSignatureNft.TransactOpts, from, to, tokenId, data)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactor) SetApprovalForAll(opts *bind.TransactOpts, operator common.Address, approved bool) (*types.Transaction, error) {
	return _ICosmicSignatureNft.contract.Transact(opts, "setApprovalForAll", operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.SetApprovalForAll(&_ICosmicSignatureNft.TransactOpts, operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactorSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.SetApprovalForAll(&_ICosmicSignatureNft.TransactOpts, operator, approved)
}

// SetNftBaseUri is a paid mutator transaction binding the contract method 0xe10a312d.
//
// Solidity: function setNftBaseUri(string newValue_) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactor) SetNftBaseUri(opts *bind.TransactOpts, newValue_ string) (*types.Transaction, error) {
	return _ICosmicSignatureNft.contract.Transact(opts, "setNftBaseUri", newValue_)
}

// SetNftBaseUri is a paid mutator transaction binding the contract method 0xe10a312d.
//
// Solidity: function setNftBaseUri(string newValue_) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) SetNftBaseUri(newValue_ string) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.SetNftBaseUri(&_ICosmicSignatureNft.TransactOpts, newValue_)
}

// SetNftBaseUri is a paid mutator transaction binding the contract method 0xe10a312d.
//
// Solidity: function setNftBaseUri(string newValue_) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactorSession) SetNftBaseUri(newValue_ string) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.SetNftBaseUri(&_ICosmicSignatureNft.TransactOpts, newValue_)
}

// SetNftGenerationScriptUri is a paid mutator transaction binding the contract method 0x11c9f23b.
//
// Solidity: function setNftGenerationScriptUri(string newValue_) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactor) SetNftGenerationScriptUri(opts *bind.TransactOpts, newValue_ string) (*types.Transaction, error) {
	return _ICosmicSignatureNft.contract.Transact(opts, "setNftGenerationScriptUri", newValue_)
}

// SetNftGenerationScriptUri is a paid mutator transaction binding the contract method 0x11c9f23b.
//
// Solidity: function setNftGenerationScriptUri(string newValue_) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) SetNftGenerationScriptUri(newValue_ string) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.SetNftGenerationScriptUri(&_ICosmicSignatureNft.TransactOpts, newValue_)
}

// SetNftGenerationScriptUri is a paid mutator transaction binding the contract method 0x11c9f23b.
//
// Solidity: function setNftGenerationScriptUri(string newValue_) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactorSession) SetNftGenerationScriptUri(newValue_ string) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.SetNftGenerationScriptUri(&_ICosmicSignatureNft.TransactOpts, newValue_)
}

// SetNftName is a paid mutator transaction binding the contract method 0xee056e1d.
//
// Solidity: function setNftName(uint256 nftId_, string nftName_) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactor) SetNftName(opts *bind.TransactOpts, nftId_ *big.Int, nftName_ string) (*types.Transaction, error) {
	return _ICosmicSignatureNft.contract.Transact(opts, "setNftName", nftId_, nftName_)
}

// SetNftName is a paid mutator transaction binding the contract method 0xee056e1d.
//
// Solidity: function setNftName(uint256 nftId_, string nftName_) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) SetNftName(nftId_ *big.Int, nftName_ string) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.SetNftName(&_ICosmicSignatureNft.TransactOpts, nftId_, nftName_)
}

// SetNftName is a paid mutator transaction binding the contract method 0xee056e1d.
//
// Solidity: function setNftName(uint256 nftId_, string nftName_) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactorSession) SetNftName(nftId_ *big.Int, nftName_ string) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.SetNftName(&_ICosmicSignatureNft.TransactOpts, nftId_, nftName_)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.contract.Transact(opts, "transferFrom", from, to, tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) TransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.TransferFrom(&_ICosmicSignatureNft.TransactOpts, from, to, tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactorSession) TransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.TransferFrom(&_ICosmicSignatureNft.TransactOpts, from, to, tokenId)
}

// ICosmicSignatureNftApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftApprovalIterator struct {
	Event *ICosmicSignatureNftApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureNftApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureNftApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureNftApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureNftApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureNftApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureNftApproval represents a Approval event raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftApproval struct {
	Owner    common.Address
	Approved common.Address
	TokenId  *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, approved []common.Address, tokenId []*big.Int) (*ICosmicSignatureNftApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _ICosmicSignatureNft.contract.FilterLogs(opts, "Approval", ownerRule, approvedRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureNftApprovalIterator{contract: _ICosmicSignatureNft.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureNftApproval, owner []common.Address, approved []common.Address, tokenId []*big.Int) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _ICosmicSignatureNft.contract.WatchLogs(opts, "Approval", ownerRule, approvedRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureNftApproval)
				if err := _ICosmicSignatureNft.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) ParseApproval(log types.Log) (*ICosmicSignatureNftApproval, error) {
	event := new(ICosmicSignatureNftApproval)
	if err := _ICosmicSignatureNft.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureNftApprovalForAllIterator is returned from FilterApprovalForAll and is used to iterate over the raw logs and unpacked data for ApprovalForAll events raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftApprovalForAllIterator struct {
	Event *ICosmicSignatureNftApprovalForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureNftApprovalForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureNftApprovalForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureNftApprovalForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureNftApprovalForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureNftApprovalForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureNftApprovalForAll represents a ApprovalForAll event raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftApprovalForAll struct {
	Owner    common.Address
	Operator common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApprovalForAll is a free log retrieval operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) FilterApprovalForAll(opts *bind.FilterOpts, owner []common.Address, operator []common.Address) (*ICosmicSignatureNftApprovalForAllIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _ICosmicSignatureNft.contract.FilterLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureNftApprovalForAllIterator{contract: _ICosmicSignatureNft.contract, event: "ApprovalForAll", logs: logs, sub: sub}, nil
}

// WatchApprovalForAll is a free log subscription operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureNftApprovalForAll, owner []common.Address, operator []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _ICosmicSignatureNft.contract.WatchLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureNftApprovalForAll)
				if err := _ICosmicSignatureNft.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApprovalForAll is a log parse operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) ParseApprovalForAll(log types.Log) (*ICosmicSignatureNftApprovalForAll, error) {
	event := new(ICosmicSignatureNftApprovalForAll)
	if err := _ICosmicSignatureNft.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureNftNftBaseUriChangedIterator is returned from FilterNftBaseUriChanged and is used to iterate over the raw logs and unpacked data for NftBaseUriChanged events raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftNftBaseUriChangedIterator struct {
	Event *ICosmicSignatureNftNftBaseUriChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureNftNftBaseUriChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureNftNftBaseUriChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureNftNftBaseUriChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureNftNftBaseUriChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureNftNftBaseUriChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureNftNftBaseUriChanged represents a NftBaseUriChanged event raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftNftBaseUriChanged struct {
	NewValue string
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterNftBaseUriChanged is a free log retrieval operation binding the contract event 0xbdfd815215fcee5bb949c941ab489c7ead076a7c8acd3527cd1b50f613ac67e6.
//
// Solidity: event NftBaseUriChanged(string newValue)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) FilterNftBaseUriChanged(opts *bind.FilterOpts) (*ICosmicSignatureNftNftBaseUriChangedIterator, error) {

	logs, sub, err := _ICosmicSignatureNft.contract.FilterLogs(opts, "NftBaseUriChanged")
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureNftNftBaseUriChangedIterator{contract: _ICosmicSignatureNft.contract, event: "NftBaseUriChanged", logs: logs, sub: sub}, nil
}

// WatchNftBaseUriChanged is a free log subscription operation binding the contract event 0xbdfd815215fcee5bb949c941ab489c7ead076a7c8acd3527cd1b50f613ac67e6.
//
// Solidity: event NftBaseUriChanged(string newValue)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) WatchNftBaseUriChanged(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureNftNftBaseUriChanged) (event.Subscription, error) {

	logs, sub, err := _ICosmicSignatureNft.contract.WatchLogs(opts, "NftBaseUriChanged")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureNftNftBaseUriChanged)
				if err := _ICosmicSignatureNft.contract.UnpackLog(event, "NftBaseUriChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseNftBaseUriChanged is a log parse operation binding the contract event 0xbdfd815215fcee5bb949c941ab489c7ead076a7c8acd3527cd1b50f613ac67e6.
//
// Solidity: event NftBaseUriChanged(string newValue)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) ParseNftBaseUriChanged(log types.Log) (*ICosmicSignatureNftNftBaseUriChanged, error) {
	event := new(ICosmicSignatureNftNftBaseUriChanged)
	if err := _ICosmicSignatureNft.contract.UnpackLog(event, "NftBaseUriChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureNftNftGenerationScriptUriChangedIterator is returned from FilterNftGenerationScriptUriChanged and is used to iterate over the raw logs and unpacked data for NftGenerationScriptUriChanged events raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftNftGenerationScriptUriChangedIterator struct {
	Event *ICosmicSignatureNftNftGenerationScriptUriChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureNftNftGenerationScriptUriChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureNftNftGenerationScriptUriChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureNftNftGenerationScriptUriChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureNftNftGenerationScriptUriChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureNftNftGenerationScriptUriChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureNftNftGenerationScriptUriChanged represents a NftGenerationScriptUriChanged event raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftNftGenerationScriptUriChanged struct {
	NewValue string
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterNftGenerationScriptUriChanged is a free log retrieval operation binding the contract event 0x27e2bd70f498920ee0fd7d8204ae8845b75dc81330e3acafa32946be3503730c.
//
// Solidity: event NftGenerationScriptUriChanged(string newValue)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) FilterNftGenerationScriptUriChanged(opts *bind.FilterOpts) (*ICosmicSignatureNftNftGenerationScriptUriChangedIterator, error) {

	logs, sub, err := _ICosmicSignatureNft.contract.FilterLogs(opts, "NftGenerationScriptUriChanged")
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureNftNftGenerationScriptUriChangedIterator{contract: _ICosmicSignatureNft.contract, event: "NftGenerationScriptUriChanged", logs: logs, sub: sub}, nil
}

// WatchNftGenerationScriptUriChanged is a free log subscription operation binding the contract event 0x27e2bd70f498920ee0fd7d8204ae8845b75dc81330e3acafa32946be3503730c.
//
// Solidity: event NftGenerationScriptUriChanged(string newValue)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) WatchNftGenerationScriptUriChanged(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureNftNftGenerationScriptUriChanged) (event.Subscription, error) {

	logs, sub, err := _ICosmicSignatureNft.contract.WatchLogs(opts, "NftGenerationScriptUriChanged")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureNftNftGenerationScriptUriChanged)
				if err := _ICosmicSignatureNft.contract.UnpackLog(event, "NftGenerationScriptUriChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseNftGenerationScriptUriChanged is a log parse operation binding the contract event 0x27e2bd70f498920ee0fd7d8204ae8845b75dc81330e3acafa32946be3503730c.
//
// Solidity: event NftGenerationScriptUriChanged(string newValue)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) ParseNftGenerationScriptUriChanged(log types.Log) (*ICosmicSignatureNftNftGenerationScriptUriChanged, error) {
	event := new(ICosmicSignatureNftNftGenerationScriptUriChanged)
	if err := _ICosmicSignatureNft.contract.UnpackLog(event, "NftGenerationScriptUriChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureNftNftMintedIterator is returned from FilterNftMinted and is used to iterate over the raw logs and unpacked data for NftMinted events raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftNftMintedIterator struct {
	Event *ICosmicSignatureNftNftMinted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureNftNftMintedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureNftNftMinted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureNftNftMinted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureNftNftMintedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureNftNftMintedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureNftNftMinted represents a NftMinted event raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftNftMinted struct {
	RoundNum        *big.Int
	NftOwnerAddress common.Address
	NftSeed         *big.Int
	NftId           *big.Int
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterNftMinted is a free log retrieval operation binding the contract event 0xc2115f21464937bfdcd1560f96f0e20b70e88accbdcd1069084c80c8797ef106.
//
// Solidity: event NftMinted(uint256 indexed roundNum, address indexed nftOwnerAddress, uint256 nftSeed, uint256 indexed nftId)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) FilterNftMinted(opts *bind.FilterOpts, roundNum []*big.Int, nftOwnerAddress []common.Address, nftId []*big.Int) (*ICosmicSignatureNftNftMintedIterator, error) {

	var roundNumRule []interface{}
	for _, roundNumItem := range roundNum {
		roundNumRule = append(roundNumRule, roundNumItem)
	}
	var nftOwnerAddressRule []interface{}
	for _, nftOwnerAddressItem := range nftOwnerAddress {
		nftOwnerAddressRule = append(nftOwnerAddressRule, nftOwnerAddressItem)
	}

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}

	logs, sub, err := _ICosmicSignatureNft.contract.FilterLogs(opts, "NftMinted", roundNumRule, nftOwnerAddressRule, nftIdRule)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureNftNftMintedIterator{contract: _ICosmicSignatureNft.contract, event: "NftMinted", logs: logs, sub: sub}, nil
}

// WatchNftMinted is a free log subscription operation binding the contract event 0xc2115f21464937bfdcd1560f96f0e20b70e88accbdcd1069084c80c8797ef106.
//
// Solidity: event NftMinted(uint256 indexed roundNum, address indexed nftOwnerAddress, uint256 nftSeed, uint256 indexed nftId)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) WatchNftMinted(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureNftNftMinted, roundNum []*big.Int, nftOwnerAddress []common.Address, nftId []*big.Int) (event.Subscription, error) {

	var roundNumRule []interface{}
	for _, roundNumItem := range roundNum {
		roundNumRule = append(roundNumRule, roundNumItem)
	}
	var nftOwnerAddressRule []interface{}
	for _, nftOwnerAddressItem := range nftOwnerAddress {
		nftOwnerAddressRule = append(nftOwnerAddressRule, nftOwnerAddressItem)
	}

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}

	logs, sub, err := _ICosmicSignatureNft.contract.WatchLogs(opts, "NftMinted", roundNumRule, nftOwnerAddressRule, nftIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureNftNftMinted)
				if err := _ICosmicSignatureNft.contract.UnpackLog(event, "NftMinted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseNftMinted is a log parse operation binding the contract event 0xc2115f21464937bfdcd1560f96f0e20b70e88accbdcd1069084c80c8797ef106.
//
// Solidity: event NftMinted(uint256 indexed roundNum, address indexed nftOwnerAddress, uint256 nftSeed, uint256 indexed nftId)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) ParseNftMinted(log types.Log) (*ICosmicSignatureNftNftMinted, error) {
	event := new(ICosmicSignatureNftNftMinted)
	if err := _ICosmicSignatureNft.contract.UnpackLog(event, "NftMinted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureNftNftNameChangedIterator is returned from FilterNftNameChanged and is used to iterate over the raw logs and unpacked data for NftNameChanged events raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftNftNameChangedIterator struct {
	Event *ICosmicSignatureNftNftNameChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureNftNftNameChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureNftNftNameChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureNftNftNameChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureNftNftNameChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureNftNftNameChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureNftNftNameChanged represents a NftNameChanged event raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftNftNameChanged struct {
	NftId   *big.Int
	NftName string
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterNftNameChanged is a free log retrieval operation binding the contract event 0xa14cfb0fe69c0b55eaaa4d9400bdba2a72e1860cade89c2a8a055e6cfde8936d.
//
// Solidity: event NftNameChanged(uint256 indexed nftId, string nftName)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) FilterNftNameChanged(opts *bind.FilterOpts, nftId []*big.Int) (*ICosmicSignatureNftNftNameChangedIterator, error) {

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}

	logs, sub, err := _ICosmicSignatureNft.contract.FilterLogs(opts, "NftNameChanged", nftIdRule)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureNftNftNameChangedIterator{contract: _ICosmicSignatureNft.contract, event: "NftNameChanged", logs: logs, sub: sub}, nil
}

// WatchNftNameChanged is a free log subscription operation binding the contract event 0xa14cfb0fe69c0b55eaaa4d9400bdba2a72e1860cade89c2a8a055e6cfde8936d.
//
// Solidity: event NftNameChanged(uint256 indexed nftId, string nftName)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) WatchNftNameChanged(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureNftNftNameChanged, nftId []*big.Int) (event.Subscription, error) {

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}

	logs, sub, err := _ICosmicSignatureNft.contract.WatchLogs(opts, "NftNameChanged", nftIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureNftNftNameChanged)
				if err := _ICosmicSignatureNft.contract.UnpackLog(event, "NftNameChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseNftNameChanged is a log parse operation binding the contract event 0xa14cfb0fe69c0b55eaaa4d9400bdba2a72e1860cade89c2a8a055e6cfde8936d.
//
// Solidity: event NftNameChanged(uint256 indexed nftId, string nftName)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) ParseNftNameChanged(log types.Log) (*ICosmicSignatureNftNftNameChanged, error) {
	event := new(ICosmicSignatureNftNftNameChanged)
	if err := _ICosmicSignatureNft.contract.UnpackLog(event, "NftNameChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureNftTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftTransferIterator struct {
	Event *ICosmicSignatureNftTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureNftTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureNftTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureNftTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureNftTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureNftTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureNftTransfer represents a Transfer event raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftTransfer struct {
	From    common.Address
	To      common.Address
	TokenId *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenId []*big.Int) (*ICosmicSignatureNftTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _ICosmicSignatureNft.contract.FilterLogs(opts, "Transfer", fromRule, toRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureNftTransferIterator{contract: _ICosmicSignatureNft.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureNftTransfer, from []common.Address, to []common.Address, tokenId []*big.Int) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _ICosmicSignatureNft.contract.WatchLogs(opts, "Transfer", fromRule, toRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureNftTransfer)
				if err := _ICosmicSignatureNft.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) ParseTransfer(log types.Log) (*ICosmicSignatureNftTransfer, error) {
	event := new(ICosmicSignatureNftTransfer)
	if err := _ICosmicSignatureNft.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
