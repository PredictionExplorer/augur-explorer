// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package contracts

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// ICosmicSignatureNftNftInfo is an auto generated low-level Go binding around an user-defined struct.
type ICosmicSignatureNftNftInfo struct {
	Name string
	Seed *big.Int
}

// CosmicSignatureNftMetaData contains all meta data concerning the CosmicSignatureNft contract.
var CosmicSignatureNftMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"game_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ERC721EnumerableForbiddenBatchMint\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ERC721IncorrectOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ERC721InsufficientApproval\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"ERC721InvalidApprover\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"ERC721InvalidOperator\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ERC721InvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ERC721InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ERC721InvalidSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ERC721NonexistentToken\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"ERC721OutOfBoundsIndex\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"errStr\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"requesterAddress\",\"type\":\"address\"}],\"name\":\"NoMintPrivileges\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"errStr\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"OwnershipError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"errStr\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"len\",\"type\":\"uint256\"}],\"name\":\"TokenNameLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"errStr\",\"type\":\"string\"}],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newValue\",\"type\":\"string\"}],\"name\":\"NftBaseUriChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newValue\",\"type\":\"string\"}],\"name\":\"NftGenerationScriptUriChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundNum\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftOwnerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftSeed\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"NftMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"nftName\",\"type\":\"string\"}],\"name\":\"NftNameChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"game\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId_\",\"type\":\"uint256\"}],\"name\":\"getNftInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"}],\"internalType\":\"structICosmicSignatureNft.NftInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId_\",\"type\":\"uint256\"}],\"name\":\"getNftName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId_\",\"type\":\"uint256\"}],\"name\":\"getNftSeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundNum_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftOwnerAddress_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftSeed_\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftGenerationScriptUri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newValue_\",\"type\":\"string\"}],\"name\":\"setNftBaseUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newValue_\",\"type\":\"string\"}],\"name\":\"setNftGenerationScriptUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"nftName_\",\"type\":\"string\"}],\"name\":\"setNftName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x60a06040523461003f57610019610014610104565b61046a565b610021610044565b61317e6108328239608051818181610c450152611771015261317e90f35b61004a565b60405190565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b906100769061004e565b810190811060018060401b0382111761008e57604052565b610058565b906100a661009f610044565b928361006c565b565b5f80fd5b60018060a01b031690565b6100c0906100ac565b90565b6100cc816100b7565b036100d357565b5f80fd5b905051906100e4826100c3565b565b906020828203126100ff576100fc915f016100d7565b90565b6100a8565b6101226139b08038038061011781610093565b9283398101906100e6565b90565b60018060401b0381116101415761013d60209161004e565b0190565b610058565b9061015861015383610125565b610093565b918252565b5f7f436f736d69635369676e61747572654e66740000000000000000000000000000910152565b61018e6012610146565b9061019b6020830161015d565b565b6101a5610184565b90565b5f7f4353530000000000000000000000000000000000000000000000000000000000910152565b6101d96003610146565b906101e6602083016101a8565b565b6101f06101cf565b90565b634e487b7160e01b5f52602260045260245ffd5b9060016002830492168015610227575b602083101461022257565b6101f3565b91607f1691610217565b5f5260205f2090565b601f602091010490565b1b90565b9190600861026391029161025d5f1984610244565b92610244565b9181191691161790565b90565b90565b61028761028261028c9261026d565b610270565b61026d565b90565b90565b91906102a86102a36102b093610273565b61028f565b908354610248565b9055565b5f90565b6102ca916102c46102b4565b91610292565b565b5b8181106102d8575050565b806102e55f6001936102b8565b016102cd565b9190601f81116102fb575b505050565b61030761032c93610231565b9060206103138461023a565b83019310610334575b6103259061023a565b01906102cc565b5f80806102f6565b91506103258192905061031c565b610357600a6103518354610207565b836102eb565b60147f697066733a2f2f54424400000000000000000000000000000000000000000000019055565b61038890610342565b565b90565b6103a161039c6103a69261038a565b610270565b6100ac565b90565b6103b29061038d565b90565b60209181520190565b5f7f5468652070726f76696465642061646472657373206973207a65726f2e000000910152565b6103f2601d6020926103b5565b6103fb816103be565b0190565b6104149060208101905f8183039101526103e5565b90565b8061043261042c6104275f6103a9565b6100b7565b916100b7565b146104425761044090610465565b565b61044a610044565b63eac0d38960e01b815280610461600482016103ff565b0390fd5b608052565b61049e9061048f61047961019d565b6104816101e8565b610489610718565b916104a0565b610499600c61037f565b610417565b565b906104ab92916104ad565b565b906104b892916104ba565b565b906104c592916104c7565b565b906104d292916104d4565b565b906104df9291610649565b565b5190565b5f5260205f2090565b9190601f81116104fe575b505050565b61050a61052f936104e5565b9060206105168461023a565b83019310610537575b6105289061023a565b01906102cc565b5f80806104f9565b91506105288192905061051f565b1c90565b90610559905f1990600802610545565b191690565b8161056891610549565b906002021790565b9061057a816104e1565b9060018060401b0382116106385761059c826105968554610207565b856104ee565b602090601f83116001146105d0579180916105bf935f926105c4575b505061055e565b90555b565b90915001515f806105b8565b601f198316916105df856104e5565b925f5b81811061062057509160029391856001969410610606575b505050020190556105c2565b610616910151601f841690610549565b90555f80806105fa565b919360206001819287870151815501950192016105e2565b610058565b9061064791610570565b565b6106609061065961066794610669565b600161063d565b600261063d565b565b61067290610674565b565b61067d9061067f565b565b6106889061068a565b565b61069390610695565b565b61069e906106c2565b565b6106a9906100b7565b9052565b91906106c0905f602085019401906106a0565b565b806106dd6106d76106d25f6103a9565b6100b7565b916100b7565b146106ed576106eb906107d2565b565b6107106106f95f6103a9565b5f918291631e4fbdf760e01b8352600483016106ad565b0390fd5b5f90565b610720610714565b503390565b5f1c90565b60018060a01b031690565b61074161074691610725565b61072a565b90565b6107539054610735565b90565b5f1b90565b9061076c60018060a01b0391610756565b9181191691161790565b61078a61078561078f926100ac565b610270565b6100ac565b90565b61079b90610776565b90565b6107a790610792565b90565b90565b906107c26107bd6107c99261079e565b6107aa565b825461075b565b9055565b5f0190565b6107db5f610749565b6107e5825f6107ad565b906108196108137f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09361079e565b9161079e565b91610822610044565b8061082c816107cd565b0390a356fe60806040526004361015610013575b610ecb565b61001d5f356101dc565b806301ffc9a7146101d757806306fdde03146101d2578063081812fc146101cd57806308ab7be8146101c8578063095ea7b3146101c357806311c9f23b146101be57806318160ddd146101b957806323b872dd146101b4578063278ec44f146101af5780632f745c59146101aa57806342842e0e146101a55780634f6ccce7146101a05780636352211e1461019b57806370a0823114610196578063715018a614610191578063836a10401461018c5780638da5cb5b1461018757806395d89b4114610182578063a22cb4651461017d578063b0c0fe4e14610178578063b88d4fde14610173578063c3fe3e281461016e578063c87b56dd14610169578063d5ec2d8314610164578063e10a312d1461015f578063e985e9c51461015a578063ee056e1d146101555763f2fde38b0361000e57610e98565b610e64565b610de9565b610d89565b610d54565b610c9c565b610c67565b610c0c565b610afc565b610ac8565b610a43565b610a0e565b6109d8565b61096b565b610936565b6108e3565b6108ae565b61087a565b610844565b61080f565b6107db565b61076c565b610717565b61060a565b610580565b6103c9565b610317565b610268565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b63ffffffff60e01b1690565b610209816101f4565b0361021057565b5f80fd5b9050359061022182610200565b565b9060208282031261023c57610239915f01610214565b90565b6101ec565b151590565b61024f90610241565b9052565b9190610266905f60208501940190610246565b565b346102985761029461028361027e366004610223565b610ed3565b61028b6101e2565b91829182610253565b0390f35b6101e8565b5f9103126102a757565b6101ec565b5190565b60209181520190565b90825f9392825e0152565b601f801991011690565b6102ed6102f66020936102fb936102e4816102ac565b938480936102b0565b958691016102b9565b6102c4565b0190565b6103149160208201915f8184039101526102ce565b90565b346103475761032736600461029d565b610343610332610f24565b61033a6101e2565b918291826102ff565b0390f35b6101e8565b90565b6103588161034c565b0361035f57565b5f80fd5b905035906103708261034f565b565b9060208282031261038b57610388915f01610363565b90565b6101ec565b60018060a01b031690565b6103a490610390565b90565b6103b09061039b565b9052565b91906103c7905f602085019401906103a7565b565b346103f9576103f56103e46103df366004610372565b610f3e565b6103ec6101e2565b918291826103b4565b0390f35b6101e8565b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52602260045260245ffd5b9060016002830492168015610445575b602083101461044057565b610411565b91607f1691610435565b60209181520190565b5f5260205f2090565b905f929180549061047b61047483610425565b809461044f565b916001811690815f146104d25750600114610496575b505050565b6104a39192939450610458565b915f925b8184106104ba57505001905f8080610491565b600181602092959395548486015201910192906104a7565b92949550505060ff19168252151560200201905f8080610491565b906104f791610461565b90565b634e487b7160e01b5f52604160045260245ffd5b90610518906102c4565b810190811067ffffffffffffffff82111761053257604052565b6104fa565b90610557610550926105476101e2565b938480926104ed565b038361050e565b565b905f1061056c5761056990610537565b90565b6103fe565b61057d600c5f90610559565b90565b346105b05761059036600461029d565b6105ac61059b610571565b6105a36101e2565b918291826102ff565b0390f35b6101e8565b6105be8161039b565b036105c557565b5f80fd5b905035906105d6826105b5565b565b919060408382031261060057806105f46105fd925f86016105c9565b93602001610363565b90565b6101ec565b5f0190565b346106395761062361061d3660046105d8565b90610f5d565b61062b6101e2565b8061063581610605565b0390f35b6101e8565b5f80fd5b5f80fd5b906106596106526101e2565b928361050e565b565b67ffffffffffffffff8111610679576106756020916102c4565b0190565b6104fa565b90825f939282370152565b9092919261069e6106998261065b565b610646565b938185526020850190828401116106ba576106b89261067e565b565b610642565b9080601f830112156106dd578160206106da93359101610689565b90565b61063e565b90602082820312610712575f82013567ffffffffffffffff811161070d5761070a92016106bf565b90565b6101f0565b6101ec565b346107455761072f61072a3660046106e2565b6111d7565b6107376101e2565b8061074181610605565b0390f35b6101e8565b6107539061034c565b9052565b919061076a905f6020850194019061074a565b565b3461079c5761077c36600461029d565b6107986107876111e6565b61078f6101e2565b91829182610757565b0390f35b6101e8565b90916060828403126107d6576107d36107bc845f85016105c9565b936107ca81602086016105c9565b93604001610363565b90565b6101ec565b3461080a576107f46107ee3660046107a1565b91611259565b6107fc6101e2565b8061080681610605565b0390f35b6101e8565b3461083f5761083b61082a610825366004610372565b611341565b6108326101e2565b918291826102ff565b0390f35b6101e8565b346108755761087161086061085a3660046105d8565b9061140f565b6108686101e2565b91829182610757565b0390f35b6101e8565b346108a95761089361088d3660046107a1565b916114a4565b61089b6101e2565b806108a581610605565b0390f35b6101e8565b346108de576108da6108c96108c4366004610372565b611511565b6108d16101e2565b91829182610757565b0390f35b6101e8565b346109135761090f6108fe6108f9366004610372565b611578565b6109066101e2565b918291826103b4565b0390f35b6101e8565b906020828203126109315761092e915f016105c9565b90565b6101ec565b346109665761096261095161094c366004610918565b6115a3565b6109596101e2565b91829182610757565b0390f35b6101e8565b346109995761097b36600461029d565b61098361162e565b61098b6101e2565b8061099581610605565b0390f35b6101e8565b90916060828403126109d3576109d06109b9845f8501610363565b936109c781602086016105c9565b93604001610363565b90565b6101ec565b34610a0957610a056109f46109ee36600461099e565b91611753565b6109fc6101e2565b91829182610757565b0390f35b6101e8565b34610a3e57610a1e36600461029d565b610a3a610a2961185d565b610a316101e2565b918291826103b4565b0390f35b6101e8565b34610a7357610a5336600461029d565b610a6f610a5e611872565b610a666101e2565b918291826102ff565b0390f35b6101e8565b610a8181610241565b03610a8857565b5f80fd5b90503590610a9982610a78565b565b9190604083820312610ac35780610ab7610ac0925f86016105c9565b93602001610a8c565b90565b6101ec565b34610af757610ae1610adb366004610a9b565b90611888565b610ae96101e2565b80610af381610605565b0390f35b6101e8565b34610b2c57610b28610b17610b12366004610372565b61189e565b610b1f6101e2565b91829182610757565b0390f35b6101e8565b67ffffffffffffffff8111610b4f57610b4b6020916102c4565b0190565b6104fa565b90929192610b69610b6482610b31565b610646565b93818552602085019082840111610b8557610b839261067e565b565b610642565b9080601f83011215610ba857816020610ba593359101610b54565b90565b61063e565b90608082820312610c0757610bc4815f84016105c9565b92610bd282602085016105c9565b92610be08360408301610363565b92606082013567ffffffffffffffff8111610c0257610bff9201610b8a565b90565b6101f0565b6101ec565b34610c3e57610c28610c1f366004610bad565b929190916118c1565b610c306101e2565b80610c3a81610605565b0390f35b6101e8565b7f000000000000000000000000000000000000000000000000000000000000000090565b34610c9757610c7736600461029d565b610c93610c82610c43565b610c8a6101e2565b918291826103b4565b0390f35b6101e8565b34610ccc57610cc8610cb7610cb2366004610372565b61197f565b610cbf6101e2565b918291826102ff565b0390f35b6101e8565b610cf0610cf9602093610cfe93610ce7816102ac565b9384809361044f565b958691016102b9565b6102c4565b0190565b610d0b9061034c565b9052565b90610d3990602080610d2e604084015f8701518582035f870152610cd1565b940151910190610d02565b90565b610d519160208201915f818403910152610d0f565b90565b34610d8457610d80610d6f610d6a366004610372565b611a88565b610d776101e2565b91829182610d3c565b0390f35b6101e8565b34610db757610da1610d9c3660046106e2565b611b01565b610da96101e2565b80610db381610605565b0390f35b6101e8565b9190604083820312610de45780610dd8610de1925f86016105c9565b936020016105c9565b90565b6101ec565b34610e1a57610e16610e05610dff366004610dbc565b90611b5f565b610e0d6101e2565b91829182610253565b0390f35b6101e8565b919091604081840312610e5f57610e38835f8301610363565b92602082013567ffffffffffffffff8111610e5a57610e5792016106bf565b90565b6101f0565b6101ec565b34610e9357610e7d610e77366004610e1f565b90611d01565b610e856101e2565b80610e8f81610605565b0390f35b6101e8565b34610ec657610eb0610eab366004610918565b611e2d565b610eb86101e2565b80610ec281610605565b0390f35b6101e8565b5f80fd5b5f90565b610edb610ecf565b5080610ef6610ef063780e9d6360e01b6101f4565b916101f4565b14908115610f03575b5090565b610f0d9150611e38565b5f610eff565b606090565b610f2190610537565b90565b610f2c610f13565b50610f376001610f18565b90565b5f90565b610f5a90610f4a610f3a565b50610f5481611ea0565b50611f0c565b90565b90610f719190610f6b611f2b565b91611f38565b565b610f8490610f7f611f48565b611191565b565b601f602091010490565b1b90565b91906008610faf910291610fa95f1984610f90565b92610f90565b9181191691161790565b90565b610fd0610fcb610fd59261034c565b610fb9565b61034c565b90565b90565b9190610ff1610fec610ff993610fbc565b610fd8565b908354610f94565b9055565b5f90565b6110139161100d610ffd565b91610fdb565b565b5b818110611021575050565b8061102e5f600193611001565b01611016565b9190601f8111611044575b505050565b61105061107593610458565b90602061105c84610f86565b8301931061107d575b61106e90610f86565b0190611015565b5f808061103f565b915061106e81929050611065565b1c90565b9061109f905f199060080261108b565b191690565b816110ae9161108f565b906002021790565b906110c0816102ac565b9067ffffffffffffffff8211611180576110e4826110de8554610425565b85611034565b602090601f831160011461111857918091611107935f9261110c575b50506110a4565b90555b565b90915001515f80611100565b601f1983169161112785610458565b925f5b8181106111685750916002939185600196941061114e575b5050500201905561110a565b61115e910151601f84169061108f565b90555f8080611142565b9193602060018192878701518155019501920161112a565b6104fa565b9061118f916110b6565b565b61119c81600c611185565b6111d27f27e2bd70f498920ee0fd7d8204ae8845b75dc81330e3acafa32946be3503730c916111c96101e2565b918291826102ff565b0390a1565b6111e090610f73565b565b5490565b6111ee610ffd565b506111f960096111e2565b90565b90565b61121361120e611218926111fc565b610fb9565b610390565b90565b611224906111ff565b90565b604090611250611257949695939661124660608401985f8501906103a7565b602083019061074a565b01906103a7565b565b91908061127661127061126b5f61121b565b61039b565b9161039b565b146112cd5761128e9082611288611f2b565b91611f96565b91826112a261129c8361039b565b9161039b565b036112ac57505050565b6112c99091925f9384936364283d7b60e01b855260048501611227565b0390fd5b6112f06112d95f61121b565b5f918291633250574960e11b8352600483016103b4565b0390fd5b634e487b7160e01b5f52603260045260245ffd5b506801000000000000000090565b90565b61132281611308565b82101561133c57611334600291611316565b910201905f90565b6112f4565b5f61135961136092611351610f13565b50600d611319565b5001610f18565b90565b91602061138492949361137d60408201965f8301906103a7565b019061074a565b565b61139a61139561139f92610390565b610fb9565b610390565b90565b6113ab90611386565b90565b6113b7906113a2565b90565b906113c4906113ae565b5f5260205260405f2090565b906113da90610fbc565b5f5260205260405f2090565b5f1c90565b90565b6113fa6113ff916113e6565b6113eb565b90565b61140c90546113ee565b90565b611417610ffd565b508161143361142d611428846115a3565b61034c565b9161034c565b1015611458576114559161144b6114509260076113ba565b6113d0565b611402565b90565b6114725f92839263295f44f760e21b845260048401611363565b0390fd5b906114886114838361065b565b610646565b918252565b6114965f611476565b90565b6114a161148d565b90565b916114b892916114b2611499565b926118c1565b565b5f5260205f2090565b6114cc816111e2565b8210156114e6576114de6001916114ba565b910201905f90565b6112f4565b6114fb906008611500930261108b565b6113eb565b90565b9061150e91546114eb565b90565b611519610ffd565b508061153461152e6115296111e6565b61034c565b9161034c565b10156115515761154861154e9160096114c3565b90611503565b90565b61155a5f61121b565b6115745f92839263295f44f760e21b845260048401611363565b0390fd5b61158a90611584610f3a565b50611ea0565b90565b90611597906113ae565b5f5260205260405f2090565b6115ab610ffd565b50806115c76115c16115bc5f61121b565b61039b565b9161039b565b146115e2576115da6115df91600461158d565b611402565b90565b6116056115ee5f61121b565b5f9182916322718ad960e21b8352600483016103b4565b0390fd5b611611611f48565b61161961161b565b565b61162c6116275f61121b565b6120a8565b565b611636611609565b565b60407f542e000000000000000000000000000000000000000000000000000000000000917f4f6e6c792074686520436f736d69635369676e617475726547616d6520636f6e5f8201527f7472616374206973207065726d697474656420746f206d696e7420616e204e4660208201520152565b6116b860426060926102b0565b6116c181611638565b0190565b91906116e89060206116e0604086018681035f8801526116ab565b9401906103a7565b565b156116f25750565b611714906116fe6101e2565b91829163173fda8d60e21b8352600483016116c5565b0390fd5b5f1b90565b906117295f1991611718565b9181191691161790565b9061174861174361174f92610fbc565b610fd8565b825461171d565b9055565b919061175d610ffd565b506117aa611769611f2b565b61179b6117957f000000000000000000000000000000000000000000000000000000000000000061039b565b9161039b565b146117a4611f2b565b906116ea565b6117b26111e6565b926117be828590612107565b6117d78360016117d0600d8890611319565b5001611733565b90839161182b61181961181361180d7fc2115f21464937bfdcd1560f96f0e20b70e88accbdcd1069084c80c8797ef10694610fbc565b946113ae565b94610fbc565b946118226101e2565b91829182610757565b0390a490565b60018060a01b031690565b61184861184d916113e6565b611831565b90565b61185a905461183c565b90565b611865610f3a565b5061186f5f611850565b90565b61187a610f13565b506118856002610f18565b90565b61189c91611894611f2b565b9190916121f0565b565b60016118b76118be926118af610ffd565b50600d611319565b5001611402565b90565b916118dd9391926118d481858491611259565b929091926123ba565b565b90565b5190565b6118fa6118f56118ff926111fc565b610fb9565b61034c565b90565b61190a61148d565b90565b905090565b61193761192e92602092611925816102ac565b9485809361190d565b938491016102b9565b0190565b6119499061194f9392611912565b90611912565b90565b611971929161197d916119636101e2565b94859260208401928361193b565b9081038252038361050e565b565b611987610f13565b5061199181611ea0565b5061199a612515565b906119ac6119a7836118df565b6118e2565b6119be6119b85f6118e6565b9161034c565b115f146119dc576119d26119d892916125e8565b90611952565b5b90565b50506119e6611902565b6119d9565b6119f56040610646565b90565b606090565b5f90565b611a096119eb565b9060208083611a166119f8565b815201611a216119fd565b81525050565b611a2f611a01565b90565b52565b90611a3f9061034c565b9052565b90611a7a611a716001611a546119eb565b94611a6b611a635f8301610537565b5f8801611a32565b01611402565b60208401611a35565b565b611a8590611a43565b90565b611a9f611aa591611a97611a27565b50600d611319565b50611a7c565b90565b611ab990611ab4611f48565b611abb565b565b611ac681600b611185565b611afc7fbdfd815215fcee5bb949c941ab489c7ead076a7c8acd3527cd1b50f613ac67e691611af36101e2565b918291826102ff565b0390a1565b611b0a90611aa8565b565b90611b16906113ae565b5f5260205260405f2090565b90611b2c906113ae565b5f5260205260405f2090565b60ff1690565b611b4a611b4f916113e6565b611b38565b90565b611b5c9054611b3e565b90565b611b8491611b7a611b7f92611b72610ecf565b506006611b0c565b611b22565b611b52565b90565b60207f7a65642e00000000000000000000000000000000000000000000000000000000917f7365744e66744e616d652063616c6c6572206973206e6f7420617574686f72695f8201520152565b611be160246040926102b0565b611bea81611b87565b0190565b9190611c11906020611c09604086018681035f880152611bd4565b94019061074a565b565b15611c1b5750565b611c3d90611c276101e2565b918291632b03cbb360e21b835260048301611bee565b0390fd5b90565b611c58611c53611c5d92611c41565b610fb9565b61034c565b90565b611c6a6020611c44565b90565b5f7f4e4654206e616d6520697320746f6f206c6f6e672e0000000000000000000000910152565b611ca160156020926102b0565b611caa81611c6d565b0190565b9190611cd1906020611cc9604086018681035f880152611c94565b94019061074a565b565b15611cdb5750565b611cfd90611ce76101e2565b918291635e8b1f5160e11b835260048301611cae565b0390fd5b611d26611d1f611d1083612691565b611d18611f2b565b84916126b0565b8290611c13565b611d6c611d3a611d35846118df565b6118e2565b611d53611d4d611d48611c60565b61034c565b9161034c565b1115611d66611d61856118df565b6118e2565b90611cd3565b611d84825f611d7d600d8590611319565b5001611185565b611dc3611db17fa14cfb0fe69c0b55eaaa4d9400bdba2a72e1860cade89c2a8a055e6cfde8936d92610fbc565b92611dba6101e2565b918291826102ff565b0390a2565b611dd990611dd4611f48565b611ddb565b565b80611df6611df0611deb5f61121b565b61039b565b9161039b565b14611e0657611e04906120a8565b565b611e29611e125f61121b565b5f918291631e4fbdf760e01b8352600483016103b4565b0390fd5b611e3690611dc8565b565b611e40610ecf565b5080611e5b611e556380ac58cd60e01b6101f4565b916101f4565b148015611e7f575b908115611e6f575b5090565b611e799150612750565b5f611e6b565b5080611e9a611e94635b5e139f60e01b6101f4565b916101f4565b14611e63565b611ea8610f3a565b50611eb281612691565b9081611ece611ec8611ec35f61121b565b61039b565b9161039b565b14611ed7575090565b611ef2905f918291637e27328960e01b835260048301610757565b0390fd5b90611f0090610fbc565b5f5260205260405f2090565b611f23611f2891611f1b610f3a565b506005611ef6565b611850565b90565b611f33610f3a565b503390565b91611f469291600192612776565b565b611f5061185d565b611f69611f63611f5e611f2b565b61039b565b9161039b565b03611f7057565b611f92611f7b611f2b565b5f91829163118cdaa760e01b8352600483016103b4565b0390fd5b9091611faf90611fa4610f3a565b5082908490916128ce565b9182611fcb611fc5611fc05f61121b565b61039b565b9161039b565b145f1461203c57611fdb81612b7e565b5b81611ff7611ff1611fec5f61121b565b61039b565b9161039b565b145f1461200c576120089150612c7f565b5b90565b8261201f6120198461039b565b9161039b565b0361202c575b5050612009565b61203591612bea565b5f80612025565b8261204f6120498461039b565b9161039b565b0361205a575b611fdc565b612065838290612a4f565b612055565b9061207b60018060a01b0391611718565b9181191691161790565b90565b9061209d6120986120a4926113ae565b612085565b825461206a565b9055565b6120b15f611850565b6120bb825f612088565b906120ef6120e97f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0936113ae565b916113ae565b916120f86101e2565b8061210281610605565b0390a3565b908161212361211d6121185f61121b565b61039b565b9161039b565b146121845761213c91906121365f61121b565b91611f96565b61215661215061214b5f61121b565b61039b565b9161039b565b0361215d57565b6121806121695f61121b565b5f9182916339e3563760e11b8352600483016103b4565b0390fd5b6121a76121905f61121b565b5f918291633250574960e11b8352600483016103b4565b0390fd5b906121b760ff91611718565b9181191691161790565b6121ca90610241565b90565b90565b906121e56121e06121ec926121c1565b6121cd565b82546121ab565b9055565b9190918261220e6122086122035f61121b565b61039b565b9161039b565b14612282576122328261222d61222660068590611b0c565b8690611b22565b6121d0565b91909161227d61226b6122657f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31936113ae565b936113ae565b936122746101e2565b91829182610253565b0390a3565b61229d835f918291630b61174360e31b8352600483016103b4565b0390fd5b6122aa90611386565b90565b6122b6906122a1565b90565b6122c2906113a2565b90565b60e01b90565b905051906122d882610200565b565b906020828203126122f3576122f0915f016122cb565b90565b6101ec565b60209181520190565b61232061232960209361232e93612317816118e2565b938480936122f8565b958691016102b9565b6102c4565b0190565b90926123659061235b612372969461235160808601975f8701906103a7565b60208501906103a7565b604083019061074a565b6060818403910152612301565b90565b9061238761238283610b31565b610646565b918252565b606090565b3d5f146123ac576123a13d612375565b903d5f602084013e5b565b6123b461238c565b906123aa565b929092833b6123d16123cb5f6118e6565b9161034c565b116123dd575b50505050565b60209161241d5f6123f56123f0886122ad565b6122b9565b9261242863150b7a0291612407611f2b565b96986124116101e2565b998a98899788966122c5565b865260048601612332565b03925af180915f926124e5575b50155f146124a25750600161244f57505b5f8080806123d7565b612457612391565b90612461826118e2565b61247361246d5f6118e6565b9161034c565b145f1461249957612495905f918291633250574960e11b8352600483016103b4565b0390fd5b50805190602001fd5b6124bb6124b5630a85bd0160e11b6101f4565b916101f4565b036124c65750612446565b6124e1905f918291633250574960e11b8352600483016103b4565b0390fd5b61250791925060203d811161250e575b6124ff818361050e565b8101906122da565b905f612435565b503d6124f5565b61251d610f13565b50612528600b610f18565b90565b90565b61254261253d6125479261252b565b610fb9565b61034c565b90565b90612555910161034c565b90565b369037565b9061258261256a83611476565b92602080612578869361065b565b9201910390612558565b565b6001612590910361034c565b90565b90565b6125aa6125a56125af92612593565b610fb9565b61034c565b90565b634e487b7160e01b5f52601260045260245ffd5b6125d26125d89161034c565b9161034c565b9081156125e3570490565b6125b2565b6125f0610f13565b5061260d6125fd82612e6b565b612607600161252e565b9061254a565b906126178261255d565b91612620610ffd565b5060200182015b60011561268a5761263a61266691612584565b916f181899199a1a9b1b9c1cb0b131b232b360811b600a82061a8353612660600a612596565b906125c6565b806126796126735f6118e6565b9161034c565b146126845790612627565b50505b90565b5050612687565b6126a86126ad916126a0610f3a565b506003611ef6565b611850565b90565b91906126ba610ecf565b50806126d66126d06126cb5f61121b565b61039b565b9161039b565b141592836126e5575b50505090565b80919293506126fc6126f68461039b565b9161039b565b1490811561273e575b50918215612718575b50505f80806126df565b61273691925061272a61273091611f0c565b9261039b565b9161039b565b145f8061270e565b61274a91508290611b5f565b5f612705565b612758610ecf565b5061277261276c6301ffc9a760e01b6101f4565b916101f4565b1490565b91909280801561289d575b61279f575b50509061279861279d92916005611ef6565b612088565b565b6127a884611ea0565b91806127c46127be6127b95f61121b565b61039b565b9161039b565b141580612882575b80612868575b6128495750916127989161279d94936127ee575b509192612786565b81849061282d6128276128217f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925956113ae565b926113ae565b92610fbc565b926128366101e2565b8061284081610605565b0390a45f6127e6565b612864905f91829163a9fbf51f60e01b8352600483016103b4565b0390fd5b5061287d612877848390611b5f565b15610241565b6127d2565b50826128966128908361039b565b9161039b565b14156127cc565b50816128b96128b36128ae5f61121b565b61039b565b9161039b565b1415612781565b906128cb910361034c565b90565b906128d7610f3a565b506128e181612691565b92806128fd6128f76128f25f61121b565b61039b565b9161039b565b03612a3c575b508261291f6129196129145f61121b565b61039b565b9161039b565b036129e8575b8161294061293a6129355f61121b565b61039b565b9161039b565b036129b2575b61295b8261295660038490611ef6565b612088565b829161299961299361298d7fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef956113ae565b926113ae565b92610fbc565b926129a26101e2565b806129ac81610605565b0390a490565b6129e36129bf600161252e565b6129dd6129ce6004869061158d565b916129d883611402565b61254a565b90611733565b612946565b612a066129f45f61121b565b826129fe5f61121b565b905f92612776565b612a37612a13600161252e565b612a31612a226004879061158d565b91612a2c83611402565b6128c0565b90611733565b612925565b612a4990849083916130cc565b5f612903565b612ab2612ab792612aad5f93612aa685612aa1612a6b846115a3565b95612a80612a7b600883906113d0565b611402565b80612a93612a8d8a61034c565b9161034c565b03612ab9575b5060086113d0565b611001565b60076113ba565b6113d0565b611001565b565b612b0b90612b06612ade612ad9612ad260078b906113ba565b8c906113d0565b611402565b91612afe83612af9612af260078d906113ba565b84906113d0565b611733565b9160086113d0565b611733565b5f612a99565b90565b5f5260205f2090565b5490565b612b2a81612b1d565b821015612b4457612b3c600191612b14565b910201905f90565b6112f4565b9081549168010000000000000000831015612b795782612b71916001612b7795018155612b21565b90610fdb565b565b6104fa565b612baf90612ba0612b8f60096111e2565b612b9b600a84906113d0565b611733565b612baa6009612b11565b612b49565b565b634e487b7160e01b5f52601160045260245ffd5b612bd4612bda9193929361034c565b9261034c565b8203918211612be557565b612bb1565b90612c35612c3a92612c2d612c11612c01836115a3565b612c0b600161252e565b90612bc5565b91612c28612c21869260076113ba565b84906113d0565b611733565b9160086113d0565b611733565b565b634e487b7160e01b5f52603160045260245ffd5b612c5981612b1d565b8015612c7a576001900390612c77612c718383612b21565b90611001565b55565b612c3c565b5f612cfd612d0292612cf6612ca7612c9760096111e2565b612ca1600161252e565b90612bc5565b612cf1612cd2612ccc612cc4612cbf600a88906113d0565b611402565b9360096114c3565b90611503565b91612ce983612ce3600984906114c3565b90610fdb565b91600a6113d0565b611733565b600a6113d0565b611001565b612d14612d0f6009612b11565b612c50565b565b90565b612d2d612d28612d3292612d16565b610fb9565b61034c565b90565b90565b612d4c612d47612d5192612d35565b610fb9565b61034c565b90565b90565b612d6b612d66612d7092612d54565b610fb9565b61034c565b90565b90565b612d8a612d85612d8f92612d73565b610fb9565b61034c565b90565b90565b612da9612da4612dae92612d92565b610fb9565b61034c565b90565b90565b612dc8612dc3612dcd92612db1565b610fb9565b61034c565b90565b90565b612de7612de2612dec92612dd0565b610fb9565b61034c565b90565b90565b612e06612e01612e0b92612def565b610fb9565b61034c565b90565b90565b612e25612e20612e2a92612e0e565b610fb9565b61034c565b90565b90565b612e44612e3f612e4992612e2d565b610fb9565b61034c565b90565b90565b612e63612e5e612e6892612e4c565b610fb9565b61034c565b90565b612e73610ffd565b50612e7d5f6118e6565b9080612eac612ea67a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000612d19565b9161034c565b1015613084575b80612ed4612ece6d04ee2d6d415b85acef8100000000612d57565b9161034c565b1015613049575b80612ef5612eef662386f26fc10000612d76565b9161034c565b1015613015575b80612f13612f0d6305f5e100612db4565b9161034c565b1015612fe4575b80612f2f612f29612710612df2565b9161034c565b1015612fb5575b80612f4a612f446064612e30565b9161034c565b1015612f87575b612f64612f5e600a612596565b9161034c565b1015612f6e575b90565b612f8290612f7c600161252e565b9061254a565b612f6b565b612f9e612faf91612f986064612e30565b906125c6565b91612fa96002612e4f565b9061254a565b90612f51565b612fcd612fde91612fc7612710612df2565b906125c6565b91612fd86004612e11565b9061254a565b90612f36565b612ffe61300f91612ff86305f5e100612db4565b906125c6565b916130096008612dd3565b9061254a565b90612f1a565b6130326130439161302c662386f26fc10000612d76565b906125c6565b9161303d6010612d95565b9061254a565b90612efc565b61306d61307e916130676d04ee2d6d415b85acef8100000000612d57565b906125c6565b916130786020611c44565b9061254a565b90612edb565b6130b56130c6916130af7a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000612d19565b906125c6565b916130c06040612d38565b9061254a565b90612eb3565b6130e16130db828486916126b0565b15610241565b6130ea57505050565b6131046130fe6130f95f61121b565b61039b565b9161039b565b145f1461312a57613126825f918291637e27328960e01b835260048301610757565b0390fd5b6131445f92839263177e802f60e01b845260048401611363565b0390fdfea26469706673582212208f704b4b0bdceb98f96fac9dd49aeb17f5edb905ca398dcab200ec919abc090664736f6c634300081c0033",
}

// CosmicSignatureNftABI is the input ABI used to generate the binding from.
// Deprecated: Use CosmicSignatureNftMetaData.ABI instead.
var CosmicSignatureNftABI = CosmicSignatureNftMetaData.ABI

// CosmicSignatureNftBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use CosmicSignatureNftMetaData.Bin instead.
var CosmicSignatureNftBin = CosmicSignatureNftMetaData.Bin

// DeployCosmicSignatureNft deploys a new Ethereum contract, binding an instance of CosmicSignatureNft to it.
func DeployCosmicSignatureNft(auth *bind.TransactOpts, backend bind.ContractBackend, game_ common.Address) (common.Address, *types.Transaction, *CosmicSignatureNft, error) {
	parsed, err := CosmicSignatureNftMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(CosmicSignatureNftBin), backend, game_)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &CosmicSignatureNft{CosmicSignatureNftCaller: CosmicSignatureNftCaller{contract: contract}, CosmicSignatureNftTransactor: CosmicSignatureNftTransactor{contract: contract}, CosmicSignatureNftFilterer: CosmicSignatureNftFilterer{contract: contract}}, nil
}

// CosmicSignatureNft is an auto generated Go binding around an Ethereum contract.
type CosmicSignatureNft struct {
	CosmicSignatureNftCaller     // Read-only binding to the contract
	CosmicSignatureNftTransactor // Write-only binding to the contract
	CosmicSignatureNftFilterer   // Log filterer for contract events
}

// CosmicSignatureNftCaller is an auto generated read-only Go binding around an Ethereum contract.
type CosmicSignatureNftCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CosmicSignatureNftTransactor is an auto generated write-only Go binding around an Ethereum contract.
type CosmicSignatureNftTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CosmicSignatureNftFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type CosmicSignatureNftFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CosmicSignatureNftSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type CosmicSignatureNftSession struct {
	Contract     *CosmicSignatureNft // Generic contract binding to set the session for
	CallOpts     bind.CallOpts       // Call options to use throughout this session
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// CosmicSignatureNftCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type CosmicSignatureNftCallerSession struct {
	Contract *CosmicSignatureNftCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts             // Call options to use throughout this session
}

// CosmicSignatureNftTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type CosmicSignatureNftTransactorSession struct {
	Contract     *CosmicSignatureNftTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts             // Transaction auth options to use throughout this session
}

// CosmicSignatureNftRaw is an auto generated low-level Go binding around an Ethereum contract.
type CosmicSignatureNftRaw struct {
	Contract *CosmicSignatureNft // Generic contract binding to access the raw methods on
}

// CosmicSignatureNftCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type CosmicSignatureNftCallerRaw struct {
	Contract *CosmicSignatureNftCaller // Generic read-only contract binding to access the raw methods on
}

// CosmicSignatureNftTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type CosmicSignatureNftTransactorRaw struct {
	Contract *CosmicSignatureNftTransactor // Generic write-only contract binding to access the raw methods on
}

// NewCosmicSignatureNft creates a new instance of CosmicSignatureNft, bound to a specific deployed contract.
func NewCosmicSignatureNft(address common.Address, backend bind.ContractBackend) (*CosmicSignatureNft, error) {
	contract, err := bindCosmicSignatureNft(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNft{CosmicSignatureNftCaller: CosmicSignatureNftCaller{contract: contract}, CosmicSignatureNftTransactor: CosmicSignatureNftTransactor{contract: contract}, CosmicSignatureNftFilterer: CosmicSignatureNftFilterer{contract: contract}}, nil
}

// NewCosmicSignatureNftCaller creates a new read-only instance of CosmicSignatureNft, bound to a specific deployed contract.
func NewCosmicSignatureNftCaller(address common.Address, caller bind.ContractCaller) (*CosmicSignatureNftCaller, error) {
	contract, err := bindCosmicSignatureNft(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftCaller{contract: contract}, nil
}

// NewCosmicSignatureNftTransactor creates a new write-only instance of CosmicSignatureNft, bound to a specific deployed contract.
func NewCosmicSignatureNftTransactor(address common.Address, transactor bind.ContractTransactor) (*CosmicSignatureNftTransactor, error) {
	contract, err := bindCosmicSignatureNft(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftTransactor{contract: contract}, nil
}

// NewCosmicSignatureNftFilterer creates a new log filterer instance of CosmicSignatureNft, bound to a specific deployed contract.
func NewCosmicSignatureNftFilterer(address common.Address, filterer bind.ContractFilterer) (*CosmicSignatureNftFilterer, error) {
	contract, err := bindCosmicSignatureNft(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftFilterer{contract: contract}, nil
}

// bindCosmicSignatureNft binds a generic wrapper to an already deployed contract.
func bindCosmicSignatureNft(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := CosmicSignatureNftMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_CosmicSignatureNft *CosmicSignatureNftRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _CosmicSignatureNft.Contract.CosmicSignatureNftCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_CosmicSignatureNft *CosmicSignatureNftRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.CosmicSignatureNftTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_CosmicSignatureNft *CosmicSignatureNftRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.CosmicSignatureNftTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_CosmicSignatureNft *CosmicSignatureNftCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _CosmicSignatureNft.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_CosmicSignatureNft *CosmicSignatureNftTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_CosmicSignatureNft *CosmicSignatureNftTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.contract.Transact(opts, method, params...)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) BalanceOf(opts *bind.CallOpts, owner common.Address) (*big.Int, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "balanceOf", owner)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftSession) BalanceOf(owner common.Address) (*big.Int, error) {
	return _CosmicSignatureNft.Contract.BalanceOf(&_CosmicSignatureNft.CallOpts, owner)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) BalanceOf(owner common.Address) (*big.Int, error) {
	return _CosmicSignatureNft.Contract.BalanceOf(&_CosmicSignatureNft.CallOpts, owner)
}

// Game is a free data retrieval call binding the contract method 0xc3fe3e28.
//
// Solidity: function game() view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) Game(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "game")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Game is a free data retrieval call binding the contract method 0xc3fe3e28.
//
// Solidity: function game() view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftSession) Game() (common.Address, error) {
	return _CosmicSignatureNft.Contract.Game(&_CosmicSignatureNft.CallOpts)
}

// Game is a free data retrieval call binding the contract method 0xc3fe3e28.
//
// Solidity: function game() view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) Game() (common.Address, error) {
	return _CosmicSignatureNft.Contract.Game(&_CosmicSignatureNft.CallOpts)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) GetApproved(opts *bind.CallOpts, tokenId *big.Int) (common.Address, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "getApproved", tokenId)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftSession) GetApproved(tokenId *big.Int) (common.Address, error) {
	return _CosmicSignatureNft.Contract.GetApproved(&_CosmicSignatureNft.CallOpts, tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) GetApproved(tokenId *big.Int) (common.Address, error) {
	return _CosmicSignatureNft.Contract.GetApproved(&_CosmicSignatureNft.CallOpts, tokenId)
}

// GetNftInfo is a free data retrieval call binding the contract method 0xd5ec2d83.
//
// Solidity: function getNftInfo(uint256 nftId_) view returns((string,uint256))
func (_CosmicSignatureNft *CosmicSignatureNftCaller) GetNftInfo(opts *bind.CallOpts, nftId_ *big.Int) (ICosmicSignatureNftNftInfo, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "getNftInfo", nftId_)

	if err != nil {
		return *new(ICosmicSignatureNftNftInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(ICosmicSignatureNftNftInfo)).(*ICosmicSignatureNftNftInfo)

	return out0, err

}

// GetNftInfo is a free data retrieval call binding the contract method 0xd5ec2d83.
//
// Solidity: function getNftInfo(uint256 nftId_) view returns((string,uint256))
func (_CosmicSignatureNft *CosmicSignatureNftSession) GetNftInfo(nftId_ *big.Int) (ICosmicSignatureNftNftInfo, error) {
	return _CosmicSignatureNft.Contract.GetNftInfo(&_CosmicSignatureNft.CallOpts, nftId_)
}

// GetNftInfo is a free data retrieval call binding the contract method 0xd5ec2d83.
//
// Solidity: function getNftInfo(uint256 nftId_) view returns((string,uint256))
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) GetNftInfo(nftId_ *big.Int) (ICosmicSignatureNftNftInfo, error) {
	return _CosmicSignatureNft.Contract.GetNftInfo(&_CosmicSignatureNft.CallOpts, nftId_)
}

// GetNftName is a free data retrieval call binding the contract method 0x278ec44f.
//
// Solidity: function getNftName(uint256 nftId_) view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) GetNftName(opts *bind.CallOpts, nftId_ *big.Int) (string, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "getNftName", nftId_)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// GetNftName is a free data retrieval call binding the contract method 0x278ec44f.
//
// Solidity: function getNftName(uint256 nftId_) view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftSession) GetNftName(nftId_ *big.Int) (string, error) {
	return _CosmicSignatureNft.Contract.GetNftName(&_CosmicSignatureNft.CallOpts, nftId_)
}

// GetNftName is a free data retrieval call binding the contract method 0x278ec44f.
//
// Solidity: function getNftName(uint256 nftId_) view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) GetNftName(nftId_ *big.Int) (string, error) {
	return _CosmicSignatureNft.Contract.GetNftName(&_CosmicSignatureNft.CallOpts, nftId_)
}

// GetNftSeed is a free data retrieval call binding the contract method 0xb0c0fe4e.
//
// Solidity: function getNftSeed(uint256 nftId_) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) GetNftSeed(opts *bind.CallOpts, nftId_ *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "getNftSeed", nftId_)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetNftSeed is a free data retrieval call binding the contract method 0xb0c0fe4e.
//
// Solidity: function getNftSeed(uint256 nftId_) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftSession) GetNftSeed(nftId_ *big.Int) (*big.Int, error) {
	return _CosmicSignatureNft.Contract.GetNftSeed(&_CosmicSignatureNft.CallOpts, nftId_)
}

// GetNftSeed is a free data retrieval call binding the contract method 0xb0c0fe4e.
//
// Solidity: function getNftSeed(uint256 nftId_) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) GetNftSeed(nftId_ *big.Int) (*big.Int, error) {
	return _CosmicSignatureNft.Contract.GetNftSeed(&_CosmicSignatureNft.CallOpts, nftId_)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) IsApprovedForAll(opts *bind.CallOpts, owner common.Address, operator common.Address) (bool, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "isApprovedForAll", owner, operator)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_CosmicSignatureNft *CosmicSignatureNftSession) IsApprovedForAll(owner common.Address, operator common.Address) (bool, error) {
	return _CosmicSignatureNft.Contract.IsApprovedForAll(&_CosmicSignatureNft.CallOpts, owner, operator)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) IsApprovedForAll(owner common.Address, operator common.Address) (bool, error) {
	return _CosmicSignatureNft.Contract.IsApprovedForAll(&_CosmicSignatureNft.CallOpts, owner, operator)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) Name(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "name")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftSession) Name() (string, error) {
	return _CosmicSignatureNft.Contract.Name(&_CosmicSignatureNft.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) Name() (string, error) {
	return _CosmicSignatureNft.Contract.Name(&_CosmicSignatureNft.CallOpts)
}

// NftGenerationScriptUri is a free data retrieval call binding the contract method 0x08ab7be8.
//
// Solidity: function nftGenerationScriptUri() view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) NftGenerationScriptUri(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "nftGenerationScriptUri")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// NftGenerationScriptUri is a free data retrieval call binding the contract method 0x08ab7be8.
//
// Solidity: function nftGenerationScriptUri() view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftSession) NftGenerationScriptUri() (string, error) {
	return _CosmicSignatureNft.Contract.NftGenerationScriptUri(&_CosmicSignatureNft.CallOpts)
}

// NftGenerationScriptUri is a free data retrieval call binding the contract method 0x08ab7be8.
//
// Solidity: function nftGenerationScriptUri() view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) NftGenerationScriptUri() (string, error) {
	return _CosmicSignatureNft.Contract.NftGenerationScriptUri(&_CosmicSignatureNft.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftSession) Owner() (common.Address, error) {
	return _CosmicSignatureNft.Contract.Owner(&_CosmicSignatureNft.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) Owner() (common.Address, error) {
	return _CosmicSignatureNft.Contract.Owner(&_CosmicSignatureNft.CallOpts)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) OwnerOf(opts *bind.CallOpts, tokenId *big.Int) (common.Address, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "ownerOf", tokenId)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftSession) OwnerOf(tokenId *big.Int) (common.Address, error) {
	return _CosmicSignatureNft.Contract.OwnerOf(&_CosmicSignatureNft.CallOpts, tokenId)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) OwnerOf(tokenId *big.Int) (common.Address, error) {
	return _CosmicSignatureNft.Contract.OwnerOf(&_CosmicSignatureNft.CallOpts, tokenId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "supportsInterface", interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_CosmicSignatureNft *CosmicSignatureNftSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _CosmicSignatureNft.Contract.SupportsInterface(&_CosmicSignatureNft.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _CosmicSignatureNft.Contract.SupportsInterface(&_CosmicSignatureNft.CallOpts, interfaceId)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) Symbol(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "symbol")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftSession) Symbol() (string, error) {
	return _CosmicSignatureNft.Contract.Symbol(&_CosmicSignatureNft.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) Symbol() (string, error) {
	return _CosmicSignatureNft.Contract.Symbol(&_CosmicSignatureNft.CallOpts)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 index) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) TokenByIndex(opts *bind.CallOpts, index *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "tokenByIndex", index)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 index) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftSession) TokenByIndex(index *big.Int) (*big.Int, error) {
	return _CosmicSignatureNft.Contract.TokenByIndex(&_CosmicSignatureNft.CallOpts, index)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 index) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) TokenByIndex(index *big.Int) (*big.Int, error) {
	return _CosmicSignatureNft.Contract.TokenByIndex(&_CosmicSignatureNft.CallOpts, index)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address owner, uint256 index) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) TokenOfOwnerByIndex(opts *bind.CallOpts, owner common.Address, index *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "tokenOfOwnerByIndex", owner, index)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address owner, uint256 index) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftSession) TokenOfOwnerByIndex(owner common.Address, index *big.Int) (*big.Int, error) {
	return _CosmicSignatureNft.Contract.TokenOfOwnerByIndex(&_CosmicSignatureNft.CallOpts, owner, index)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address owner, uint256 index) view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) TokenOfOwnerByIndex(owner common.Address, index *big.Int) (*big.Int, error) {
	return _CosmicSignatureNft.Contract.TokenOfOwnerByIndex(&_CosmicSignatureNft.CallOpts, owner, index)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 tokenId) view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) TokenURI(opts *bind.CallOpts, tokenId *big.Int) (string, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "tokenURI", tokenId)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 tokenId) view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftSession) TokenURI(tokenId *big.Int) (string, error) {
	return _CosmicSignatureNft.Contract.TokenURI(&_CosmicSignatureNft.CallOpts, tokenId)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 tokenId) view returns(string)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) TokenURI(tokenId *big.Int) (string, error) {
	return _CosmicSignatureNft.Contract.TokenURI(&_CosmicSignatureNft.CallOpts, tokenId)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _CosmicSignatureNft.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftSession) TotalSupply() (*big.Int, error) {
	return _CosmicSignatureNft.Contract.TotalSupply(&_CosmicSignatureNft.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftCallerSession) TotalSupply() (*big.Int, error) {
	return _CosmicSignatureNft.Contract.TotalSupply(&_CosmicSignatureNft.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) Approve(opts *bind.TransactOpts, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "approve", to, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_CosmicSignatureNft *CosmicSignatureNftSession) Approve(to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.Approve(&_CosmicSignatureNft.TransactOpts, to, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) Approve(to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.Approve(&_CosmicSignatureNft.TransactOpts, to, tokenId)
}

// Mint is a paid mutator transaction binding the contract method 0x836a1040.
//
// Solidity: function mint(uint256 roundNum_, address nftOwnerAddress_, uint256 nftSeed_) returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) Mint(opts *bind.TransactOpts, roundNum_ *big.Int, nftOwnerAddress_ common.Address, nftSeed_ *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "mint", roundNum_, nftOwnerAddress_, nftSeed_)
}

// Mint is a paid mutator transaction binding the contract method 0x836a1040.
//
// Solidity: function mint(uint256 roundNum_, address nftOwnerAddress_, uint256 nftSeed_) returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftSession) Mint(roundNum_ *big.Int, nftOwnerAddress_ common.Address, nftSeed_ *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.Mint(&_CosmicSignatureNft.TransactOpts, roundNum_, nftOwnerAddress_, nftSeed_)
}

// Mint is a paid mutator transaction binding the contract method 0x836a1040.
//
// Solidity: function mint(uint256 roundNum_, address nftOwnerAddress_, uint256 nftSeed_) returns(uint256)
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) Mint(roundNum_ *big.Int, nftOwnerAddress_ common.Address, nftSeed_ *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.Mint(&_CosmicSignatureNft.TransactOpts, roundNum_, nftOwnerAddress_, nftSeed_)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_CosmicSignatureNft *CosmicSignatureNftSession) RenounceOwnership() (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.RenounceOwnership(&_CosmicSignatureNft.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.RenounceOwnership(&_CosmicSignatureNft.TransactOpts)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) SafeTransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "safeTransferFrom", from, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_CosmicSignatureNft *CosmicSignatureNftSession) SafeTransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SafeTransferFrom(&_CosmicSignatureNft.TransactOpts, from, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) SafeTransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SafeTransferFrom(&_CosmicSignatureNft.TransactOpts, from, to, tokenId)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) SafeTransferFrom0(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "safeTransferFrom0", from, to, tokenId, data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_CosmicSignatureNft *CosmicSignatureNftSession) SafeTransferFrom0(from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SafeTransferFrom0(&_CosmicSignatureNft.TransactOpts, from, to, tokenId, data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) SafeTransferFrom0(from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SafeTransferFrom0(&_CosmicSignatureNft.TransactOpts, from, to, tokenId, data)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) SetApprovalForAll(opts *bind.TransactOpts, operator common.Address, approved bool) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "setApprovalForAll", operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_CosmicSignatureNft *CosmicSignatureNftSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SetApprovalForAll(&_CosmicSignatureNft.TransactOpts, operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SetApprovalForAll(&_CosmicSignatureNft.TransactOpts, operator, approved)
}

// SetNftBaseUri is a paid mutator transaction binding the contract method 0xe10a312d.
//
// Solidity: function setNftBaseUri(string newValue_) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) SetNftBaseUri(opts *bind.TransactOpts, newValue_ string) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "setNftBaseUri", newValue_)
}

// SetNftBaseUri is a paid mutator transaction binding the contract method 0xe10a312d.
//
// Solidity: function setNftBaseUri(string newValue_) returns()
func (_CosmicSignatureNft *CosmicSignatureNftSession) SetNftBaseUri(newValue_ string) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SetNftBaseUri(&_CosmicSignatureNft.TransactOpts, newValue_)
}

// SetNftBaseUri is a paid mutator transaction binding the contract method 0xe10a312d.
//
// Solidity: function setNftBaseUri(string newValue_) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) SetNftBaseUri(newValue_ string) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SetNftBaseUri(&_CosmicSignatureNft.TransactOpts, newValue_)
}

// SetNftGenerationScriptUri is a paid mutator transaction binding the contract method 0x11c9f23b.
//
// Solidity: function setNftGenerationScriptUri(string newValue_) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) SetNftGenerationScriptUri(opts *bind.TransactOpts, newValue_ string) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "setNftGenerationScriptUri", newValue_)
}

// SetNftGenerationScriptUri is a paid mutator transaction binding the contract method 0x11c9f23b.
//
// Solidity: function setNftGenerationScriptUri(string newValue_) returns()
func (_CosmicSignatureNft *CosmicSignatureNftSession) SetNftGenerationScriptUri(newValue_ string) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SetNftGenerationScriptUri(&_CosmicSignatureNft.TransactOpts, newValue_)
}

// SetNftGenerationScriptUri is a paid mutator transaction binding the contract method 0x11c9f23b.
//
// Solidity: function setNftGenerationScriptUri(string newValue_) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) SetNftGenerationScriptUri(newValue_ string) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SetNftGenerationScriptUri(&_CosmicSignatureNft.TransactOpts, newValue_)
}

// SetNftName is a paid mutator transaction binding the contract method 0xee056e1d.
//
// Solidity: function setNftName(uint256 nftId_, string nftName_) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) SetNftName(opts *bind.TransactOpts, nftId_ *big.Int, nftName_ string) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "setNftName", nftId_, nftName_)
}

// SetNftName is a paid mutator transaction binding the contract method 0xee056e1d.
//
// Solidity: function setNftName(uint256 nftId_, string nftName_) returns()
func (_CosmicSignatureNft *CosmicSignatureNftSession) SetNftName(nftId_ *big.Int, nftName_ string) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SetNftName(&_CosmicSignatureNft.TransactOpts, nftId_, nftName_)
}

// SetNftName is a paid mutator transaction binding the contract method 0xee056e1d.
//
// Solidity: function setNftName(uint256 nftId_, string nftName_) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) SetNftName(nftId_ *big.Int, nftName_ string) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.SetNftName(&_CosmicSignatureNft.TransactOpts, nftId_, nftName_)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "transferFrom", from, to, tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_CosmicSignatureNft *CosmicSignatureNftSession) TransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.TransferFrom(&_CosmicSignatureNft.TransactOpts, from, to, tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) TransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.TransferFrom(&_CosmicSignatureNft.TransactOpts, from, to, tokenId)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _CosmicSignatureNft.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_CosmicSignatureNft *CosmicSignatureNftSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.TransferOwnership(&_CosmicSignatureNft.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_CosmicSignatureNft *CosmicSignatureNftTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _CosmicSignatureNft.Contract.TransferOwnership(&_CosmicSignatureNft.TransactOpts, newOwner)
}

// CosmicSignatureNftApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the CosmicSignatureNft contract.
type CosmicSignatureNftApprovalIterator struct {
	Event *CosmicSignatureNftApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureNftApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureNftApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureNftApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureNftApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureNftApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureNftApproval represents a Approval event raised by the CosmicSignatureNft contract.
type CosmicSignatureNftApproval struct {
	Owner    common.Address
	Approved common.Address
	TokenId  *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, approved []common.Address, tokenId []*big.Int) (*CosmicSignatureNftApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.FilterLogs(opts, "Approval", ownerRule, approvedRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftApprovalIterator{contract: _CosmicSignatureNft.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *CosmicSignatureNftApproval, owner []common.Address, approved []common.Address, tokenId []*big.Int) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.WatchLogs(opts, "Approval", ownerRule, approvedRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureNftApproval)
				if err := _CosmicSignatureNft.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) ParseApproval(log types.Log) (*CosmicSignatureNftApproval, error) {
	event := new(CosmicSignatureNftApproval)
	if err := _CosmicSignatureNft.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureNftApprovalForAllIterator is returned from FilterApprovalForAll and is used to iterate over the raw logs and unpacked data for ApprovalForAll events raised by the CosmicSignatureNft contract.
type CosmicSignatureNftApprovalForAllIterator struct {
	Event *CosmicSignatureNftApprovalForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureNftApprovalForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureNftApprovalForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureNftApprovalForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureNftApprovalForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureNftApprovalForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureNftApprovalForAll represents a ApprovalForAll event raised by the CosmicSignatureNft contract.
type CosmicSignatureNftApprovalForAll struct {
	Owner    common.Address
	Operator common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApprovalForAll is a free log retrieval operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) FilterApprovalForAll(opts *bind.FilterOpts, owner []common.Address, operator []common.Address) (*CosmicSignatureNftApprovalForAllIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.FilterLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftApprovalForAllIterator{contract: _CosmicSignatureNft.contract, event: "ApprovalForAll", logs: logs, sub: sub}, nil
}

// WatchApprovalForAll is a free log subscription operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *CosmicSignatureNftApprovalForAll, owner []common.Address, operator []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.WatchLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureNftApprovalForAll)
				if err := _CosmicSignatureNft.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApprovalForAll is a log parse operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) ParseApprovalForAll(log types.Log) (*CosmicSignatureNftApprovalForAll, error) {
	event := new(CosmicSignatureNftApprovalForAll)
	if err := _CosmicSignatureNft.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureNftNftBaseUriChangedIterator is returned from FilterNftBaseUriChanged and is used to iterate over the raw logs and unpacked data for NftBaseUriChanged events raised by the CosmicSignatureNft contract.
type CosmicSignatureNftNftBaseUriChangedIterator struct {
	Event *CosmicSignatureNftNftBaseUriChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureNftNftBaseUriChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureNftNftBaseUriChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureNftNftBaseUriChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureNftNftBaseUriChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureNftNftBaseUriChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureNftNftBaseUriChanged represents a NftBaseUriChanged event raised by the CosmicSignatureNft contract.
type CosmicSignatureNftNftBaseUriChanged struct {
	NewValue string
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterNftBaseUriChanged is a free log retrieval operation binding the contract event 0xbdfd815215fcee5bb949c941ab489c7ead076a7c8acd3527cd1b50f613ac67e6.
//
// Solidity: event NftBaseUriChanged(string newValue)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) FilterNftBaseUriChanged(opts *bind.FilterOpts) (*CosmicSignatureNftNftBaseUriChangedIterator, error) {

	logs, sub, err := _CosmicSignatureNft.contract.FilterLogs(opts, "NftBaseUriChanged")
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftNftBaseUriChangedIterator{contract: _CosmicSignatureNft.contract, event: "NftBaseUriChanged", logs: logs, sub: sub}, nil
}

// WatchNftBaseUriChanged is a free log subscription operation binding the contract event 0xbdfd815215fcee5bb949c941ab489c7ead076a7c8acd3527cd1b50f613ac67e6.
//
// Solidity: event NftBaseUriChanged(string newValue)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) WatchNftBaseUriChanged(opts *bind.WatchOpts, sink chan<- *CosmicSignatureNftNftBaseUriChanged) (event.Subscription, error) {

	logs, sub, err := _CosmicSignatureNft.contract.WatchLogs(opts, "NftBaseUriChanged")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureNftNftBaseUriChanged)
				if err := _CosmicSignatureNft.contract.UnpackLog(event, "NftBaseUriChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseNftBaseUriChanged is a log parse operation binding the contract event 0xbdfd815215fcee5bb949c941ab489c7ead076a7c8acd3527cd1b50f613ac67e6.
//
// Solidity: event NftBaseUriChanged(string newValue)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) ParseNftBaseUriChanged(log types.Log) (*CosmicSignatureNftNftBaseUriChanged, error) {
	event := new(CosmicSignatureNftNftBaseUriChanged)
	if err := _CosmicSignatureNft.contract.UnpackLog(event, "NftBaseUriChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureNftNftGenerationScriptUriChangedIterator is returned from FilterNftGenerationScriptUriChanged and is used to iterate over the raw logs and unpacked data for NftGenerationScriptUriChanged events raised by the CosmicSignatureNft contract.
type CosmicSignatureNftNftGenerationScriptUriChangedIterator struct {
	Event *CosmicSignatureNftNftGenerationScriptUriChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureNftNftGenerationScriptUriChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureNftNftGenerationScriptUriChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureNftNftGenerationScriptUriChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureNftNftGenerationScriptUriChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureNftNftGenerationScriptUriChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureNftNftGenerationScriptUriChanged represents a NftGenerationScriptUriChanged event raised by the CosmicSignatureNft contract.
type CosmicSignatureNftNftGenerationScriptUriChanged struct {
	NewValue string
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterNftGenerationScriptUriChanged is a free log retrieval operation binding the contract event 0x27e2bd70f498920ee0fd7d8204ae8845b75dc81330e3acafa32946be3503730c.
//
// Solidity: event NftGenerationScriptUriChanged(string newValue)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) FilterNftGenerationScriptUriChanged(opts *bind.FilterOpts) (*CosmicSignatureNftNftGenerationScriptUriChangedIterator, error) {

	logs, sub, err := _CosmicSignatureNft.contract.FilterLogs(opts, "NftGenerationScriptUriChanged")
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftNftGenerationScriptUriChangedIterator{contract: _CosmicSignatureNft.contract, event: "NftGenerationScriptUriChanged", logs: logs, sub: sub}, nil
}

// WatchNftGenerationScriptUriChanged is a free log subscription operation binding the contract event 0x27e2bd70f498920ee0fd7d8204ae8845b75dc81330e3acafa32946be3503730c.
//
// Solidity: event NftGenerationScriptUriChanged(string newValue)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) WatchNftGenerationScriptUriChanged(opts *bind.WatchOpts, sink chan<- *CosmicSignatureNftNftGenerationScriptUriChanged) (event.Subscription, error) {

	logs, sub, err := _CosmicSignatureNft.contract.WatchLogs(opts, "NftGenerationScriptUriChanged")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureNftNftGenerationScriptUriChanged)
				if err := _CosmicSignatureNft.contract.UnpackLog(event, "NftGenerationScriptUriChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseNftGenerationScriptUriChanged is a log parse operation binding the contract event 0x27e2bd70f498920ee0fd7d8204ae8845b75dc81330e3acafa32946be3503730c.
//
// Solidity: event NftGenerationScriptUriChanged(string newValue)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) ParseNftGenerationScriptUriChanged(log types.Log) (*CosmicSignatureNftNftGenerationScriptUriChanged, error) {
	event := new(CosmicSignatureNftNftGenerationScriptUriChanged)
	if err := _CosmicSignatureNft.contract.UnpackLog(event, "NftGenerationScriptUriChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureNftNftMintedIterator is returned from FilterNftMinted and is used to iterate over the raw logs and unpacked data for NftMinted events raised by the CosmicSignatureNft contract.
type CosmicSignatureNftNftMintedIterator struct {
	Event *CosmicSignatureNftNftMinted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureNftNftMintedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureNftNftMinted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureNftNftMinted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureNftNftMintedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureNftNftMintedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureNftNftMinted represents a NftMinted event raised by the CosmicSignatureNft contract.
type CosmicSignatureNftNftMinted struct {
	RoundNum        *big.Int
	NftOwnerAddress common.Address
	NftSeed         *big.Int
	NftId           *big.Int
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterNftMinted is a free log retrieval operation binding the contract event 0xc2115f21464937bfdcd1560f96f0e20b70e88accbdcd1069084c80c8797ef106.
//
// Solidity: event NftMinted(uint256 indexed roundNum, address indexed nftOwnerAddress, uint256 nftSeed, uint256 indexed nftId)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) FilterNftMinted(opts *bind.FilterOpts, roundNum []*big.Int, nftOwnerAddress []common.Address, nftId []*big.Int) (*CosmicSignatureNftNftMintedIterator, error) {

	var roundNumRule []interface{}
	for _, roundNumItem := range roundNum {
		roundNumRule = append(roundNumRule, roundNumItem)
	}
	var nftOwnerAddressRule []interface{}
	for _, nftOwnerAddressItem := range nftOwnerAddress {
		nftOwnerAddressRule = append(nftOwnerAddressRule, nftOwnerAddressItem)
	}

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.FilterLogs(opts, "NftMinted", roundNumRule, nftOwnerAddressRule, nftIdRule)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftNftMintedIterator{contract: _CosmicSignatureNft.contract, event: "NftMinted", logs: logs, sub: sub}, nil
}

// WatchNftMinted is a free log subscription operation binding the contract event 0xc2115f21464937bfdcd1560f96f0e20b70e88accbdcd1069084c80c8797ef106.
//
// Solidity: event NftMinted(uint256 indexed roundNum, address indexed nftOwnerAddress, uint256 nftSeed, uint256 indexed nftId)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) WatchNftMinted(opts *bind.WatchOpts, sink chan<- *CosmicSignatureNftNftMinted, roundNum []*big.Int, nftOwnerAddress []common.Address, nftId []*big.Int) (event.Subscription, error) {

	var roundNumRule []interface{}
	for _, roundNumItem := range roundNum {
		roundNumRule = append(roundNumRule, roundNumItem)
	}
	var nftOwnerAddressRule []interface{}
	for _, nftOwnerAddressItem := range nftOwnerAddress {
		nftOwnerAddressRule = append(nftOwnerAddressRule, nftOwnerAddressItem)
	}

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.WatchLogs(opts, "NftMinted", roundNumRule, nftOwnerAddressRule, nftIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureNftNftMinted)
				if err := _CosmicSignatureNft.contract.UnpackLog(event, "NftMinted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseNftMinted is a log parse operation binding the contract event 0xc2115f21464937bfdcd1560f96f0e20b70e88accbdcd1069084c80c8797ef106.
//
// Solidity: event NftMinted(uint256 indexed roundNum, address indexed nftOwnerAddress, uint256 nftSeed, uint256 indexed nftId)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) ParseNftMinted(log types.Log) (*CosmicSignatureNftNftMinted, error) {
	event := new(CosmicSignatureNftNftMinted)
	if err := _CosmicSignatureNft.contract.UnpackLog(event, "NftMinted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureNftNftNameChangedIterator is returned from FilterNftNameChanged and is used to iterate over the raw logs and unpacked data for NftNameChanged events raised by the CosmicSignatureNft contract.
type CosmicSignatureNftNftNameChangedIterator struct {
	Event *CosmicSignatureNftNftNameChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureNftNftNameChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureNftNftNameChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureNftNftNameChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureNftNftNameChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureNftNftNameChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureNftNftNameChanged represents a NftNameChanged event raised by the CosmicSignatureNft contract.
type CosmicSignatureNftNftNameChanged struct {
	NftId   *big.Int
	NftName string
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterNftNameChanged is a free log retrieval operation binding the contract event 0xa14cfb0fe69c0b55eaaa4d9400bdba2a72e1860cade89c2a8a055e6cfde8936d.
//
// Solidity: event NftNameChanged(uint256 indexed nftId, string nftName)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) FilterNftNameChanged(opts *bind.FilterOpts, nftId []*big.Int) (*CosmicSignatureNftNftNameChangedIterator, error) {

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.FilterLogs(opts, "NftNameChanged", nftIdRule)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftNftNameChangedIterator{contract: _CosmicSignatureNft.contract, event: "NftNameChanged", logs: logs, sub: sub}, nil
}

// WatchNftNameChanged is a free log subscription operation binding the contract event 0xa14cfb0fe69c0b55eaaa4d9400bdba2a72e1860cade89c2a8a055e6cfde8936d.
//
// Solidity: event NftNameChanged(uint256 indexed nftId, string nftName)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) WatchNftNameChanged(opts *bind.WatchOpts, sink chan<- *CosmicSignatureNftNftNameChanged, nftId []*big.Int) (event.Subscription, error) {

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.WatchLogs(opts, "NftNameChanged", nftIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureNftNftNameChanged)
				if err := _CosmicSignatureNft.contract.UnpackLog(event, "NftNameChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseNftNameChanged is a log parse operation binding the contract event 0xa14cfb0fe69c0b55eaaa4d9400bdba2a72e1860cade89c2a8a055e6cfde8936d.
//
// Solidity: event NftNameChanged(uint256 indexed nftId, string nftName)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) ParseNftNameChanged(log types.Log) (*CosmicSignatureNftNftNameChanged, error) {
	event := new(CosmicSignatureNftNftNameChanged)
	if err := _CosmicSignatureNft.contract.UnpackLog(event, "NftNameChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureNftOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the CosmicSignatureNft contract.
type CosmicSignatureNftOwnershipTransferredIterator struct {
	Event *CosmicSignatureNftOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureNftOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureNftOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureNftOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureNftOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureNftOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureNftOwnershipTransferred represents a OwnershipTransferred event raised by the CosmicSignatureNft contract.
type CosmicSignatureNftOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*CosmicSignatureNftOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftOwnershipTransferredIterator{contract: _CosmicSignatureNft.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *CosmicSignatureNftOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureNftOwnershipTransferred)
				if err := _CosmicSignatureNft.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) ParseOwnershipTransferred(log types.Log) (*CosmicSignatureNftOwnershipTransferred, error) {
	event := new(CosmicSignatureNftOwnershipTransferred)
	if err := _CosmicSignatureNft.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureNftTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the CosmicSignatureNft contract.
type CosmicSignatureNftTransferIterator struct {
	Event *CosmicSignatureNftTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureNftTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureNftTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureNftTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureNftTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureNftTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureNftTransfer represents a Transfer event raised by the CosmicSignatureNft contract.
type CosmicSignatureNftTransfer struct {
	From    common.Address
	To      common.Address
	TokenId *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenId []*big.Int) (*CosmicSignatureNftTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.FilterLogs(opts, "Transfer", fromRule, toRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureNftTransferIterator{contract: _CosmicSignatureNft.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *CosmicSignatureNftTransfer, from []common.Address, to []common.Address, tokenId []*big.Int) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _CosmicSignatureNft.contract.WatchLogs(opts, "Transfer", fromRule, toRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureNftTransfer)
				if err := _CosmicSignatureNft.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_CosmicSignatureNft *CosmicSignatureNftFilterer) ParseTransfer(log types.Log) (*CosmicSignatureNftTransfer, error) {
	event := new(CosmicSignatureNftTransfer)
	if err := _CosmicSignatureNft.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureNftMetaData contains all meta data concerning the ICosmicSignatureNft contract.
var ICosmicSignatureNftMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newValue\",\"type\":\"string\"}],\"name\":\"NftBaseUriChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newValue\",\"type\":\"string\"}],\"name\":\"NftGenerationScriptUriChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundNum\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftOwnerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftSeed\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"NftMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"nftName\",\"type\":\"string\"}],\"name\":\"NftNameChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId_\",\"type\":\"uint256\"}],\"name\":\"getNftInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"}],\"internalType\":\"structICosmicSignatureNft.NftInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId_\",\"type\":\"uint256\"}],\"name\":\"getNftName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId_\",\"type\":\"uint256\"}],\"name\":\"getNftSeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundNum_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftOwnerAddress_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftSeed_\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newValue_\",\"type\":\"string\"}],\"name\":\"setNftBaseUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newValue_\",\"type\":\"string\"}],\"name\":\"setNftGenerationScriptUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"nftName_\",\"type\":\"string\"}],\"name\":\"setNftName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// ICosmicSignatureNftABI is the input ABI used to generate the binding from.
// Deprecated: Use ICosmicSignatureNftMetaData.ABI instead.
var ICosmicSignatureNftABI = ICosmicSignatureNftMetaData.ABI

// ICosmicSignatureNft is an auto generated Go binding around an Ethereum contract.
type ICosmicSignatureNft struct {
	ICosmicSignatureNftCaller     // Read-only binding to the contract
	ICosmicSignatureNftTransactor // Write-only binding to the contract
	ICosmicSignatureNftFilterer   // Log filterer for contract events
}

// ICosmicSignatureNftCaller is an auto generated read-only Go binding around an Ethereum contract.
type ICosmicSignatureNftCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ICosmicSignatureNftTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ICosmicSignatureNftTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ICosmicSignatureNftFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ICosmicSignatureNftFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ICosmicSignatureNftSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ICosmicSignatureNftSession struct {
	Contract     *ICosmicSignatureNft // Generic contract binding to set the session for
	CallOpts     bind.CallOpts        // Call options to use throughout this session
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// ICosmicSignatureNftCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ICosmicSignatureNftCallerSession struct {
	Contract *ICosmicSignatureNftCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts              // Call options to use throughout this session
}

// ICosmicSignatureNftTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ICosmicSignatureNftTransactorSession struct {
	Contract     *ICosmicSignatureNftTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts              // Transaction auth options to use throughout this session
}

// ICosmicSignatureNftRaw is an auto generated low-level Go binding around an Ethereum contract.
type ICosmicSignatureNftRaw struct {
	Contract *ICosmicSignatureNft // Generic contract binding to access the raw methods on
}

// ICosmicSignatureNftCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ICosmicSignatureNftCallerRaw struct {
	Contract *ICosmicSignatureNftCaller // Generic read-only contract binding to access the raw methods on
}

// ICosmicSignatureNftTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ICosmicSignatureNftTransactorRaw struct {
	Contract *ICosmicSignatureNftTransactor // Generic write-only contract binding to access the raw methods on
}

// NewICosmicSignatureNft creates a new instance of ICosmicSignatureNft, bound to a specific deployed contract.
func NewICosmicSignatureNft(address common.Address, backend bind.ContractBackend) (*ICosmicSignatureNft, error) {
	contract, err := bindICosmicSignatureNft(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureNft{ICosmicSignatureNftCaller: ICosmicSignatureNftCaller{contract: contract}, ICosmicSignatureNftTransactor: ICosmicSignatureNftTransactor{contract: contract}, ICosmicSignatureNftFilterer: ICosmicSignatureNftFilterer{contract: contract}}, nil
}

// NewICosmicSignatureNftCaller creates a new read-only instance of ICosmicSignatureNft, bound to a specific deployed contract.
func NewICosmicSignatureNftCaller(address common.Address, caller bind.ContractCaller) (*ICosmicSignatureNftCaller, error) {
	contract, err := bindICosmicSignatureNft(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureNftCaller{contract: contract}, nil
}

// NewICosmicSignatureNftTransactor creates a new write-only instance of ICosmicSignatureNft, bound to a specific deployed contract.
func NewICosmicSignatureNftTransactor(address common.Address, transactor bind.ContractTransactor) (*ICosmicSignatureNftTransactor, error) {
	contract, err := bindICosmicSignatureNft(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureNftTransactor{contract: contract}, nil
}

// NewICosmicSignatureNftFilterer creates a new log filterer instance of ICosmicSignatureNft, bound to a specific deployed contract.
func NewICosmicSignatureNftFilterer(address common.Address, filterer bind.ContractFilterer) (*ICosmicSignatureNftFilterer, error) {
	contract, err := bindICosmicSignatureNft(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureNftFilterer{contract: contract}, nil
}

// bindICosmicSignatureNft binds a generic wrapper to an already deployed contract.
func bindICosmicSignatureNft(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ICosmicSignatureNftMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ICosmicSignatureNft *ICosmicSignatureNftRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ICosmicSignatureNft.Contract.ICosmicSignatureNftCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ICosmicSignatureNft *ICosmicSignatureNftRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.ICosmicSignatureNftTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ICosmicSignatureNft *ICosmicSignatureNftRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.ICosmicSignatureNftTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ICosmicSignatureNft *ICosmicSignatureNftCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ICosmicSignatureNft.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.contract.Transact(opts, method, params...)
}

// GetNftInfo is a free data retrieval call binding the contract method 0xd5ec2d83.
//
// Solidity: function getNftInfo(uint256 nftId_) view returns((string,uint256))
func (_ICosmicSignatureNft *ICosmicSignatureNftCaller) GetNftInfo(opts *bind.CallOpts, nftId_ *big.Int) (ICosmicSignatureNftNftInfo, error) {
	var out []interface{}
	err := _ICosmicSignatureNft.contract.Call(opts, &out, "getNftInfo", nftId_)

	if err != nil {
		return *new(ICosmicSignatureNftNftInfo), err
	}

	out0 := *abi.ConvertType(out[0], new(ICosmicSignatureNftNftInfo)).(*ICosmicSignatureNftNftInfo)

	return out0, err

}

// GetNftInfo is a free data retrieval call binding the contract method 0xd5ec2d83.
//
// Solidity: function getNftInfo(uint256 nftId_) view returns((string,uint256))
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) GetNftInfo(nftId_ *big.Int) (ICosmicSignatureNftNftInfo, error) {
	return _ICosmicSignatureNft.Contract.GetNftInfo(&_ICosmicSignatureNft.CallOpts, nftId_)
}

// GetNftInfo is a free data retrieval call binding the contract method 0xd5ec2d83.
//
// Solidity: function getNftInfo(uint256 nftId_) view returns((string,uint256))
func (_ICosmicSignatureNft *ICosmicSignatureNftCallerSession) GetNftInfo(nftId_ *big.Int) (ICosmicSignatureNftNftInfo, error) {
	return _ICosmicSignatureNft.Contract.GetNftInfo(&_ICosmicSignatureNft.CallOpts, nftId_)
}

// GetNftName is a free data retrieval call binding the contract method 0x278ec44f.
//
// Solidity: function getNftName(uint256 nftId_) view returns(string)
func (_ICosmicSignatureNft *ICosmicSignatureNftCaller) GetNftName(opts *bind.CallOpts, nftId_ *big.Int) (string, error) {
	var out []interface{}
	err := _ICosmicSignatureNft.contract.Call(opts, &out, "getNftName", nftId_)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// GetNftName is a free data retrieval call binding the contract method 0x278ec44f.
//
// Solidity: function getNftName(uint256 nftId_) view returns(string)
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) GetNftName(nftId_ *big.Int) (string, error) {
	return _ICosmicSignatureNft.Contract.GetNftName(&_ICosmicSignatureNft.CallOpts, nftId_)
}

// GetNftName is a free data retrieval call binding the contract method 0x278ec44f.
//
// Solidity: function getNftName(uint256 nftId_) view returns(string)
func (_ICosmicSignatureNft *ICosmicSignatureNftCallerSession) GetNftName(nftId_ *big.Int) (string, error) {
	return _ICosmicSignatureNft.Contract.GetNftName(&_ICosmicSignatureNft.CallOpts, nftId_)
}

// GetNftSeed is a free data retrieval call binding the contract method 0xb0c0fe4e.
//
// Solidity: function getNftSeed(uint256 nftId_) view returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftCaller) GetNftSeed(opts *bind.CallOpts, nftId_ *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _ICosmicSignatureNft.contract.Call(opts, &out, "getNftSeed", nftId_)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetNftSeed is a free data retrieval call binding the contract method 0xb0c0fe4e.
//
// Solidity: function getNftSeed(uint256 nftId_) view returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) GetNftSeed(nftId_ *big.Int) (*big.Int, error) {
	return _ICosmicSignatureNft.Contract.GetNftSeed(&_ICosmicSignatureNft.CallOpts, nftId_)
}

// GetNftSeed is a free data retrieval call binding the contract method 0xb0c0fe4e.
//
// Solidity: function getNftSeed(uint256 nftId_) view returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftCallerSession) GetNftSeed(nftId_ *big.Int) (*big.Int, error) {
	return _ICosmicSignatureNft.Contract.GetNftSeed(&_ICosmicSignatureNft.CallOpts, nftId_)
}

// Mint is a paid mutator transaction binding the contract method 0x836a1040.
//
// Solidity: function mint(uint256 roundNum_, address nftOwnerAddress_, uint256 nftSeed_) returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactor) Mint(opts *bind.TransactOpts, roundNum_ *big.Int, nftOwnerAddress_ common.Address, nftSeed_ *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.contract.Transact(opts, "mint", roundNum_, nftOwnerAddress_, nftSeed_)
}

// Mint is a paid mutator transaction binding the contract method 0x836a1040.
//
// Solidity: function mint(uint256 roundNum_, address nftOwnerAddress_, uint256 nftSeed_) returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) Mint(roundNum_ *big.Int, nftOwnerAddress_ common.Address, nftSeed_ *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.Mint(&_ICosmicSignatureNft.TransactOpts, roundNum_, nftOwnerAddress_, nftSeed_)
}

// Mint is a paid mutator transaction binding the contract method 0x836a1040.
//
// Solidity: function mint(uint256 roundNum_, address nftOwnerAddress_, uint256 nftSeed_) returns(uint256)
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactorSession) Mint(roundNum_ *big.Int, nftOwnerAddress_ common.Address, nftSeed_ *big.Int) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.Mint(&_ICosmicSignatureNft.TransactOpts, roundNum_, nftOwnerAddress_, nftSeed_)
}

// SetNftBaseUri is a paid mutator transaction binding the contract method 0xe10a312d.
//
// Solidity: function setNftBaseUri(string newValue_) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactor) SetNftBaseUri(opts *bind.TransactOpts, newValue_ string) (*types.Transaction, error) {
	return _ICosmicSignatureNft.contract.Transact(opts, "setNftBaseUri", newValue_)
}

// SetNftBaseUri is a paid mutator transaction binding the contract method 0xe10a312d.
//
// Solidity: function setNftBaseUri(string newValue_) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) SetNftBaseUri(newValue_ string) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.SetNftBaseUri(&_ICosmicSignatureNft.TransactOpts, newValue_)
}

// SetNftBaseUri is a paid mutator transaction binding the contract method 0xe10a312d.
//
// Solidity: function setNftBaseUri(string newValue_) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactorSession) SetNftBaseUri(newValue_ string) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.SetNftBaseUri(&_ICosmicSignatureNft.TransactOpts, newValue_)
}

// SetNftGenerationScriptUri is a paid mutator transaction binding the contract method 0x11c9f23b.
//
// Solidity: function setNftGenerationScriptUri(string newValue_) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactor) SetNftGenerationScriptUri(opts *bind.TransactOpts, newValue_ string) (*types.Transaction, error) {
	return _ICosmicSignatureNft.contract.Transact(opts, "setNftGenerationScriptUri", newValue_)
}

// SetNftGenerationScriptUri is a paid mutator transaction binding the contract method 0x11c9f23b.
//
// Solidity: function setNftGenerationScriptUri(string newValue_) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) SetNftGenerationScriptUri(newValue_ string) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.SetNftGenerationScriptUri(&_ICosmicSignatureNft.TransactOpts, newValue_)
}

// SetNftGenerationScriptUri is a paid mutator transaction binding the contract method 0x11c9f23b.
//
// Solidity: function setNftGenerationScriptUri(string newValue_) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactorSession) SetNftGenerationScriptUri(newValue_ string) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.SetNftGenerationScriptUri(&_ICosmicSignatureNft.TransactOpts, newValue_)
}

// SetNftName is a paid mutator transaction binding the contract method 0xee056e1d.
//
// Solidity: function setNftName(uint256 nftId_, string nftName_) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactor) SetNftName(opts *bind.TransactOpts, nftId_ *big.Int, nftName_ string) (*types.Transaction, error) {
	return _ICosmicSignatureNft.contract.Transact(opts, "setNftName", nftId_, nftName_)
}

// SetNftName is a paid mutator transaction binding the contract method 0xee056e1d.
//
// Solidity: function setNftName(uint256 nftId_, string nftName_) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftSession) SetNftName(nftId_ *big.Int, nftName_ string) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.SetNftName(&_ICosmicSignatureNft.TransactOpts, nftId_, nftName_)
}

// SetNftName is a paid mutator transaction binding the contract method 0xee056e1d.
//
// Solidity: function setNftName(uint256 nftId_, string nftName_) returns()
func (_ICosmicSignatureNft *ICosmicSignatureNftTransactorSession) SetNftName(nftId_ *big.Int, nftName_ string) (*types.Transaction, error) {
	return _ICosmicSignatureNft.Contract.SetNftName(&_ICosmicSignatureNft.TransactOpts, nftId_, nftName_)
}

// ICosmicSignatureNftNftBaseUriChangedIterator is returned from FilterNftBaseUriChanged and is used to iterate over the raw logs and unpacked data for NftBaseUriChanged events raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftNftBaseUriChangedIterator struct {
	Event *ICosmicSignatureNftNftBaseUriChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureNftNftBaseUriChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureNftNftBaseUriChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureNftNftBaseUriChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureNftNftBaseUriChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureNftNftBaseUriChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureNftNftBaseUriChanged represents a NftBaseUriChanged event raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftNftBaseUriChanged struct {
	NewValue string
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterNftBaseUriChanged is a free log retrieval operation binding the contract event 0xbdfd815215fcee5bb949c941ab489c7ead076a7c8acd3527cd1b50f613ac67e6.
//
// Solidity: event NftBaseUriChanged(string newValue)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) FilterNftBaseUriChanged(opts *bind.FilterOpts) (*ICosmicSignatureNftNftBaseUriChangedIterator, error) {

	logs, sub, err := _ICosmicSignatureNft.contract.FilterLogs(opts, "NftBaseUriChanged")
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureNftNftBaseUriChangedIterator{contract: _ICosmicSignatureNft.contract, event: "NftBaseUriChanged", logs: logs, sub: sub}, nil
}

// WatchNftBaseUriChanged is a free log subscription operation binding the contract event 0xbdfd815215fcee5bb949c941ab489c7ead076a7c8acd3527cd1b50f613ac67e6.
//
// Solidity: event NftBaseUriChanged(string newValue)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) WatchNftBaseUriChanged(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureNftNftBaseUriChanged) (event.Subscription, error) {

	logs, sub, err := _ICosmicSignatureNft.contract.WatchLogs(opts, "NftBaseUriChanged")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureNftNftBaseUriChanged)
				if err := _ICosmicSignatureNft.contract.UnpackLog(event, "NftBaseUriChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseNftBaseUriChanged is a log parse operation binding the contract event 0xbdfd815215fcee5bb949c941ab489c7ead076a7c8acd3527cd1b50f613ac67e6.
//
// Solidity: event NftBaseUriChanged(string newValue)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) ParseNftBaseUriChanged(log types.Log) (*ICosmicSignatureNftNftBaseUriChanged, error) {
	event := new(ICosmicSignatureNftNftBaseUriChanged)
	if err := _ICosmicSignatureNft.contract.UnpackLog(event, "NftBaseUriChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureNftNftGenerationScriptUriChangedIterator is returned from FilterNftGenerationScriptUriChanged and is used to iterate over the raw logs and unpacked data for NftGenerationScriptUriChanged events raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftNftGenerationScriptUriChangedIterator struct {
	Event *ICosmicSignatureNftNftGenerationScriptUriChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureNftNftGenerationScriptUriChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureNftNftGenerationScriptUriChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureNftNftGenerationScriptUriChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureNftNftGenerationScriptUriChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureNftNftGenerationScriptUriChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureNftNftGenerationScriptUriChanged represents a NftGenerationScriptUriChanged event raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftNftGenerationScriptUriChanged struct {
	NewValue string
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterNftGenerationScriptUriChanged is a free log retrieval operation binding the contract event 0x27e2bd70f498920ee0fd7d8204ae8845b75dc81330e3acafa32946be3503730c.
//
// Solidity: event NftGenerationScriptUriChanged(string newValue)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) FilterNftGenerationScriptUriChanged(opts *bind.FilterOpts) (*ICosmicSignatureNftNftGenerationScriptUriChangedIterator, error) {

	logs, sub, err := _ICosmicSignatureNft.contract.FilterLogs(opts, "NftGenerationScriptUriChanged")
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureNftNftGenerationScriptUriChangedIterator{contract: _ICosmicSignatureNft.contract, event: "NftGenerationScriptUriChanged", logs: logs, sub: sub}, nil
}

// WatchNftGenerationScriptUriChanged is a free log subscription operation binding the contract event 0x27e2bd70f498920ee0fd7d8204ae8845b75dc81330e3acafa32946be3503730c.
//
// Solidity: event NftGenerationScriptUriChanged(string newValue)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) WatchNftGenerationScriptUriChanged(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureNftNftGenerationScriptUriChanged) (event.Subscription, error) {

	logs, sub, err := _ICosmicSignatureNft.contract.WatchLogs(opts, "NftGenerationScriptUriChanged")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureNftNftGenerationScriptUriChanged)
				if err := _ICosmicSignatureNft.contract.UnpackLog(event, "NftGenerationScriptUriChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseNftGenerationScriptUriChanged is a log parse operation binding the contract event 0x27e2bd70f498920ee0fd7d8204ae8845b75dc81330e3acafa32946be3503730c.
//
// Solidity: event NftGenerationScriptUriChanged(string newValue)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) ParseNftGenerationScriptUriChanged(log types.Log) (*ICosmicSignatureNftNftGenerationScriptUriChanged, error) {
	event := new(ICosmicSignatureNftNftGenerationScriptUriChanged)
	if err := _ICosmicSignatureNft.contract.UnpackLog(event, "NftGenerationScriptUriChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureNftNftMintedIterator is returned from FilterNftMinted and is used to iterate over the raw logs and unpacked data for NftMinted events raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftNftMintedIterator struct {
	Event *ICosmicSignatureNftNftMinted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureNftNftMintedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureNftNftMinted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureNftNftMinted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureNftNftMintedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureNftNftMintedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureNftNftMinted represents a NftMinted event raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftNftMinted struct {
	RoundNum        *big.Int
	NftOwnerAddress common.Address
	NftSeed         *big.Int
	NftId           *big.Int
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterNftMinted is a free log retrieval operation binding the contract event 0xc2115f21464937bfdcd1560f96f0e20b70e88accbdcd1069084c80c8797ef106.
//
// Solidity: event NftMinted(uint256 indexed roundNum, address indexed nftOwnerAddress, uint256 nftSeed, uint256 indexed nftId)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) FilterNftMinted(opts *bind.FilterOpts, roundNum []*big.Int, nftOwnerAddress []common.Address, nftId []*big.Int) (*ICosmicSignatureNftNftMintedIterator, error) {

	var roundNumRule []interface{}
	for _, roundNumItem := range roundNum {
		roundNumRule = append(roundNumRule, roundNumItem)
	}
	var nftOwnerAddressRule []interface{}
	for _, nftOwnerAddressItem := range nftOwnerAddress {
		nftOwnerAddressRule = append(nftOwnerAddressRule, nftOwnerAddressItem)
	}

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}

	logs, sub, err := _ICosmicSignatureNft.contract.FilterLogs(opts, "NftMinted", roundNumRule, nftOwnerAddressRule, nftIdRule)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureNftNftMintedIterator{contract: _ICosmicSignatureNft.contract, event: "NftMinted", logs: logs, sub: sub}, nil
}

// WatchNftMinted is a free log subscription operation binding the contract event 0xc2115f21464937bfdcd1560f96f0e20b70e88accbdcd1069084c80c8797ef106.
//
// Solidity: event NftMinted(uint256 indexed roundNum, address indexed nftOwnerAddress, uint256 nftSeed, uint256 indexed nftId)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) WatchNftMinted(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureNftNftMinted, roundNum []*big.Int, nftOwnerAddress []common.Address, nftId []*big.Int) (event.Subscription, error) {

	var roundNumRule []interface{}
	for _, roundNumItem := range roundNum {
		roundNumRule = append(roundNumRule, roundNumItem)
	}
	var nftOwnerAddressRule []interface{}
	for _, nftOwnerAddressItem := range nftOwnerAddress {
		nftOwnerAddressRule = append(nftOwnerAddressRule, nftOwnerAddressItem)
	}

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}

	logs, sub, err := _ICosmicSignatureNft.contract.WatchLogs(opts, "NftMinted", roundNumRule, nftOwnerAddressRule, nftIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureNftNftMinted)
				if err := _ICosmicSignatureNft.contract.UnpackLog(event, "NftMinted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseNftMinted is a log parse operation binding the contract event 0xc2115f21464937bfdcd1560f96f0e20b70e88accbdcd1069084c80c8797ef106.
//
// Solidity: event NftMinted(uint256 indexed roundNum, address indexed nftOwnerAddress, uint256 nftSeed, uint256 indexed nftId)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) ParseNftMinted(log types.Log) (*ICosmicSignatureNftNftMinted, error) {
	event := new(ICosmicSignatureNftNftMinted)
	if err := _ICosmicSignatureNft.contract.UnpackLog(event, "NftMinted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureNftNftNameChangedIterator is returned from FilterNftNameChanged and is used to iterate over the raw logs and unpacked data for NftNameChanged events raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftNftNameChangedIterator struct {
	Event *ICosmicSignatureNftNftNameChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureNftNftNameChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureNftNftNameChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureNftNftNameChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureNftNftNameChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureNftNftNameChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureNftNftNameChanged represents a NftNameChanged event raised by the ICosmicSignatureNft contract.
type ICosmicSignatureNftNftNameChanged struct {
	NftId   *big.Int
	NftName string
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterNftNameChanged is a free log retrieval operation binding the contract event 0xa14cfb0fe69c0b55eaaa4d9400bdba2a72e1860cade89c2a8a055e6cfde8936d.
//
// Solidity: event NftNameChanged(uint256 indexed nftId, string nftName)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) FilterNftNameChanged(opts *bind.FilterOpts, nftId []*big.Int) (*ICosmicSignatureNftNftNameChangedIterator, error) {

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}

	logs, sub, err := _ICosmicSignatureNft.contract.FilterLogs(opts, "NftNameChanged", nftIdRule)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureNftNftNameChangedIterator{contract: _ICosmicSignatureNft.contract, event: "NftNameChanged", logs: logs, sub: sub}, nil
}

// WatchNftNameChanged is a free log subscription operation binding the contract event 0xa14cfb0fe69c0b55eaaa4d9400bdba2a72e1860cade89c2a8a055e6cfde8936d.
//
// Solidity: event NftNameChanged(uint256 indexed nftId, string nftName)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) WatchNftNameChanged(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureNftNftNameChanged, nftId []*big.Int) (event.Subscription, error) {

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}

	logs, sub, err := _ICosmicSignatureNft.contract.WatchLogs(opts, "NftNameChanged", nftIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureNftNftNameChanged)
				if err := _ICosmicSignatureNft.contract.UnpackLog(event, "NftNameChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseNftNameChanged is a log parse operation binding the contract event 0xa14cfb0fe69c0b55eaaa4d9400bdba2a72e1860cade89c2a8a055e6cfde8936d.
//
// Solidity: event NftNameChanged(uint256 indexed nftId, string nftName)
func (_ICosmicSignatureNft *ICosmicSignatureNftFilterer) ParseNftNameChanged(log types.Log) (*ICosmicSignatureNftNftNameChanged, error) {
	event := new(ICosmicSignatureNftNftNameChanged)
	if err := _ICosmicSignatureNft.contract.UnpackLog(event, "NftNameChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
