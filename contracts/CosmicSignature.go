// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package contracts

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// CosmicSignatureMetaData contains all meta data concerning the CosmicSignature contract.
var CosmicSignatureMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_cosmicGameProxyContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ERC721EnumerableForbiddenBatchMint\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ERC721IncorrectOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ERC721InsufficientApproval\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"ERC721InvalidApprover\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"ERC721InvalidOperator\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ERC721InvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ERC721InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ERC721InvalidSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ERC721NonexistentToken\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"ERC721OutOfBoundsIndex\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"errStr\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"}],\"name\":\"NoMintPrivileges\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"errStr\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"OwnershipError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"errStr\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"len\",\"type\":\"uint256\"}],\"name\":\"TokenNameLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"errStr\",\"type\":\"string\"}],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newURI\",\"type\":\"string\"}],\"name\":\"BaseURIEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"seed\",\"type\":\"bytes32\"}],\"name\":\"MintEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newURL\",\"type\":\"string\"}],\"name\":\"TokenGenerationScriptURLEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"}],\"name\":\"TokenNameEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cosmicGameProxyContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"entropy\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roundNum\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"seeds\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newTokenGenerationScriptURL\",\"type\":\"string\"}],\"name\":\"setTokenGenerationScriptURL\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"setTokenName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenGenerationScriptURL\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenNames\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x60a06040523461003f57610019610014610104565b6105c8565b610021610044565b61326c6109a58239608051818181610ab9015261151f015261326c90f35b61004a565b60405190565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b906100769061004e565b810190811060018060401b0382111761008e57604052565b610058565b906100a661009f610044565b928361006c565b565b5f80fd5b60018060a01b031690565b6100c0906100ac565b90565b6100cc816100b7565b036100d357565b5f80fd5b905051906100e4826100c3565b565b906020828203126100ff576100fc915f016100d7565b90565b6100a8565b610122613c118038038061011781610093565b9283398101906100e6565b90565b60018060401b0381116101415761013d60209161004e565b0190565b610058565b9061015861015383610125565b610093565b918252565b5f7f436f736d69635369676e61747572650000000000000000000000000000000000910152565b61018e600f610146565b9061019b6020830161015d565b565b6101a5610184565b90565b5f7f4353530000000000000000000000000000000000000000000000000000000000910152565b6101d96003610146565b906101e6602083016101a8565b565b6101f06101cf565b90565b5f1b90565b906102045f19916101f3565b9181191691161790565b90565b90565b90565b61022b6102266102309261020e565b610214565b610211565b90565b90565b9061024b61024661025292610217565b610233565b82546101f8565b9055565b634e487b7160e01b5f52602260045260245ffd5b906001600283049216801561028a575b602083101461028557565b610256565b91607f169161027a565b5f5260205f2090565b601f602091010490565b1b90565b919060086102c69102916102c05f19846102a7565b926102a7565b9181191691161790565b6102e46102df6102e992610211565b610214565b610211565b90565b91906103026102fd61030a936102d0565b610233565b9083546102ab565b9055565b5f90565b6103249161031e61030e565b916102ec565b565b5b818110610332575050565b8061033f5f600193610312565b01610327565b9190601f8111610355575b505050565b61036161038693610294565b90602061036d8461029d565b8301931061038e575b61037f9061029d565b0190610326565b5f8080610350565b915061037f81929050610376565b6103b1600a6103ab835461026a565b83610345565b60147f697066733a2f2f54424400000000000000000000000000000000000000000000019055565b6103e29061039c565b565b6103f86103f36103fd9261020e565b610214565b6100ac565b90565b610409906103e4565b90565b60209181520190565b5f7f5a65726f2d616464726573732077617320676976656e2e000000000000000000910152565b610449601760209261040c565b61045281610415565b0190565b61046b9060208101905f81830391015261043c565b90565b1561047557565b61047d610044565b63eac0d38960e01b81528061049460048201610456565b0390fd5b90565b6104af6104aa6104b492610498565b610214565b610211565b90565b634e487b7160e01b5f52601160045260245ffd5b6104da6104e091939293610211565b92610211565b82039182116104eb57565b6104b7565b5f7f6e65774e46540000000000000000000000000000000000000000000000000000910152565b610524600660209261040c565b61052d816104f0565b0190565b61053a90610211565b9052565b90565b61054a9061053e565b9052565b91604061057f92949361057861056d606083018381035f850152610517565b966020830190610531565b0190610541565b565b60200190565b5190565b6105949061053e565b90565b5f1c90565b6105a590610597565b90565b906105bd6105b86105c49261058b565b61059c565b82546101f8565b9055565b6105e2336105d461019d565b6105dc6101e8565b9161067e565b6105ed5f600e610236565b6105f760106103d9565b61061c8161061561060f61060a5f610400565b6100b7565b916100b7565b141561046e565b6106794261065f61063743610631600161049b565b906104cb565b4091610650610644610044565b9384926020840161054e565b6020820181038252038261006c565b61067161066b82610587565b91610581565b20600d6105a8565b608052565b9061068992916106ad565b565b610694906100b7565b9052565b91906106ab905f6020850194019061068b565b565b916106b791610709565b806106d26106cc6106c75f610400565b6100b7565b916100b7565b146106e2576106e090610943565b565b6107056106ee5f610400565b5f918291631e4fbdf760e01b835260048301610698565b0390fd5b9061071391610715565b565b9061071f91610889565b565b5190565b5f5260205f2090565b9190601f811161073e575b505050565b61074a61076f93610725565b9060206107568461029d565b83019310610777575b6107689061029d565b0190610326565b5f8080610739565b91506107688192905061075f565b1c90565b90610799905f1990600802610785565b191690565b816107a891610789565b906002021790565b906107ba81610721565b9060018060401b038211610878576107dc826107d6855461026a565b8561072e565b602090601f8311600114610810579180916107ff935f92610804575b505061079e565b90555b565b90915001515f806107f8565b601f1983169161081f85610725565b925f5b81811061086057509160029391856001969410610846575b50505002019055610802565b610856910151601f841690610789565b90555f808061083a565b91936020600181928787015181550195019201610822565b610058565b90610887916107b0565b565b9061089761089e925f61087d565b600161087d565b565b60018060a01b031690565b6108b76108bc91610597565b6108a0565b90565b6108c990546108ab565b90565b906108dd60018060a01b03916101f3565b9181191691161790565b6108fb6108f6610900926100ac565b610214565b6100ac565b90565b61090c906108e7565b90565b61091890610903565b90565b90565b9061093361092e61093a9261090f565b61091b565b82546108cc565b9055565b5f0190565b61094d600a6108bf565b61095882600a61091e565b9061098c6109867f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09361090f565b9161090f565b91610995610044565b8061099f8161093e565b0390a356fe60806040526004361015610013575b610f69565b61001d5f356101ec565b806301ffc9a7146101e757806306fdde03146101e2578063081812fc146101dd578063095ea7b3146101d857806318160ddd146101d357806323b872dd146101ce5780632f745c59146101c9578063310495ab146101c457806340c10f19146101bf57806342842e0e146101ba57806346519a18146101b557806347ce07cc146101b05780634f6ccce7146101ab57806355f804b3146101a65780636352211e146101a157806370a082311461019c578063715018a6146101975780637722620d146101925780638da5cb5b1461018d5780638e499bcf1461018857806395d89b4114610183578063a22cb4651461017e578063b88d4fde14610179578063c87b56dd14610174578063cdb0e89e1461016f578063de9d90bc1461016a578063e985e9c514610165578063f0503e80146101605763f2fde38b0361000e57610f36565b610f01565b610e9c565b610e3a565b610df7565b610d7d565b610d46565b610c37565b610bb2565b610b7d565b610b10565b610adb565b610a84565b610a4f565b6109fc565b6109c9565b610994565b61095f565b6108cb565b6107be565b610788565b610753565b61055c565b610528565b6104b9565b610463565b6103d9565b610327565b610278565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b63ffffffff60e01b1690565b61021981610204565b0361022057565b5f80fd5b9050359061023182610210565b565b9060208282031261024c57610249915f01610224565b90565b6101fc565b151590565b61025f90610251565b9052565b9190610276905f60208501940190610256565b565b346102a8576102a461029361028e366004610233565b610f71565b61029b6101f2565b91829182610263565b0390f35b6101f8565b5f9103126102b757565b6101fc565b5190565b60209181520190565b90825f9392825e0152565b601f801991011690565b6102fd61030660209361030b936102f4816102bc565b938480936102c0565b958691016102c9565b6102d4565b0190565b6103249160208201915f8184039101526102de565b90565b34610357576103373660046102ad565b610353610342610fc2565b61034a6101f2565b9182918261030f565b0390f35b6101f8565b90565b6103688161035c565b0361036f57565b5f80fd5b905035906103808261035f565b565b9060208282031261039b57610398915f01610373565b90565b6101fc565b60018060a01b031690565b6103b4906103a0565b90565b6103c0906103ab565b9052565b91906103d7905f602085019401906103b7565b565b34610409576104056103f46103ef366004610382565b610fdb565b6103fc6101f2565b918291826103c4565b0390f35b6101f8565b610417816103ab565b0361041e57565b5f80fd5b9050359061042f8261040e565b565b9190604083820312610459578061044d610456925f8601610422565b93602001610373565b90565b6101fc565b5f0190565b346104925761047c610476366004610431565b90610ffa565b6104846101f2565b8061048e8161045e565b0390f35b6101f8565b6104a09061035c565b9052565b91906104b7905f60208501940190610497565b565b346104e9576104c93660046102ad565b6104e56104d4611018565b6104dc6101f2565b918291826104a4565b0390f35b6101f8565b909160608284031261052357610520610509845f8501610422565b936105178160208601610422565b93604001610373565b90565b6101fc565b346105575761054161053b3660046104ee565b9161108b565b6105496101f2565b806105538161045e565b0390f35b6101f8565b3461058d57610589610578610572366004610431565b906111cf565b6105806101f2565b918291826104a4565b0390f35b6101f8565b90565b6105a96105a46105ae9261035c565b610592565b61035c565b90565b906105bb90610595565b5f5260205260405f2090565b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52602260045260245ffd5b906001600283049216801561060e575b602083101461060957565b6105da565b91607f16916105fe565b60209181520190565b5f5260205f2090565b905f929180549061064461063d836105ee565b8094610618565b916001811690815f1461069b575060011461065f575b505050565b61066c9192939450610621565b915f925b81841061068357505001905f808061065a565b60018160209295939554848601520191019290610670565b92949550505060ff19168252151560200201905f808061065a565b906106c09161062a565b90565b634e487b7160e01b5f52604160045260245ffd5b906106e1906102d4565b810190811067ffffffffffffffff8211176106fb57604052565b6106c3565b90610720610719926107106101f2565b938480926106b6565b03836106d7565b565b905f106107355761073290610700565b90565b6105c7565b6107509061074b600c915f926105b1565b610722565b90565b346107835761077f61076e610769366004610382565b61073a565b6107766101f2565b9182918261030f565b0390f35b6101f8565b346107b9576107b56107a461079e366004610431565b906114de565b6107ac6101f2565b918291826104a4565b0390f35b6101f8565b346107ed576107d76107d13660046104ee565b916116a7565b6107df6101f2565b806107e98161045e565b0390f35b6101f8565b5f80fd5b5f80fd5b9061080d6108066101f2565b92836106d7565b565b67ffffffffffffffff811161082d576108296020916102d4565b0190565b6106c3565b90825f939282370152565b9092919261085261084d8261080f565b6107fa565b9381855260208501908284011161086e5761086c92610832565b565b6107f6565b9080601f830112156108915781602061088e9335910161083d565b90565b6107f2565b906020828203126108c6575f82013567ffffffffffffffff81116108c1576108be9201610873565b90565b610200565b6101fc565b346108f9576108e36108de366004610896565b6118f7565b6108eb6101f2565b806108f58161045e565b0390f35b6101f8565b1c90565b90565b61091590600861091a93026108fe565b610902565b90565b906109289154610905565b90565b610937600d5f9061091d565b90565b90565b6109469061093a565b9052565b919061095d905f6020850194019061093d565b565b3461098f5761096f3660046102ad565b61098b61097a61092b565b6109826101f2565b9182918261094a565b0390f35b6101f8565b346109c4576109c06109af6109aa366004610382565b611947565b6109b76101f2565b918291826104a4565b0390f35b6101f8565b346109f7576109e16109dc366004610896565b611a07565b6109e96101f2565b806109f38161045e565b0390f35b6101f8565b34610a2c57610a28610a17610a12366004610382565b611a12565b610a1f6101f2565b918291826103c4565b0390f35b6101f8565b90602082820312610a4a57610a47915f01610422565b90565b6101fc565b34610a7f57610a7b610a6a610a65366004610a31565b611a3d565b610a726101f2565b918291826104a4565b0390f35b6101f8565b34610ab257610a943660046102ad565b610a9c611ac8565b610aa46101f2565b80610aae8161045e565b0390f35b6101f8565b7f000000000000000000000000000000000000000000000000000000000000000090565b34610b0b57610aeb3660046102ad565b610b07610af6610ab7565b610afe6101f2565b918291826103c4565b0390f35b6101f8565b34610b4057610b203660046102ad565b610b3c610b2b611afe565b610b336101f2565b918291826103c4565b0390f35b6101f8565b90565b610b58906008610b5d93026108fe565b610b45565b90565b90610b6b9154610b48565b90565b610b7a600e5f90610b60565b90565b34610bad57610b8d3660046102ad565b610ba9610b98610b6e565b610ba06101f2565b918291826104a4565b0390f35b6101f8565b34610be257610bc23660046102ad565b610bde610bcd611b14565b610bd56101f2565b9182918261030f565b0390f35b6101f8565b610bf081610251565b03610bf757565b5f80fd5b90503590610c0882610be7565b565b9190604083820312610c325780610c26610c2f925f8601610422565b93602001610bfb565b90565b6101fc565b34610c6657610c50610c4a366004610c0a565b90611b2a565b610c586101f2565b80610c628161045e565b0390f35b6101f8565b67ffffffffffffffff8111610c8957610c856020916102d4565b0190565b6106c3565b90929192610ca3610c9e82610c6b565b6107fa565b93818552602085019082840111610cbf57610cbd92610832565b565b6107f6565b9080601f83011215610ce257816020610cdf93359101610c8e565b90565b6107f2565b90608082820312610d4157610cfe815f8401610422565b92610d0c8260208501610422565b92610d1a8360408301610373565b92606082013567ffffffffffffffff8111610d3c57610d399201610cc4565b90565b610200565b6101fc565b34610d7857610d62610d59366004610ce7565b92919091611b40565b610d6a6101f2565b80610d748161045e565b0390f35b6101f8565b34610dad57610da9610d98610d93366004610382565b611bfa565b610da06101f2565b9182918261030f565b0390f35b6101f8565b919091604081840312610df257610dcb835f8301610373565b92602082013567ffffffffffffffff8111610ded57610dea9201610873565b90565b610200565b6101fc565b34610e2657610e10610e0a366004610db2565b90611dd3565b610e186101f2565b80610e228161045e565b0390f35b6101f8565b610e3760105f90610722565b90565b34610e6a57610e4a3660046102ad565b610e66610e55610e2b565b610e5d6101f2565b9182918261030f565b0390f35b6101f8565b9190604083820312610e975780610e8b610e94925f8601610422565b93602001610422565b90565b6101fc565b34610ecd57610ec9610eb8610eb2366004610e6f565b90611ee4565b610ec06101f2565b91829182610263565b0390f35b6101f8565b90610edc90610595565b5f5260205260405f2090565b610efe90610ef9600b915f92610ed2565b61091d565b90565b34610f3157610f2d610f1c610f17366004610382565b610ee8565b610f246101f2565b9182918261094a565b0390f35b6101f8565b34610f6457610f4e610f49366004610a31565b611f71565b610f566101f2565b80610f608161045e565b0390f35b6101f8565b5f80fd5b5f90565b610f79610f6d565b5080610f94610f8e63780e9d6360e01b610204565b91610204565b14908115610fa1575b5090565b610fab9150611f7c565b5f610f9d565b606090565b610fbf90610700565b90565b610fca610fb1565b50610fd45f610fb6565b90565b5f90565b610ff790610fe7610fd7565b50610ff181611fe4565b50612050565b90565b9061100e919061100861206f565b9161207c565b565b5f90565b5490565b611020611010565b5061102b6008611014565b90565b90565b61104561104061104a9261102e565b610592565b6103a0565b90565b61105690611031565b90565b604090611082611089949695939661107860608401985f8501906103b7565b6020830190610497565b01906103b7565b565b9190806110a86110a261109d5f61104d565b6103ab565b916103ab565b146110ff576110c090826110ba61206f565b9161208c565b91826110d46110ce836103ab565b916103ab565b036110de57505050565b6110fb9091925f9384936364283d7b60e01b855260048501611059565b0390fd5b61112261110b5f61104d565b5f918291633250574960e11b8352600483016103c4565b0390fd5b91602061114792949361114060408201965f8301906103b7565b0190610497565b565b61115d611158611162926103a0565b610592565b6103a0565b90565b61116e90611149565b90565b61117a90611165565b90565b9061118790611171565b5f5260205260405f2090565b9061119d90610595565b5f5260205260405f2090565b5f1c90565b6111ba6111bf916111a9565b610b45565b90565b6111cc90546111ae565b90565b6111d7611010565b50816111f36111ed6111e884611a3d565b61035c565b9161035c565b1015611218576112159161120b61121092600661117d565b611193565b6111c2565b90565b6112325f92839263295f44f760e21b845260048401611126565b0390fd5b5f7f5a65726f2d616464726573732077617320676976656e2e000000000000000000910152565b61126a60176020926102c0565b61127381611236565b0190565b61128c9060208101905f81830391015261125d565b90565b1561129657565b61129e6101f2565b63eac0d38960e01b8152806112b560048201611277565b0390fd5b60207f742063616e206d696e742e000000000000000000000000000000000000000000917f4f6e6c792074686520436f736d696347616d6550726f787920636f6e747261635f8201520152565b611313602b6040926102c0565b61131c816112b9565b0190565b919061134390602061133b604086018681035f880152611306565b9401906103b7565b565b1561134d5750565b61136f906113596101f2565b91829163173fda8d60e21b835260048301611320565b0390fd5b90565b61138a61138561138f92611373565b610592565b61035c565b90565b634e487b7160e01b5f52601160045260245ffd5b6113b56113bb9193929361035c565b9261035c565b82018092116113c657565b611392565b5f1b90565b906113dc5f19916113cb565b9181191691161790565b90565b906113fe6113f961140592610595565b6113e6565b82546113d0565b9055565b61141561141a916111a9565b610902565b90565b6114279054611409565b90565b61143961143f9193929361035c565b9261035c565b820391821161144a57565b611392565b9095949261149a946114896114939261147f60809661147560a088019c5f89019061093d565b6020870190610497565b604085019061093d565b6060830190610497565b01906103b7565b565b60200190565b5190565b6114af9061093a565b90565b6114bb906111a9565b90565b906114d36114ce6114da926114a6565b6114b2565b82546113d0565b9055565b6114e6611010565b5061150c816115056114ff6114fa5f61104d565b6103ab565b916103ab565b141561128f565b61155161151761206f565b6115496115437f00000000000000000000000000000000000000000000000000000000000000006103ab565b916103ab565b143390611345565b61155b600e6111c2565b9161158261157b61156c6001611376565b611576600e6111c2565b6113a6565b600e6113e9565b6115ec61158f600d61141d565b6115d242916115c36115ab436115a56001611376565b9061142a565b408888916115b76101f2565b9687956020870161144f565b602082018103825203826106d7565b6115e46115de826114a2565b9161149c565b20600d6114be565b61160a6115f9600d61141d565b611605600b8690610ed2565b6114be565b611615828490612160565b8291611621600d61141d565b9261167361166161165b6116557fc646da88dc2b2526461a0ebb4326e2418ec0bea89496b632b7c9ee42fbfe1d4d94610595565b94611171565b94610595565b9461166a6101f2565b9182918261094a565b0390a490565b9061168b6116868361080f565b6107fa565b918252565b6116995f611679565b90565b6116a4611690565b90565b916116bb92916116b561169c565b92611b40565b565b6116ce906116c9612204565b6118b1565b565b601f602091010490565b1b90565b919060086116f99102916116f35f19846116da565b926116da565b9181191691161790565b919061171961171461172193610595565b6113e6565b9083546116de565b9055565b61173791611731611010565b91611703565b565b5b818110611745575050565b806117525f600193611725565b0161173a565b9190601f8111611768575b505050565b61177461179993610621565b906020611780846116d0565b830193106117a1575b611792906116d0565b0190611739565b5f8080611763565b915061179281929050611789565b906117bf905f19906008026108fe565b191690565b816117ce916117af565b906002021790565b906117e0816102bc565b9067ffffffffffffffff82116118a057611804826117fe85546105ee565b85611758565b602090601f831160011461183857918091611827935f9261182c575b50506117c4565b90555b565b90915001515f80611820565b601f1983169161184785610621565b925f5b8181106118885750916002939185600196941061186e575b5050500201905561182a565b61187e910151601f8416906117af565b90555f8080611862565b9193602060018192878701518155019501920161184a565b6106c3565b906118af916117d6565b565b6118bc8160106118a5565b6118f27f0119741ee0f95fab26124262a82c3c0e9e1c7ff4bb33c6fba5f3b11c9b6d0bad916118e96101f2565b9182918261030f565b0390a1565b611900906116bd565b565b634e487b7160e01b5f52603260045260245ffd5b5f5260205f2090565b61192881611014565b8210156119425761193a600191611916565b910201905f90565b611902565b61194f611010565b508061196a61196461195f611018565b61035c565b9161035c565b10156119875761197e61198491600861191f565b90610b60565b90565b6119905f61104d565b6119aa5f92839263295f44f760e21b845260048401611126565b0390fd5b6119bf906119ba612204565b6119c1565b565b6119cc81600f6118a5565b611a027f2fc013f885e8a815b9d697da28bc143b4dced47528c41b46e2b35fd0f4be718c916119f96101f2565b9182918261030f565b0390a1565b611a10906119ae565b565b611a2490611a1e610fd7565b50611fe4565b90565b90611a3190611171565b5f5260205260405f2090565b611a45611010565b5080611a61611a5b611a565f61104d565b6103ab565b916103ab565b14611a7c57611a74611a79916003611a27565b6111c2565b90565b611a9f611a885f61104d565b5f9182916322718ad960e21b8352600483016103c4565b0390fd5b611aab612204565b611ab3611ab5565b565b611ac6611ac15f61104d565b612290565b565b611ad0611aa3565b565b60018060a01b031690565b611ae9611aee916111a9565b611ad2565b90565b611afb9054611add565b90565b611b06610fd7565b50611b11600a611af1565b90565b611b1c610fb1565b50611b276001610fb6565b90565b611b3e91611b3661206f565b919091612336565b565b91611b5c939192611b538185849161108b565b92909192612500565b565b90565b611b75611b70611b7a9261102e565b610592565b61035c565b90565b611b85611690565b90565b905090565b611bb2611ba992602092611ba0816102bc565b94858093611b88565b938491016102c9565b0190565b611bc490611bca9392611b8d565b90611b8d565b90565b611bec9291611bf891611bde6101f2565b948592602084019283611bb6565b908103825203836106d7565b565b611c02610fb1565b50611c0c81611fe4565b50611c1561265b565b90611c27611c2283611b5e565b6114a2565b611c39611c335f611b61565b9161035c565b115f14611c5757611c4d611c53929161270f565b90611bcd565b5b90565b5050611c61611b7d565b611c54565b60207f206e6f7220617070726f7665642e000000000000000000000000000000000000917f736574546f6b656e4e616d652063616c6c6572206973206e6f74206f776e65725f8201520152565b611cc0602e6040926102c0565b611cc981611c66565b0190565b9190611cf0906020611ce8604086018681035f880152611cb3565b940190610497565b565b15611cfa5750565b611d1c90611d066101f2565b918291632b03cbb360e21b835260048301611ccd565b0390fd5b90565b611d37611d32611d3c92611d20565b610592565b61035c565b90565b5f7f546f6b656e206e616d6520697320746f6f206c6f6e672e000000000000000000910152565b611d7360176020926102c0565b611d7c81611d3f565b0190565b9190611da3906020611d9b604086018681035f880152611d66565b940190610497565b565b15611dad5750565b611dcf90611db96101f2565b918291635e8b1f5160e11b835260048301611d80565b0390fd5b611df8611df1611de2836127b8565b611dea61206f565b84916127d7565b8290611cf2565b611e38611e0c611e0784611b5e565b6114a2565b611e1f611e196020611d23565b9161035c565b1115611e32611e2d85611b5e565b6114a2565b90611da5565b611e4d82611e48600c84906105b1565b6118a5565b611e8c611e7a7f8ad5e159ff95649c8a9f323ac5a457e741897cf44ce07dfce0e98b84ef9d5f1292610595565b92611e836101f2565b9182918261030f565b0390a2565b90611e9b90611171565b5f5260205260405f2090565b90611eb190611171565b5f5260205260405f2090565b60ff1690565b611ecf611ed4916111a9565b611ebd565b90565b611ee19054611ec3565b90565b611f0991611eff611f0492611ef7610f6d565b506005611e91565b611ea7565b611ed7565b90565b611f1d90611f18612204565b611f1f565b565b80611f3a611f34611f2f5f61104d565b6103ab565b916103ab565b14611f4a57611f4890612290565b565b611f6d611f565f61104d565b5f918291631e4fbdf760e01b8352600483016103c4565b0390fd5b611f7a90611f0c565b565b611f84610f6d565b5080611f9f611f996380ac58cd60e01b610204565b91610204565b148015611fc3575b908115611fb3575b5090565b611fbd9150612877565b5f611faf565b5080611fde611fd8635b5e139f60e01b610204565b91610204565b14611fa7565b611fec610fd7565b50611ff6816127b8565b908161201261200c6120075f61104d565b6103ab565b916103ab565b1461201b575090565b612036905f918291637e27328960e01b8352600483016104a4565b0390fd5b9061204490610595565b5f5260205260405f2090565b61206761206c9161205f610fd7565b50600461203a565b611af1565b90565b612077610fd7565b503390565b9161208a929160019261289d565b565b90916120a59061209a610fd7565b5082908490916129f5565b91826120c16120bb6120b65f61104d565b6103ab565b916103ab565b145f14612132576120d181612ca5565b5b816120ed6120e76120e25f61104d565b6103ab565b916103ab565b145f14612102576120fe9150612d6d565b5b90565b8261211561210f846103ab565b916103ab565b03612122575b50506120ff565b61212b91612cd8565b5f8061211b565b8261214561213f846103ab565b916103ab565b03612150575b6120d2565b61215b838290612b76565b61214b565b908161217c6121766121715f61104d565b6103ab565b916103ab565b146121dd57612195919061218f5f61104d565b9161208c565b6121af6121a96121a45f61104d565b6103ab565b916103ab565b036121b657565b6121d96121c25f61104d565b5f9182916339e3563760e11b8352600483016103c4565b0390fd5b6122006121e95f61104d565b5f918291633250574960e11b8352600483016103c4565b0390fd5b61220c611afe565b61222561221f61221a61206f565b6103ab565b916103ab565b0361222c57565b61224e61223761206f565b5f91829163118cdaa760e01b8352600483016103c4565b0390fd5b9061226360018060a01b03916113cb565b9181191691161790565b90565b9061228561228061228c92611171565b61226d565b8254612252565b9055565b61229a600a611af1565b6122a582600a612270565b906122d96122d37f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e093611171565b91611171565b916122e26101f2565b806122ec8161045e565b0390a3565b906122fd60ff916113cb565b9181191691161790565b61231090610251565b90565b90565b9061232b61232661233292612307565b612313565b82546122f1565b9055565b9190918261235461234e6123495f61104d565b6103ab565b916103ab565b146123c8576123788261237361236c60058590611e91565b8690611ea7565b612316565b9190916123c36123b16123ab7f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c3193611171565b93611171565b936123ba6101f2565b91829182610263565b0390a3565b6123e3835f918291630b61174360e31b8352600483016103c4565b0390fd5b6123f090611149565b90565b6123fc906123e7565b90565b61240890611165565b90565b60e01b90565b9050519061241e82610210565b565b9060208282031261243957612436915f01612411565b90565b6101fc565b60209181520190565b61246661246f6020936124749361245d816114a2565b9384809361243e565b958691016102c9565b6102d4565b0190565b90926124ab906124a16124b8969461249760808601975f8701906103b7565b60208501906103b7565b6040830190610497565b6060818403910152612447565b90565b906124cd6124c883610c6b565b6107fa565b918252565b606090565b3d5f146124f2576124e73d6124bb565b903d5f602084013e5b565b6124fa6124d2565b906124f0565b929092833b6125176125115f611b61565b9161035c565b11612523575b50505050565b6020916125635f61253b612536886123f3565b6123ff565b9261256e63150b7a029161254d61206f565b96986125576101f2565b998a988997889661240b565b865260048601612478565b03925af180915f9261262b575b50155f146125e85750600161259557505b5f80808061251d565b61259d6124d7565b906125a7826114a2565b6125b96125b35f611b61565b9161035c565b145f146125df576125db905f918291633250574960e11b8352600483016103c4565b0390fd5b50805190602001fd5b6126016125fb630a85bd0160e11b610204565b91610204565b0361260c575061258c565b612627905f918291633250574960e11b8352600483016103c4565b0390fd5b61264d91925060203d8111612654575b61264581836106d7565b810190612420565b905f61257b565b503d61263b565b612663610fb1565b5061266e600f610fb6565b90565b9061267c910161035c565b90565b369037565b906126a961269183611679565b9260208061269f869361080f565b920191039061267f565b565b60016126b7910361035c565b90565b90565b6126d16126cc6126d6926126ba565b610592565b61035c565b90565b634e487b7160e01b5f52601260045260245ffd5b6126f96126ff9161035c565b9161035c565b90811561270a570490565b6126d9565b612717610fb1565b5061273461272482612f59565b61272e6001611376565b90612671565b9061273e82612684565b91612747611010565b5060200182015b6001156127b15761276161278d916126ab565b916f181899199a1a9b1b9c1cb0b131b232b360811b600a82061a8353612787600a6126bd565b906126ed565b806127a061279a5f611b61565b9161035c565b146127ab579061274e565b50505b90565b50506127ae565b6127cf6127d4916127c7610fd7565b50600261203a565b611af1565b90565b91906127e1610f6d565b50806127fd6127f76127f25f61104d565b6103ab565b916103ab565b1415928361280c575b50505090565b809192935061282361281d846103ab565b916103ab565b14908115612865575b5091821561283f575b50505f8080612806565b61285d91925061285161285791612050565b926103ab565b916103ab565b145f80612835565b61287191508290611ee4565b5f61282c565b61287f610f6d565b506128996128936301ffc9a760e01b610204565b91610204565b1490565b9190928080156129c4575b6128c6575b5050906128bf6128c49291600461203a565b612270565b565b6128cf84611fe4565b91806128eb6128e56128e05f61104d565b6103ab565b916103ab565b1415806129a9575b8061298f575b6129705750916128bf916128c49493612915575b5091926128ad565b81849061295461294e6129487f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92595611171565b92611171565b92610595565b9261295d6101f2565b806129678161045e565b0390a45f61290d565b61298b905f91829163a9fbf51f60e01b8352600483016103c4565b0390fd5b506129a461299e848390611ee4565b15610251565b6128f9565b50826129bd6129b7836103ab565b916103ab565b14156128f3565b50816129e06129da6129d55f61104d565b6103ab565b916103ab565b14156128a8565b906129f2910361035c565b90565b906129fe610fd7565b50612a08816127b8565b9280612a24612a1e612a195f61104d565b6103ab565b916103ab565b03612b63575b5082612a46612a40612a3b5f61104d565b6103ab565b916103ab565b03612b0f575b81612a67612a61612a5c5f61104d565b6103ab565b916103ab565b03612ad9575b612a8282612a7d6002849061203a565b612270565b8291612ac0612aba612ab47fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef95611171565b92611171565b92610595565b92612ac96101f2565b80612ad38161045e565b0390a490565b612b0a612ae66001611376565b612b04612af560038690611a27565b91612aff836111c2565b612671565b906113e9565b612a6d565b612b2d612b1b5f61104d565b82612b255f61104d565b905f9261289d565b612b5e612b3a6001611376565b612b58612b4960038790611a27565b91612b53836111c2565b6129e7565b906113e9565b612a4c565b612b7090849083916131ba565b5f612a2a565b612bd9612bde92612bd45f93612bcd85612bc8612b9284611a3d565b95612ba7612ba260078390611193565b6111c2565b80612bba612bb48a61035c565b9161035c565b03612be0575b506007611193565b611725565b600661117d565b611193565b611725565b565b612c3290612c2d612c05612c00612bf960068b9061117d565b8c90611193565b6111c2565b91612c2583612c20612c1960068d9061117d565b8490611193565b6113e9565b916007611193565b6113e9565b5f612bc0565b90565b5f5260205f2090565b5490565b612c5181612c44565b821015612c6b57612c63600191612c3b565b910201905f90565b611902565b9081549168010000000000000000831015612ca05782612c98916001612c9e95018155612c48565b90611703565b565b6106c3565b612cd690612cc7612cb66008611014565b612cc260098490611193565b6113e9565b612cd16008612c38565b612c70565b565b90612d23612d2892612d1b612cff612cef83611a3d565b612cf96001611376565b9061142a565b91612d16612d0f8692600661117d565b8490611193565b6113e9565b916007611193565b6113e9565b565b634e487b7160e01b5f52603160045260245ffd5b612d4781612c44565b8015612d68576001900390612d65612d5f8383612c48565b90611725565b55565b612d2a565b5f612deb612df092612de4612d95612d856008611014565b612d8f6001611376565b9061142a565b612ddf612dc0612dba612db2612dad60098890611193565b6111c2565b93600861191f565b90610b60565b91612dd783612dd16008849061191f565b90611703565b916009611193565b6113e9565b6009611193565b611725565b612e02612dfd6008612c38565b612d3e565b565b90565b612e1b612e16612e2092612e04565b610592565b61035c565b90565b90565b612e3a612e35612e3f92612e23565b610592565b61035c565b90565b90565b612e59612e54612e5e92612e42565b610592565b61035c565b90565b90565b612e78612e73612e7d92612e61565b610592565b61035c565b90565b90565b612e97612e92612e9c92612e80565b610592565b61035c565b90565b90565b612eb6612eb1612ebb92612e9f565b610592565b61035c565b90565b90565b612ed5612ed0612eda92612ebe565b610592565b61035c565b90565b90565b612ef4612eef612ef992612edd565b610592565b61035c565b90565b90565b612f13612f0e612f1892612efc565b610592565b61035c565b90565b90565b612f32612f2d612f3792612f1b565b610592565b61035c565b90565b90565b612f51612f4c612f5692612f3a565b610592565b61035c565b90565b612f61611010565b50612f6b5f611b61565b9080612f9a612f947a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000612e07565b9161035c565b1015613172575b80612fc2612fbc6d04ee2d6d415b85acef8100000000612e45565b9161035c565b1015613137575b80612fe3612fdd662386f26fc10000612e64565b9161035c565b1015613103575b80613001612ffb6305f5e100612ea2565b9161035c565b10156130d2575b8061301d613017612710612ee0565b9161035c565b10156130a3575b806130386130326064612f1e565b9161035c565b1015613075575b61305261304c600a6126bd565b9161035c565b101561305c575b90565b6130709061306a6001611376565b90612671565b613059565b61308c61309d916130866064612f1e565b906126ed565b916130976002612f3d565b90612671565b9061303f565b6130bb6130cc916130b5612710612ee0565b906126ed565b916130c66004612eff565b90612671565b90613024565b6130ec6130fd916130e66305f5e100612ea2565b906126ed565b916130f76008612ec1565b90612671565b90613008565b6131206131319161311a662386f26fc10000612e64565b906126ed565b9161312b6010612e83565b90612671565b90612fea565b61315b61316c916131556d04ee2d6d415b85acef8100000000612e45565b906126ed565b916131666020611d23565b90612671565b90612fc9565b6131a36131b49161319d7a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000612e07565b906126ed565b916131ae6040612e26565b90612671565b90612fa1565b6131cf6131c9828486916127d7565b15610251565b6131d857505050565b6131f26131ec6131e75f61104d565b6103ab565b916103ab565b145f1461321857613214825f918291637e27328960e01b8352600483016104a4565b0390fd5b6132325f92839263177e802f60e01b845260048401611126565b0390fdfea264697066735822122006f95c46acf525fe6b7aee9b295feddcabfd5d114613cf7a7df747f2778061e664736f6c634300081a0033",
}

// CosmicSignatureABI is the input ABI used to generate the binding from.
// Deprecated: Use CosmicSignatureMetaData.ABI instead.
var CosmicSignatureABI = CosmicSignatureMetaData.ABI

// CosmicSignatureBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use CosmicSignatureMetaData.Bin instead.
var CosmicSignatureBin = CosmicSignatureMetaData.Bin

// DeployCosmicSignature deploys a new Ethereum contract, binding an instance of CosmicSignature to it.
func DeployCosmicSignature(auth *bind.TransactOpts, backend bind.ContractBackend, _cosmicGameProxyContract common.Address) (common.Address, *types.Transaction, *CosmicSignature, error) {
	parsed, err := CosmicSignatureMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(CosmicSignatureBin), backend, _cosmicGameProxyContract)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &CosmicSignature{CosmicSignatureCaller: CosmicSignatureCaller{contract: contract}, CosmicSignatureTransactor: CosmicSignatureTransactor{contract: contract}, CosmicSignatureFilterer: CosmicSignatureFilterer{contract: contract}}, nil
}

// CosmicSignature is an auto generated Go binding around an Ethereum contract.
type CosmicSignature struct {
	CosmicSignatureCaller     // Read-only binding to the contract
	CosmicSignatureTransactor // Write-only binding to the contract
	CosmicSignatureFilterer   // Log filterer for contract events
}

// CosmicSignatureCaller is an auto generated read-only Go binding around an Ethereum contract.
type CosmicSignatureCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CosmicSignatureTransactor is an auto generated write-only Go binding around an Ethereum contract.
type CosmicSignatureTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CosmicSignatureFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type CosmicSignatureFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CosmicSignatureSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type CosmicSignatureSession struct {
	Contract     *CosmicSignature  // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// CosmicSignatureCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type CosmicSignatureCallerSession struct {
	Contract *CosmicSignatureCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts          // Call options to use throughout this session
}

// CosmicSignatureTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type CosmicSignatureTransactorSession struct {
	Contract     *CosmicSignatureTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts          // Transaction auth options to use throughout this session
}

// CosmicSignatureRaw is an auto generated low-level Go binding around an Ethereum contract.
type CosmicSignatureRaw struct {
	Contract *CosmicSignature // Generic contract binding to access the raw methods on
}

// CosmicSignatureCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type CosmicSignatureCallerRaw struct {
	Contract *CosmicSignatureCaller // Generic read-only contract binding to access the raw methods on
}

// CosmicSignatureTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type CosmicSignatureTransactorRaw struct {
	Contract *CosmicSignatureTransactor // Generic write-only contract binding to access the raw methods on
}

// NewCosmicSignature creates a new instance of CosmicSignature, bound to a specific deployed contract.
func NewCosmicSignature(address common.Address, backend bind.ContractBackend) (*CosmicSignature, error) {
	contract, err := bindCosmicSignature(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &CosmicSignature{CosmicSignatureCaller: CosmicSignatureCaller{contract: contract}, CosmicSignatureTransactor: CosmicSignatureTransactor{contract: contract}, CosmicSignatureFilterer: CosmicSignatureFilterer{contract: contract}}, nil
}

// NewCosmicSignatureCaller creates a new read-only instance of CosmicSignature, bound to a specific deployed contract.
func NewCosmicSignatureCaller(address common.Address, caller bind.ContractCaller) (*CosmicSignatureCaller, error) {
	contract, err := bindCosmicSignature(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureCaller{contract: contract}, nil
}

// NewCosmicSignatureTransactor creates a new write-only instance of CosmicSignature, bound to a specific deployed contract.
func NewCosmicSignatureTransactor(address common.Address, transactor bind.ContractTransactor) (*CosmicSignatureTransactor, error) {
	contract, err := bindCosmicSignature(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureTransactor{contract: contract}, nil
}

// NewCosmicSignatureFilterer creates a new log filterer instance of CosmicSignature, bound to a specific deployed contract.
func NewCosmicSignatureFilterer(address common.Address, filterer bind.ContractFilterer) (*CosmicSignatureFilterer, error) {
	contract, err := bindCosmicSignature(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureFilterer{contract: contract}, nil
}

// bindCosmicSignature binds a generic wrapper to an already deployed contract.
func bindCosmicSignature(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := CosmicSignatureMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_CosmicSignature *CosmicSignatureRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _CosmicSignature.Contract.CosmicSignatureCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_CosmicSignature *CosmicSignatureRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CosmicSignature.Contract.CosmicSignatureTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_CosmicSignature *CosmicSignatureRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _CosmicSignature.Contract.CosmicSignatureTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_CosmicSignature *CosmicSignatureCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _CosmicSignature.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_CosmicSignature *CosmicSignatureTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CosmicSignature.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_CosmicSignature *CosmicSignatureTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _CosmicSignature.Contract.contract.Transact(opts, method, params...)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256)
func (_CosmicSignature *CosmicSignatureCaller) BalanceOf(opts *bind.CallOpts, owner common.Address) (*big.Int, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "balanceOf", owner)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256)
func (_CosmicSignature *CosmicSignatureSession) BalanceOf(owner common.Address) (*big.Int, error) {
	return _CosmicSignature.Contract.BalanceOf(&_CosmicSignature.CallOpts, owner)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256)
func (_CosmicSignature *CosmicSignatureCallerSession) BalanceOf(owner common.Address) (*big.Int, error) {
	return _CosmicSignature.Contract.BalanceOf(&_CosmicSignature.CallOpts, owner)
}

// CosmicGameProxyContract is a free data retrieval call binding the contract method 0x7722620d.
//
// Solidity: function cosmicGameProxyContract() view returns(address)
func (_CosmicSignature *CosmicSignatureCaller) CosmicGameProxyContract(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "cosmicGameProxyContract")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// CosmicGameProxyContract is a free data retrieval call binding the contract method 0x7722620d.
//
// Solidity: function cosmicGameProxyContract() view returns(address)
func (_CosmicSignature *CosmicSignatureSession) CosmicGameProxyContract() (common.Address, error) {
	return _CosmicSignature.Contract.CosmicGameProxyContract(&_CosmicSignature.CallOpts)
}

// CosmicGameProxyContract is a free data retrieval call binding the contract method 0x7722620d.
//
// Solidity: function cosmicGameProxyContract() view returns(address)
func (_CosmicSignature *CosmicSignatureCallerSession) CosmicGameProxyContract() (common.Address, error) {
	return _CosmicSignature.Contract.CosmicGameProxyContract(&_CosmicSignature.CallOpts)
}

// Entropy is a free data retrieval call binding the contract method 0x47ce07cc.
//
// Solidity: function entropy() view returns(bytes32)
func (_CosmicSignature *CosmicSignatureCaller) Entropy(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "entropy")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// Entropy is a free data retrieval call binding the contract method 0x47ce07cc.
//
// Solidity: function entropy() view returns(bytes32)
func (_CosmicSignature *CosmicSignatureSession) Entropy() ([32]byte, error) {
	return _CosmicSignature.Contract.Entropy(&_CosmicSignature.CallOpts)
}

// Entropy is a free data retrieval call binding the contract method 0x47ce07cc.
//
// Solidity: function entropy() view returns(bytes32)
func (_CosmicSignature *CosmicSignatureCallerSession) Entropy() ([32]byte, error) {
	return _CosmicSignature.Contract.Entropy(&_CosmicSignature.CallOpts)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address)
func (_CosmicSignature *CosmicSignatureCaller) GetApproved(opts *bind.CallOpts, tokenId *big.Int) (common.Address, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "getApproved", tokenId)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address)
func (_CosmicSignature *CosmicSignatureSession) GetApproved(tokenId *big.Int) (common.Address, error) {
	return _CosmicSignature.Contract.GetApproved(&_CosmicSignature.CallOpts, tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address)
func (_CosmicSignature *CosmicSignatureCallerSession) GetApproved(tokenId *big.Int) (common.Address, error) {
	return _CosmicSignature.Contract.GetApproved(&_CosmicSignature.CallOpts, tokenId)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_CosmicSignature *CosmicSignatureCaller) IsApprovedForAll(opts *bind.CallOpts, owner common.Address, operator common.Address) (bool, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "isApprovedForAll", owner, operator)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_CosmicSignature *CosmicSignatureSession) IsApprovedForAll(owner common.Address, operator common.Address) (bool, error) {
	return _CosmicSignature.Contract.IsApprovedForAll(&_CosmicSignature.CallOpts, owner, operator)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_CosmicSignature *CosmicSignatureCallerSession) IsApprovedForAll(owner common.Address, operator common.Address) (bool, error) {
	return _CosmicSignature.Contract.IsApprovedForAll(&_CosmicSignature.CallOpts, owner, operator)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_CosmicSignature *CosmicSignatureCaller) Name(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "name")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_CosmicSignature *CosmicSignatureSession) Name() (string, error) {
	return _CosmicSignature.Contract.Name(&_CosmicSignature.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_CosmicSignature *CosmicSignatureCallerSession) Name() (string, error) {
	return _CosmicSignature.Contract.Name(&_CosmicSignature.CallOpts)
}

// NumTokens is a free data retrieval call binding the contract method 0x8e499bcf.
//
// Solidity: function numTokens() view returns(uint256)
func (_CosmicSignature *CosmicSignatureCaller) NumTokens(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "numTokens")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumTokens is a free data retrieval call binding the contract method 0x8e499bcf.
//
// Solidity: function numTokens() view returns(uint256)
func (_CosmicSignature *CosmicSignatureSession) NumTokens() (*big.Int, error) {
	return _CosmicSignature.Contract.NumTokens(&_CosmicSignature.CallOpts)
}

// NumTokens is a free data retrieval call binding the contract method 0x8e499bcf.
//
// Solidity: function numTokens() view returns(uint256)
func (_CosmicSignature *CosmicSignatureCallerSession) NumTokens() (*big.Int, error) {
	return _CosmicSignature.Contract.NumTokens(&_CosmicSignature.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_CosmicSignature *CosmicSignatureCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_CosmicSignature *CosmicSignatureSession) Owner() (common.Address, error) {
	return _CosmicSignature.Contract.Owner(&_CosmicSignature.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_CosmicSignature *CosmicSignatureCallerSession) Owner() (common.Address, error) {
	return _CosmicSignature.Contract.Owner(&_CosmicSignature.CallOpts)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address)
func (_CosmicSignature *CosmicSignatureCaller) OwnerOf(opts *bind.CallOpts, tokenId *big.Int) (common.Address, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "ownerOf", tokenId)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address)
func (_CosmicSignature *CosmicSignatureSession) OwnerOf(tokenId *big.Int) (common.Address, error) {
	return _CosmicSignature.Contract.OwnerOf(&_CosmicSignature.CallOpts, tokenId)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address)
func (_CosmicSignature *CosmicSignatureCallerSession) OwnerOf(tokenId *big.Int) (common.Address, error) {
	return _CosmicSignature.Contract.OwnerOf(&_CosmicSignature.CallOpts, tokenId)
}

// Seeds is a free data retrieval call binding the contract method 0xf0503e80.
//
// Solidity: function seeds(uint256 ) view returns(bytes32)
func (_CosmicSignature *CosmicSignatureCaller) Seeds(opts *bind.CallOpts, arg0 *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "seeds", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// Seeds is a free data retrieval call binding the contract method 0xf0503e80.
//
// Solidity: function seeds(uint256 ) view returns(bytes32)
func (_CosmicSignature *CosmicSignatureSession) Seeds(arg0 *big.Int) ([32]byte, error) {
	return _CosmicSignature.Contract.Seeds(&_CosmicSignature.CallOpts, arg0)
}

// Seeds is a free data retrieval call binding the contract method 0xf0503e80.
//
// Solidity: function seeds(uint256 ) view returns(bytes32)
func (_CosmicSignature *CosmicSignatureCallerSession) Seeds(arg0 *big.Int) ([32]byte, error) {
	return _CosmicSignature.Contract.Seeds(&_CosmicSignature.CallOpts, arg0)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_CosmicSignature *CosmicSignatureCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "supportsInterface", interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_CosmicSignature *CosmicSignatureSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _CosmicSignature.Contract.SupportsInterface(&_CosmicSignature.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_CosmicSignature *CosmicSignatureCallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _CosmicSignature.Contract.SupportsInterface(&_CosmicSignature.CallOpts, interfaceId)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_CosmicSignature *CosmicSignatureCaller) Symbol(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "symbol")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_CosmicSignature *CosmicSignatureSession) Symbol() (string, error) {
	return _CosmicSignature.Contract.Symbol(&_CosmicSignature.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_CosmicSignature *CosmicSignatureCallerSession) Symbol() (string, error) {
	return _CosmicSignature.Contract.Symbol(&_CosmicSignature.CallOpts)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 index) view returns(uint256)
func (_CosmicSignature *CosmicSignatureCaller) TokenByIndex(opts *bind.CallOpts, index *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "tokenByIndex", index)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 index) view returns(uint256)
func (_CosmicSignature *CosmicSignatureSession) TokenByIndex(index *big.Int) (*big.Int, error) {
	return _CosmicSignature.Contract.TokenByIndex(&_CosmicSignature.CallOpts, index)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 index) view returns(uint256)
func (_CosmicSignature *CosmicSignatureCallerSession) TokenByIndex(index *big.Int) (*big.Int, error) {
	return _CosmicSignature.Contract.TokenByIndex(&_CosmicSignature.CallOpts, index)
}

// TokenGenerationScriptURL is a free data retrieval call binding the contract method 0xde9d90bc.
//
// Solidity: function tokenGenerationScriptURL() view returns(string)
func (_CosmicSignature *CosmicSignatureCaller) TokenGenerationScriptURL(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "tokenGenerationScriptURL")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// TokenGenerationScriptURL is a free data retrieval call binding the contract method 0xde9d90bc.
//
// Solidity: function tokenGenerationScriptURL() view returns(string)
func (_CosmicSignature *CosmicSignatureSession) TokenGenerationScriptURL() (string, error) {
	return _CosmicSignature.Contract.TokenGenerationScriptURL(&_CosmicSignature.CallOpts)
}

// TokenGenerationScriptURL is a free data retrieval call binding the contract method 0xde9d90bc.
//
// Solidity: function tokenGenerationScriptURL() view returns(string)
func (_CosmicSignature *CosmicSignatureCallerSession) TokenGenerationScriptURL() (string, error) {
	return _CosmicSignature.Contract.TokenGenerationScriptURL(&_CosmicSignature.CallOpts)
}

// TokenNames is a free data retrieval call binding the contract method 0x310495ab.
//
// Solidity: function tokenNames(uint256 ) view returns(string)
func (_CosmicSignature *CosmicSignatureCaller) TokenNames(opts *bind.CallOpts, arg0 *big.Int) (string, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "tokenNames", arg0)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// TokenNames is a free data retrieval call binding the contract method 0x310495ab.
//
// Solidity: function tokenNames(uint256 ) view returns(string)
func (_CosmicSignature *CosmicSignatureSession) TokenNames(arg0 *big.Int) (string, error) {
	return _CosmicSignature.Contract.TokenNames(&_CosmicSignature.CallOpts, arg0)
}

// TokenNames is a free data retrieval call binding the contract method 0x310495ab.
//
// Solidity: function tokenNames(uint256 ) view returns(string)
func (_CosmicSignature *CosmicSignatureCallerSession) TokenNames(arg0 *big.Int) (string, error) {
	return _CosmicSignature.Contract.TokenNames(&_CosmicSignature.CallOpts, arg0)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address owner, uint256 index) view returns(uint256)
func (_CosmicSignature *CosmicSignatureCaller) TokenOfOwnerByIndex(opts *bind.CallOpts, owner common.Address, index *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "tokenOfOwnerByIndex", owner, index)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address owner, uint256 index) view returns(uint256)
func (_CosmicSignature *CosmicSignatureSession) TokenOfOwnerByIndex(owner common.Address, index *big.Int) (*big.Int, error) {
	return _CosmicSignature.Contract.TokenOfOwnerByIndex(&_CosmicSignature.CallOpts, owner, index)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address owner, uint256 index) view returns(uint256)
func (_CosmicSignature *CosmicSignatureCallerSession) TokenOfOwnerByIndex(owner common.Address, index *big.Int) (*big.Int, error) {
	return _CosmicSignature.Contract.TokenOfOwnerByIndex(&_CosmicSignature.CallOpts, owner, index)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 tokenId) view returns(string)
func (_CosmicSignature *CosmicSignatureCaller) TokenURI(opts *bind.CallOpts, tokenId *big.Int) (string, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "tokenURI", tokenId)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 tokenId) view returns(string)
func (_CosmicSignature *CosmicSignatureSession) TokenURI(tokenId *big.Int) (string, error) {
	return _CosmicSignature.Contract.TokenURI(&_CosmicSignature.CallOpts, tokenId)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 tokenId) view returns(string)
func (_CosmicSignature *CosmicSignatureCallerSession) TokenURI(tokenId *big.Int) (string, error) {
	return _CosmicSignature.Contract.TokenURI(&_CosmicSignature.CallOpts, tokenId)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_CosmicSignature *CosmicSignatureCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_CosmicSignature *CosmicSignatureSession) TotalSupply() (*big.Int, error) {
	return _CosmicSignature.Contract.TotalSupply(&_CosmicSignature.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_CosmicSignature *CosmicSignatureCallerSession) TotalSupply() (*big.Int, error) {
	return _CosmicSignature.Contract.TotalSupply(&_CosmicSignature.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_CosmicSignature *CosmicSignatureTransactor) Approve(opts *bind.TransactOpts, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignature.contract.Transact(opts, "approve", to, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_CosmicSignature *CosmicSignatureSession) Approve(to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignature.Contract.Approve(&_CosmicSignature.TransactOpts, to, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_CosmicSignature *CosmicSignatureTransactorSession) Approve(to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignature.Contract.Approve(&_CosmicSignature.TransactOpts, to, tokenId)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address owner, uint256 roundNum) returns(uint256)
func (_CosmicSignature *CosmicSignatureTransactor) Mint(opts *bind.TransactOpts, owner common.Address, roundNum *big.Int) (*types.Transaction, error) {
	return _CosmicSignature.contract.Transact(opts, "mint", owner, roundNum)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address owner, uint256 roundNum) returns(uint256)
func (_CosmicSignature *CosmicSignatureSession) Mint(owner common.Address, roundNum *big.Int) (*types.Transaction, error) {
	return _CosmicSignature.Contract.Mint(&_CosmicSignature.TransactOpts, owner, roundNum)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address owner, uint256 roundNum) returns(uint256)
func (_CosmicSignature *CosmicSignatureTransactorSession) Mint(owner common.Address, roundNum *big.Int) (*types.Transaction, error) {
	return _CosmicSignature.Contract.Mint(&_CosmicSignature.TransactOpts, owner, roundNum)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_CosmicSignature *CosmicSignatureTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CosmicSignature.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_CosmicSignature *CosmicSignatureSession) RenounceOwnership() (*types.Transaction, error) {
	return _CosmicSignature.Contract.RenounceOwnership(&_CosmicSignature.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_CosmicSignature *CosmicSignatureTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _CosmicSignature.Contract.RenounceOwnership(&_CosmicSignature.TransactOpts)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_CosmicSignature *CosmicSignatureTransactor) SafeTransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignature.contract.Transact(opts, "safeTransferFrom", from, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_CosmicSignature *CosmicSignatureSession) SafeTransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignature.Contract.SafeTransferFrom(&_CosmicSignature.TransactOpts, from, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_CosmicSignature *CosmicSignatureTransactorSession) SafeTransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignature.Contract.SafeTransferFrom(&_CosmicSignature.TransactOpts, from, to, tokenId)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_CosmicSignature *CosmicSignatureTransactor) SafeTransferFrom0(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _CosmicSignature.contract.Transact(opts, "safeTransferFrom0", from, to, tokenId, data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_CosmicSignature *CosmicSignatureSession) SafeTransferFrom0(from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _CosmicSignature.Contract.SafeTransferFrom0(&_CosmicSignature.TransactOpts, from, to, tokenId, data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_CosmicSignature *CosmicSignatureTransactorSession) SafeTransferFrom0(from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _CosmicSignature.Contract.SafeTransferFrom0(&_CosmicSignature.TransactOpts, from, to, tokenId, data)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_CosmicSignature *CosmicSignatureTransactor) SetApprovalForAll(opts *bind.TransactOpts, operator common.Address, approved bool) (*types.Transaction, error) {
	return _CosmicSignature.contract.Transact(opts, "setApprovalForAll", operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_CosmicSignature *CosmicSignatureSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _CosmicSignature.Contract.SetApprovalForAll(&_CosmicSignature.TransactOpts, operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_CosmicSignature *CosmicSignatureTransactorSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _CosmicSignature.Contract.SetApprovalForAll(&_CosmicSignature.TransactOpts, operator, approved)
}

// SetBaseURI is a paid mutator transaction binding the contract method 0x55f804b3.
//
// Solidity: function setBaseURI(string value) returns()
func (_CosmicSignature *CosmicSignatureTransactor) SetBaseURI(opts *bind.TransactOpts, value string) (*types.Transaction, error) {
	return _CosmicSignature.contract.Transact(opts, "setBaseURI", value)
}

// SetBaseURI is a paid mutator transaction binding the contract method 0x55f804b3.
//
// Solidity: function setBaseURI(string value) returns()
func (_CosmicSignature *CosmicSignatureSession) SetBaseURI(value string) (*types.Transaction, error) {
	return _CosmicSignature.Contract.SetBaseURI(&_CosmicSignature.TransactOpts, value)
}

// SetBaseURI is a paid mutator transaction binding the contract method 0x55f804b3.
//
// Solidity: function setBaseURI(string value) returns()
func (_CosmicSignature *CosmicSignatureTransactorSession) SetBaseURI(value string) (*types.Transaction, error) {
	return _CosmicSignature.Contract.SetBaseURI(&_CosmicSignature.TransactOpts, value)
}

// SetTokenGenerationScriptURL is a paid mutator transaction binding the contract method 0x46519a18.
//
// Solidity: function setTokenGenerationScriptURL(string newTokenGenerationScriptURL) returns()
func (_CosmicSignature *CosmicSignatureTransactor) SetTokenGenerationScriptURL(opts *bind.TransactOpts, newTokenGenerationScriptURL string) (*types.Transaction, error) {
	return _CosmicSignature.contract.Transact(opts, "setTokenGenerationScriptURL", newTokenGenerationScriptURL)
}

// SetTokenGenerationScriptURL is a paid mutator transaction binding the contract method 0x46519a18.
//
// Solidity: function setTokenGenerationScriptURL(string newTokenGenerationScriptURL) returns()
func (_CosmicSignature *CosmicSignatureSession) SetTokenGenerationScriptURL(newTokenGenerationScriptURL string) (*types.Transaction, error) {
	return _CosmicSignature.Contract.SetTokenGenerationScriptURL(&_CosmicSignature.TransactOpts, newTokenGenerationScriptURL)
}

// SetTokenGenerationScriptURL is a paid mutator transaction binding the contract method 0x46519a18.
//
// Solidity: function setTokenGenerationScriptURL(string newTokenGenerationScriptURL) returns()
func (_CosmicSignature *CosmicSignatureTransactorSession) SetTokenGenerationScriptURL(newTokenGenerationScriptURL string) (*types.Transaction, error) {
	return _CosmicSignature.Contract.SetTokenGenerationScriptURL(&_CosmicSignature.TransactOpts, newTokenGenerationScriptURL)
}

// SetTokenName is a paid mutator transaction binding the contract method 0xcdb0e89e.
//
// Solidity: function setTokenName(uint256 tokenId, string name) returns()
func (_CosmicSignature *CosmicSignatureTransactor) SetTokenName(opts *bind.TransactOpts, tokenId *big.Int, name string) (*types.Transaction, error) {
	return _CosmicSignature.contract.Transact(opts, "setTokenName", tokenId, name)
}

// SetTokenName is a paid mutator transaction binding the contract method 0xcdb0e89e.
//
// Solidity: function setTokenName(uint256 tokenId, string name) returns()
func (_CosmicSignature *CosmicSignatureSession) SetTokenName(tokenId *big.Int, name string) (*types.Transaction, error) {
	return _CosmicSignature.Contract.SetTokenName(&_CosmicSignature.TransactOpts, tokenId, name)
}

// SetTokenName is a paid mutator transaction binding the contract method 0xcdb0e89e.
//
// Solidity: function setTokenName(uint256 tokenId, string name) returns()
func (_CosmicSignature *CosmicSignatureTransactorSession) SetTokenName(tokenId *big.Int, name string) (*types.Transaction, error) {
	return _CosmicSignature.Contract.SetTokenName(&_CosmicSignature.TransactOpts, tokenId, name)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_CosmicSignature *CosmicSignatureTransactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignature.contract.Transact(opts, "transferFrom", from, to, tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_CosmicSignature *CosmicSignatureSession) TransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignature.Contract.TransferFrom(&_CosmicSignature.TransactOpts, from, to, tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_CosmicSignature *CosmicSignatureTransactorSession) TransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignature.Contract.TransferFrom(&_CosmicSignature.TransactOpts, from, to, tokenId)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_CosmicSignature *CosmicSignatureTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _CosmicSignature.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_CosmicSignature *CosmicSignatureSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _CosmicSignature.Contract.TransferOwnership(&_CosmicSignature.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_CosmicSignature *CosmicSignatureTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _CosmicSignature.Contract.TransferOwnership(&_CosmicSignature.TransactOpts, newOwner)
}

// CosmicSignatureApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the CosmicSignature contract.
type CosmicSignatureApprovalIterator struct {
	Event *CosmicSignatureApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureApproval represents a Approval event raised by the CosmicSignature contract.
type CosmicSignatureApproval struct {
	Owner    common.Address
	Approved common.Address
	TokenId  *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_CosmicSignature *CosmicSignatureFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, approved []common.Address, tokenId []*big.Int) (*CosmicSignatureApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _CosmicSignature.contract.FilterLogs(opts, "Approval", ownerRule, approvedRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureApprovalIterator{contract: _CosmicSignature.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_CosmicSignature *CosmicSignatureFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *CosmicSignatureApproval, owner []common.Address, approved []common.Address, tokenId []*big.Int) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _CosmicSignature.contract.WatchLogs(opts, "Approval", ownerRule, approvedRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureApproval)
				if err := _CosmicSignature.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_CosmicSignature *CosmicSignatureFilterer) ParseApproval(log types.Log) (*CosmicSignatureApproval, error) {
	event := new(CosmicSignatureApproval)
	if err := _CosmicSignature.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureApprovalForAllIterator is returned from FilterApprovalForAll and is used to iterate over the raw logs and unpacked data for ApprovalForAll events raised by the CosmicSignature contract.
type CosmicSignatureApprovalForAllIterator struct {
	Event *CosmicSignatureApprovalForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureApprovalForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureApprovalForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureApprovalForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureApprovalForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureApprovalForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureApprovalForAll represents a ApprovalForAll event raised by the CosmicSignature contract.
type CosmicSignatureApprovalForAll struct {
	Owner    common.Address
	Operator common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApprovalForAll is a free log retrieval operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_CosmicSignature *CosmicSignatureFilterer) FilterApprovalForAll(opts *bind.FilterOpts, owner []common.Address, operator []common.Address) (*CosmicSignatureApprovalForAllIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _CosmicSignature.contract.FilterLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureApprovalForAllIterator{contract: _CosmicSignature.contract, event: "ApprovalForAll", logs: logs, sub: sub}, nil
}

// WatchApprovalForAll is a free log subscription operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_CosmicSignature *CosmicSignatureFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *CosmicSignatureApprovalForAll, owner []common.Address, operator []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _CosmicSignature.contract.WatchLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureApprovalForAll)
				if err := _CosmicSignature.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApprovalForAll is a log parse operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_CosmicSignature *CosmicSignatureFilterer) ParseApprovalForAll(log types.Log) (*CosmicSignatureApprovalForAll, error) {
	event := new(CosmicSignatureApprovalForAll)
	if err := _CosmicSignature.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureBaseURIEventIterator is returned from FilterBaseURIEvent and is used to iterate over the raw logs and unpacked data for BaseURIEvent events raised by the CosmicSignature contract.
type CosmicSignatureBaseURIEventIterator struct {
	Event *CosmicSignatureBaseURIEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureBaseURIEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureBaseURIEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureBaseURIEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureBaseURIEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureBaseURIEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureBaseURIEvent represents a BaseURIEvent event raised by the CosmicSignature contract.
type CosmicSignatureBaseURIEvent struct {
	NewURI string
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterBaseURIEvent is a free log retrieval operation binding the contract event 0x2fc013f885e8a815b9d697da28bc143b4dced47528c41b46e2b35fd0f4be718c.
//
// Solidity: event BaseURIEvent(string newURI)
func (_CosmicSignature *CosmicSignatureFilterer) FilterBaseURIEvent(opts *bind.FilterOpts) (*CosmicSignatureBaseURIEventIterator, error) {

	logs, sub, err := _CosmicSignature.contract.FilterLogs(opts, "BaseURIEvent")
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureBaseURIEventIterator{contract: _CosmicSignature.contract, event: "BaseURIEvent", logs: logs, sub: sub}, nil
}

// WatchBaseURIEvent is a free log subscription operation binding the contract event 0x2fc013f885e8a815b9d697da28bc143b4dced47528c41b46e2b35fd0f4be718c.
//
// Solidity: event BaseURIEvent(string newURI)
func (_CosmicSignature *CosmicSignatureFilterer) WatchBaseURIEvent(opts *bind.WatchOpts, sink chan<- *CosmicSignatureBaseURIEvent) (event.Subscription, error) {

	logs, sub, err := _CosmicSignature.contract.WatchLogs(opts, "BaseURIEvent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureBaseURIEvent)
				if err := _CosmicSignature.contract.UnpackLog(event, "BaseURIEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBaseURIEvent is a log parse operation binding the contract event 0x2fc013f885e8a815b9d697da28bc143b4dced47528c41b46e2b35fd0f4be718c.
//
// Solidity: event BaseURIEvent(string newURI)
func (_CosmicSignature *CosmicSignatureFilterer) ParseBaseURIEvent(log types.Log) (*CosmicSignatureBaseURIEvent, error) {
	event := new(CosmicSignatureBaseURIEvent)
	if err := _CosmicSignature.contract.UnpackLog(event, "BaseURIEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureMintEventIterator is returned from FilterMintEvent and is used to iterate over the raw logs and unpacked data for MintEvent events raised by the CosmicSignature contract.
type CosmicSignatureMintEventIterator struct {
	Event *CosmicSignatureMintEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureMintEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureMintEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureMintEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureMintEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureMintEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureMintEvent represents a MintEvent event raised by the CosmicSignature contract.
type CosmicSignatureMintEvent struct {
	TokenId  *big.Int
	Owner    common.Address
	RoundNum *big.Int
	Seed     [32]byte
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterMintEvent is a free log retrieval operation binding the contract event 0xc646da88dc2b2526461a0ebb4326e2418ec0bea89496b632b7c9ee42fbfe1d4d.
//
// Solidity: event MintEvent(uint256 indexed tokenId, address indexed owner, uint256 indexed roundNum, bytes32 seed)
func (_CosmicSignature *CosmicSignatureFilterer) FilterMintEvent(opts *bind.FilterOpts, tokenId []*big.Int, owner []common.Address, roundNum []*big.Int) (*CosmicSignatureMintEventIterator, error) {

	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}
	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var roundNumRule []interface{}
	for _, roundNumItem := range roundNum {
		roundNumRule = append(roundNumRule, roundNumItem)
	}

	logs, sub, err := _CosmicSignature.contract.FilterLogs(opts, "MintEvent", tokenIdRule, ownerRule, roundNumRule)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureMintEventIterator{contract: _CosmicSignature.contract, event: "MintEvent", logs: logs, sub: sub}, nil
}

// WatchMintEvent is a free log subscription operation binding the contract event 0xc646da88dc2b2526461a0ebb4326e2418ec0bea89496b632b7c9ee42fbfe1d4d.
//
// Solidity: event MintEvent(uint256 indexed tokenId, address indexed owner, uint256 indexed roundNum, bytes32 seed)
func (_CosmicSignature *CosmicSignatureFilterer) WatchMintEvent(opts *bind.WatchOpts, sink chan<- *CosmicSignatureMintEvent, tokenId []*big.Int, owner []common.Address, roundNum []*big.Int) (event.Subscription, error) {

	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}
	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var roundNumRule []interface{}
	for _, roundNumItem := range roundNum {
		roundNumRule = append(roundNumRule, roundNumItem)
	}

	logs, sub, err := _CosmicSignature.contract.WatchLogs(opts, "MintEvent", tokenIdRule, ownerRule, roundNumRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureMintEvent)
				if err := _CosmicSignature.contract.UnpackLog(event, "MintEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMintEvent is a log parse operation binding the contract event 0xc646da88dc2b2526461a0ebb4326e2418ec0bea89496b632b7c9ee42fbfe1d4d.
//
// Solidity: event MintEvent(uint256 indexed tokenId, address indexed owner, uint256 indexed roundNum, bytes32 seed)
func (_CosmicSignature *CosmicSignatureFilterer) ParseMintEvent(log types.Log) (*CosmicSignatureMintEvent, error) {
	event := new(CosmicSignatureMintEvent)
	if err := _CosmicSignature.contract.UnpackLog(event, "MintEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the CosmicSignature contract.
type CosmicSignatureOwnershipTransferredIterator struct {
	Event *CosmicSignatureOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureOwnershipTransferred represents a OwnershipTransferred event raised by the CosmicSignature contract.
type CosmicSignatureOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_CosmicSignature *CosmicSignatureFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*CosmicSignatureOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _CosmicSignature.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureOwnershipTransferredIterator{contract: _CosmicSignature.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_CosmicSignature *CosmicSignatureFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *CosmicSignatureOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _CosmicSignature.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureOwnershipTransferred)
				if err := _CosmicSignature.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_CosmicSignature *CosmicSignatureFilterer) ParseOwnershipTransferred(log types.Log) (*CosmicSignatureOwnershipTransferred, error) {
	event := new(CosmicSignatureOwnershipTransferred)
	if err := _CosmicSignature.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureTokenGenerationScriptURLEventIterator is returned from FilterTokenGenerationScriptURLEvent and is used to iterate over the raw logs and unpacked data for TokenGenerationScriptURLEvent events raised by the CosmicSignature contract.
type CosmicSignatureTokenGenerationScriptURLEventIterator struct {
	Event *CosmicSignatureTokenGenerationScriptURLEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureTokenGenerationScriptURLEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureTokenGenerationScriptURLEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureTokenGenerationScriptURLEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureTokenGenerationScriptURLEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureTokenGenerationScriptURLEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureTokenGenerationScriptURLEvent represents a TokenGenerationScriptURLEvent event raised by the CosmicSignature contract.
type CosmicSignatureTokenGenerationScriptURLEvent struct {
	NewURL string
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterTokenGenerationScriptURLEvent is a free log retrieval operation binding the contract event 0x0119741ee0f95fab26124262a82c3c0e9e1c7ff4bb33c6fba5f3b11c9b6d0bad.
//
// Solidity: event TokenGenerationScriptURLEvent(string newURL)
func (_CosmicSignature *CosmicSignatureFilterer) FilterTokenGenerationScriptURLEvent(opts *bind.FilterOpts) (*CosmicSignatureTokenGenerationScriptURLEventIterator, error) {

	logs, sub, err := _CosmicSignature.contract.FilterLogs(opts, "TokenGenerationScriptURLEvent")
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureTokenGenerationScriptURLEventIterator{contract: _CosmicSignature.contract, event: "TokenGenerationScriptURLEvent", logs: logs, sub: sub}, nil
}

// WatchTokenGenerationScriptURLEvent is a free log subscription operation binding the contract event 0x0119741ee0f95fab26124262a82c3c0e9e1c7ff4bb33c6fba5f3b11c9b6d0bad.
//
// Solidity: event TokenGenerationScriptURLEvent(string newURL)
func (_CosmicSignature *CosmicSignatureFilterer) WatchTokenGenerationScriptURLEvent(opts *bind.WatchOpts, sink chan<- *CosmicSignatureTokenGenerationScriptURLEvent) (event.Subscription, error) {

	logs, sub, err := _CosmicSignature.contract.WatchLogs(opts, "TokenGenerationScriptURLEvent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureTokenGenerationScriptURLEvent)
				if err := _CosmicSignature.contract.UnpackLog(event, "TokenGenerationScriptURLEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTokenGenerationScriptURLEvent is a log parse operation binding the contract event 0x0119741ee0f95fab26124262a82c3c0e9e1c7ff4bb33c6fba5f3b11c9b6d0bad.
//
// Solidity: event TokenGenerationScriptURLEvent(string newURL)
func (_CosmicSignature *CosmicSignatureFilterer) ParseTokenGenerationScriptURLEvent(log types.Log) (*CosmicSignatureTokenGenerationScriptURLEvent, error) {
	event := new(CosmicSignatureTokenGenerationScriptURLEvent)
	if err := _CosmicSignature.contract.UnpackLog(event, "TokenGenerationScriptURLEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureTokenNameEventIterator is returned from FilterTokenNameEvent and is used to iterate over the raw logs and unpacked data for TokenNameEvent events raised by the CosmicSignature contract.
type CosmicSignatureTokenNameEventIterator struct {
	Event *CosmicSignatureTokenNameEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureTokenNameEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureTokenNameEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureTokenNameEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureTokenNameEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureTokenNameEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureTokenNameEvent represents a TokenNameEvent event raised by the CosmicSignature contract.
type CosmicSignatureTokenNameEvent struct {
	TokenId *big.Int
	NewName string
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterTokenNameEvent is a free log retrieval operation binding the contract event 0x8ad5e159ff95649c8a9f323ac5a457e741897cf44ce07dfce0e98b84ef9d5f12.
//
// Solidity: event TokenNameEvent(uint256 indexed tokenId, string newName)
func (_CosmicSignature *CosmicSignatureFilterer) FilterTokenNameEvent(opts *bind.FilterOpts, tokenId []*big.Int) (*CosmicSignatureTokenNameEventIterator, error) {

	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _CosmicSignature.contract.FilterLogs(opts, "TokenNameEvent", tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureTokenNameEventIterator{contract: _CosmicSignature.contract, event: "TokenNameEvent", logs: logs, sub: sub}, nil
}

// WatchTokenNameEvent is a free log subscription operation binding the contract event 0x8ad5e159ff95649c8a9f323ac5a457e741897cf44ce07dfce0e98b84ef9d5f12.
//
// Solidity: event TokenNameEvent(uint256 indexed tokenId, string newName)
func (_CosmicSignature *CosmicSignatureFilterer) WatchTokenNameEvent(opts *bind.WatchOpts, sink chan<- *CosmicSignatureTokenNameEvent, tokenId []*big.Int) (event.Subscription, error) {

	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _CosmicSignature.contract.WatchLogs(opts, "TokenNameEvent", tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureTokenNameEvent)
				if err := _CosmicSignature.contract.UnpackLog(event, "TokenNameEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTokenNameEvent is a log parse operation binding the contract event 0x8ad5e159ff95649c8a9f323ac5a457e741897cf44ce07dfce0e98b84ef9d5f12.
//
// Solidity: event TokenNameEvent(uint256 indexed tokenId, string newName)
func (_CosmicSignature *CosmicSignatureFilterer) ParseTokenNameEvent(log types.Log) (*CosmicSignatureTokenNameEvent, error) {
	event := new(CosmicSignatureTokenNameEvent)
	if err := _CosmicSignature.contract.UnpackLog(event, "TokenNameEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the CosmicSignature contract.
type CosmicSignatureTransferIterator struct {
	Event *CosmicSignatureTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureTransfer represents a Transfer event raised by the CosmicSignature contract.
type CosmicSignatureTransfer struct {
	From    common.Address
	To      common.Address
	TokenId *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_CosmicSignature *CosmicSignatureFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenId []*big.Int) (*CosmicSignatureTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _CosmicSignature.contract.FilterLogs(opts, "Transfer", fromRule, toRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureTransferIterator{contract: _CosmicSignature.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_CosmicSignature *CosmicSignatureFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *CosmicSignatureTransfer, from []common.Address, to []common.Address, tokenId []*big.Int) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _CosmicSignature.contract.WatchLogs(opts, "Transfer", fromRule, toRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureTransfer)
				if err := _CosmicSignature.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_CosmicSignature *CosmicSignatureFilterer) ParseTransfer(log types.Log) (*CosmicSignatureTransfer, error) {
	event := new(CosmicSignatureTransfer)
	if err := _CosmicSignature.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureMetaData contains all meta data concerning the ICosmicSignature contract.
var ICosmicSignatureMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newURI\",\"type\":\"string\"}],\"name\":\"BaseURIEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"seed\",\"type\":\"bytes32\"}],\"name\":\"MintEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newURL\",\"type\":\"string\"}],\"name\":\"TokenGenerationScriptURLEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"}],\"name\":\"TokenNameEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roundNum\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newTokenGenerationScriptURL\",\"type\":\"string\"}],\"name\":\"setTokenGenerationScriptURL\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"setTokenName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// ICosmicSignatureABI is the input ABI used to generate the binding from.
// Deprecated: Use ICosmicSignatureMetaData.ABI instead.
var ICosmicSignatureABI = ICosmicSignatureMetaData.ABI

// ICosmicSignature is an auto generated Go binding around an Ethereum contract.
type ICosmicSignature struct {
	ICosmicSignatureCaller     // Read-only binding to the contract
	ICosmicSignatureTransactor // Write-only binding to the contract
	ICosmicSignatureFilterer   // Log filterer for contract events
}

// ICosmicSignatureCaller is an auto generated read-only Go binding around an Ethereum contract.
type ICosmicSignatureCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ICosmicSignatureTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ICosmicSignatureTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ICosmicSignatureFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ICosmicSignatureFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ICosmicSignatureSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ICosmicSignatureSession struct {
	Contract     *ICosmicSignature // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ICosmicSignatureCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ICosmicSignatureCallerSession struct {
	Contract *ICosmicSignatureCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts           // Call options to use throughout this session
}

// ICosmicSignatureTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ICosmicSignatureTransactorSession struct {
	Contract     *ICosmicSignatureTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts           // Transaction auth options to use throughout this session
}

// ICosmicSignatureRaw is an auto generated low-level Go binding around an Ethereum contract.
type ICosmicSignatureRaw struct {
	Contract *ICosmicSignature // Generic contract binding to access the raw methods on
}

// ICosmicSignatureCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ICosmicSignatureCallerRaw struct {
	Contract *ICosmicSignatureCaller // Generic read-only contract binding to access the raw methods on
}

// ICosmicSignatureTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ICosmicSignatureTransactorRaw struct {
	Contract *ICosmicSignatureTransactor // Generic write-only contract binding to access the raw methods on
}

// NewICosmicSignature creates a new instance of ICosmicSignature, bound to a specific deployed contract.
func NewICosmicSignature(address common.Address, backend bind.ContractBackend) (*ICosmicSignature, error) {
	contract, err := bindICosmicSignature(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignature{ICosmicSignatureCaller: ICosmicSignatureCaller{contract: contract}, ICosmicSignatureTransactor: ICosmicSignatureTransactor{contract: contract}, ICosmicSignatureFilterer: ICosmicSignatureFilterer{contract: contract}}, nil
}

// NewICosmicSignatureCaller creates a new read-only instance of ICosmicSignature, bound to a specific deployed contract.
func NewICosmicSignatureCaller(address common.Address, caller bind.ContractCaller) (*ICosmicSignatureCaller, error) {
	contract, err := bindICosmicSignature(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureCaller{contract: contract}, nil
}

// NewICosmicSignatureTransactor creates a new write-only instance of ICosmicSignature, bound to a specific deployed contract.
func NewICosmicSignatureTransactor(address common.Address, transactor bind.ContractTransactor) (*ICosmicSignatureTransactor, error) {
	contract, err := bindICosmicSignature(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureTransactor{contract: contract}, nil
}

// NewICosmicSignatureFilterer creates a new log filterer instance of ICosmicSignature, bound to a specific deployed contract.
func NewICosmicSignatureFilterer(address common.Address, filterer bind.ContractFilterer) (*ICosmicSignatureFilterer, error) {
	contract, err := bindICosmicSignature(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureFilterer{contract: contract}, nil
}

// bindICosmicSignature binds a generic wrapper to an already deployed contract.
func bindICosmicSignature(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ICosmicSignatureMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ICosmicSignature *ICosmicSignatureRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ICosmicSignature.Contract.ICosmicSignatureCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ICosmicSignature *ICosmicSignatureRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.ICosmicSignatureTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ICosmicSignature *ICosmicSignatureRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.ICosmicSignatureTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ICosmicSignature *ICosmicSignatureCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ICosmicSignature.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ICosmicSignature *ICosmicSignatureTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ICosmicSignature *ICosmicSignatureTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.contract.Transact(opts, method, params...)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256 balance)
func (_ICosmicSignature *ICosmicSignatureCaller) BalanceOf(opts *bind.CallOpts, owner common.Address) (*big.Int, error) {
	var out []interface{}
	err := _ICosmicSignature.contract.Call(opts, &out, "balanceOf", owner)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256 balance)
func (_ICosmicSignature *ICosmicSignatureSession) BalanceOf(owner common.Address) (*big.Int, error) {
	return _ICosmicSignature.Contract.BalanceOf(&_ICosmicSignature.CallOpts, owner)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256 balance)
func (_ICosmicSignature *ICosmicSignatureCallerSession) BalanceOf(owner common.Address) (*big.Int, error) {
	return _ICosmicSignature.Contract.BalanceOf(&_ICosmicSignature.CallOpts, owner)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address operator)
func (_ICosmicSignature *ICosmicSignatureCaller) GetApproved(opts *bind.CallOpts, tokenId *big.Int) (common.Address, error) {
	var out []interface{}
	err := _ICosmicSignature.contract.Call(opts, &out, "getApproved", tokenId)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address operator)
func (_ICosmicSignature *ICosmicSignatureSession) GetApproved(tokenId *big.Int) (common.Address, error) {
	return _ICosmicSignature.Contract.GetApproved(&_ICosmicSignature.CallOpts, tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address operator)
func (_ICosmicSignature *ICosmicSignatureCallerSession) GetApproved(tokenId *big.Int) (common.Address, error) {
	return _ICosmicSignature.Contract.GetApproved(&_ICosmicSignature.CallOpts, tokenId)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_ICosmicSignature *ICosmicSignatureCaller) IsApprovedForAll(opts *bind.CallOpts, owner common.Address, operator common.Address) (bool, error) {
	var out []interface{}
	err := _ICosmicSignature.contract.Call(opts, &out, "isApprovedForAll", owner, operator)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_ICosmicSignature *ICosmicSignatureSession) IsApprovedForAll(owner common.Address, operator common.Address) (bool, error) {
	return _ICosmicSignature.Contract.IsApprovedForAll(&_ICosmicSignature.CallOpts, owner, operator)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_ICosmicSignature *ICosmicSignatureCallerSession) IsApprovedForAll(owner common.Address, operator common.Address) (bool, error) {
	return _ICosmicSignature.Contract.IsApprovedForAll(&_ICosmicSignature.CallOpts, owner, operator)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address owner)
func (_ICosmicSignature *ICosmicSignatureCaller) OwnerOf(opts *bind.CallOpts, tokenId *big.Int) (common.Address, error) {
	var out []interface{}
	err := _ICosmicSignature.contract.Call(opts, &out, "ownerOf", tokenId)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address owner)
func (_ICosmicSignature *ICosmicSignatureSession) OwnerOf(tokenId *big.Int) (common.Address, error) {
	return _ICosmicSignature.Contract.OwnerOf(&_ICosmicSignature.CallOpts, tokenId)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address owner)
func (_ICosmicSignature *ICosmicSignatureCallerSession) OwnerOf(tokenId *big.Int) (common.Address, error) {
	return _ICosmicSignature.Contract.OwnerOf(&_ICosmicSignature.CallOpts, tokenId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_ICosmicSignature *ICosmicSignatureCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _ICosmicSignature.contract.Call(opts, &out, "supportsInterface", interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_ICosmicSignature *ICosmicSignatureSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _ICosmicSignature.Contract.SupportsInterface(&_ICosmicSignature.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_ICosmicSignature *ICosmicSignatureCallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _ICosmicSignature.Contract.SupportsInterface(&_ICosmicSignature.CallOpts, interfaceId)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 index) view returns(uint256)
func (_ICosmicSignature *ICosmicSignatureCaller) TokenByIndex(opts *bind.CallOpts, index *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _ICosmicSignature.contract.Call(opts, &out, "tokenByIndex", index)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 index) view returns(uint256)
func (_ICosmicSignature *ICosmicSignatureSession) TokenByIndex(index *big.Int) (*big.Int, error) {
	return _ICosmicSignature.Contract.TokenByIndex(&_ICosmicSignature.CallOpts, index)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 index) view returns(uint256)
func (_ICosmicSignature *ICosmicSignatureCallerSession) TokenByIndex(index *big.Int) (*big.Int, error) {
	return _ICosmicSignature.Contract.TokenByIndex(&_ICosmicSignature.CallOpts, index)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address owner, uint256 index) view returns(uint256)
func (_ICosmicSignature *ICosmicSignatureCaller) TokenOfOwnerByIndex(opts *bind.CallOpts, owner common.Address, index *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _ICosmicSignature.contract.Call(opts, &out, "tokenOfOwnerByIndex", owner, index)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address owner, uint256 index) view returns(uint256)
func (_ICosmicSignature *ICosmicSignatureSession) TokenOfOwnerByIndex(owner common.Address, index *big.Int) (*big.Int, error) {
	return _ICosmicSignature.Contract.TokenOfOwnerByIndex(&_ICosmicSignature.CallOpts, owner, index)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address owner, uint256 index) view returns(uint256)
func (_ICosmicSignature *ICosmicSignatureCallerSession) TokenOfOwnerByIndex(owner common.Address, index *big.Int) (*big.Int, error) {
	return _ICosmicSignature.Contract.TokenOfOwnerByIndex(&_ICosmicSignature.CallOpts, owner, index)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ICosmicSignature *ICosmicSignatureCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _ICosmicSignature.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ICosmicSignature *ICosmicSignatureSession) TotalSupply() (*big.Int, error) {
	return _ICosmicSignature.Contract.TotalSupply(&_ICosmicSignature.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ICosmicSignature *ICosmicSignatureCallerSession) TotalSupply() (*big.Int, error) {
	return _ICosmicSignature.Contract.TotalSupply(&_ICosmicSignature.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_ICosmicSignature *ICosmicSignatureTransactor) Approve(opts *bind.TransactOpts, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignature.contract.Transact(opts, "approve", to, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_ICosmicSignature *ICosmicSignatureSession) Approve(to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.Approve(&_ICosmicSignature.TransactOpts, to, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_ICosmicSignature *ICosmicSignatureTransactorSession) Approve(to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.Approve(&_ICosmicSignature.TransactOpts, to, tokenId)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address owner, uint256 roundNum) returns(uint256)
func (_ICosmicSignature *ICosmicSignatureTransactor) Mint(opts *bind.TransactOpts, owner common.Address, roundNum *big.Int) (*types.Transaction, error) {
	return _ICosmicSignature.contract.Transact(opts, "mint", owner, roundNum)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address owner, uint256 roundNum) returns(uint256)
func (_ICosmicSignature *ICosmicSignatureSession) Mint(owner common.Address, roundNum *big.Int) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.Mint(&_ICosmicSignature.TransactOpts, owner, roundNum)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address owner, uint256 roundNum) returns(uint256)
func (_ICosmicSignature *ICosmicSignatureTransactorSession) Mint(owner common.Address, roundNum *big.Int) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.Mint(&_ICosmicSignature.TransactOpts, owner, roundNum)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_ICosmicSignature *ICosmicSignatureTransactor) SafeTransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignature.contract.Transact(opts, "safeTransferFrom", from, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_ICosmicSignature *ICosmicSignatureSession) SafeTransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.SafeTransferFrom(&_ICosmicSignature.TransactOpts, from, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_ICosmicSignature *ICosmicSignatureTransactorSession) SafeTransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.SafeTransferFrom(&_ICosmicSignature.TransactOpts, from, to, tokenId)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_ICosmicSignature *ICosmicSignatureTransactor) SafeTransferFrom0(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _ICosmicSignature.contract.Transact(opts, "safeTransferFrom0", from, to, tokenId, data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_ICosmicSignature *ICosmicSignatureSession) SafeTransferFrom0(from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.SafeTransferFrom0(&_ICosmicSignature.TransactOpts, from, to, tokenId, data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_ICosmicSignature *ICosmicSignatureTransactorSession) SafeTransferFrom0(from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.SafeTransferFrom0(&_ICosmicSignature.TransactOpts, from, to, tokenId, data)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_ICosmicSignature *ICosmicSignatureTransactor) SetApprovalForAll(opts *bind.TransactOpts, operator common.Address, approved bool) (*types.Transaction, error) {
	return _ICosmicSignature.contract.Transact(opts, "setApprovalForAll", operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_ICosmicSignature *ICosmicSignatureSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.SetApprovalForAll(&_ICosmicSignature.TransactOpts, operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_ICosmicSignature *ICosmicSignatureTransactorSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.SetApprovalForAll(&_ICosmicSignature.TransactOpts, operator, approved)
}

// SetBaseURI is a paid mutator transaction binding the contract method 0x55f804b3.
//
// Solidity: function setBaseURI(string value) returns()
func (_ICosmicSignature *ICosmicSignatureTransactor) SetBaseURI(opts *bind.TransactOpts, value string) (*types.Transaction, error) {
	return _ICosmicSignature.contract.Transact(opts, "setBaseURI", value)
}

// SetBaseURI is a paid mutator transaction binding the contract method 0x55f804b3.
//
// Solidity: function setBaseURI(string value) returns()
func (_ICosmicSignature *ICosmicSignatureSession) SetBaseURI(value string) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.SetBaseURI(&_ICosmicSignature.TransactOpts, value)
}

// SetBaseURI is a paid mutator transaction binding the contract method 0x55f804b3.
//
// Solidity: function setBaseURI(string value) returns()
func (_ICosmicSignature *ICosmicSignatureTransactorSession) SetBaseURI(value string) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.SetBaseURI(&_ICosmicSignature.TransactOpts, value)
}

// SetTokenGenerationScriptURL is a paid mutator transaction binding the contract method 0x46519a18.
//
// Solidity: function setTokenGenerationScriptURL(string newTokenGenerationScriptURL) returns()
func (_ICosmicSignature *ICosmicSignatureTransactor) SetTokenGenerationScriptURL(opts *bind.TransactOpts, newTokenGenerationScriptURL string) (*types.Transaction, error) {
	return _ICosmicSignature.contract.Transact(opts, "setTokenGenerationScriptURL", newTokenGenerationScriptURL)
}

// SetTokenGenerationScriptURL is a paid mutator transaction binding the contract method 0x46519a18.
//
// Solidity: function setTokenGenerationScriptURL(string newTokenGenerationScriptURL) returns()
func (_ICosmicSignature *ICosmicSignatureSession) SetTokenGenerationScriptURL(newTokenGenerationScriptURL string) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.SetTokenGenerationScriptURL(&_ICosmicSignature.TransactOpts, newTokenGenerationScriptURL)
}

// SetTokenGenerationScriptURL is a paid mutator transaction binding the contract method 0x46519a18.
//
// Solidity: function setTokenGenerationScriptURL(string newTokenGenerationScriptURL) returns()
func (_ICosmicSignature *ICosmicSignatureTransactorSession) SetTokenGenerationScriptURL(newTokenGenerationScriptURL string) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.SetTokenGenerationScriptURL(&_ICosmicSignature.TransactOpts, newTokenGenerationScriptURL)
}

// SetTokenName is a paid mutator transaction binding the contract method 0xcdb0e89e.
//
// Solidity: function setTokenName(uint256 tokenId, string name) returns()
func (_ICosmicSignature *ICosmicSignatureTransactor) SetTokenName(opts *bind.TransactOpts, tokenId *big.Int, name string) (*types.Transaction, error) {
	return _ICosmicSignature.contract.Transact(opts, "setTokenName", tokenId, name)
}

// SetTokenName is a paid mutator transaction binding the contract method 0xcdb0e89e.
//
// Solidity: function setTokenName(uint256 tokenId, string name) returns()
func (_ICosmicSignature *ICosmicSignatureSession) SetTokenName(tokenId *big.Int, name string) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.SetTokenName(&_ICosmicSignature.TransactOpts, tokenId, name)
}

// SetTokenName is a paid mutator transaction binding the contract method 0xcdb0e89e.
//
// Solidity: function setTokenName(uint256 tokenId, string name) returns()
func (_ICosmicSignature *ICosmicSignatureTransactorSession) SetTokenName(tokenId *big.Int, name string) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.SetTokenName(&_ICosmicSignature.TransactOpts, tokenId, name)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_ICosmicSignature *ICosmicSignatureTransactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignature.contract.Transact(opts, "transferFrom", from, to, tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_ICosmicSignature *ICosmicSignatureSession) TransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.TransferFrom(&_ICosmicSignature.TransactOpts, from, to, tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_ICosmicSignature *ICosmicSignatureTransactorSession) TransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.TransferFrom(&_ICosmicSignature.TransactOpts, from, to, tokenId)
}

// ICosmicSignatureApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the ICosmicSignature contract.
type ICosmicSignatureApprovalIterator struct {
	Event *ICosmicSignatureApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureApproval represents a Approval event raised by the ICosmicSignature contract.
type ICosmicSignatureApproval struct {
	Owner    common.Address
	Approved common.Address
	TokenId  *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_ICosmicSignature *ICosmicSignatureFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, approved []common.Address, tokenId []*big.Int) (*ICosmicSignatureApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _ICosmicSignature.contract.FilterLogs(opts, "Approval", ownerRule, approvedRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureApprovalIterator{contract: _ICosmicSignature.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_ICosmicSignature *ICosmicSignatureFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureApproval, owner []common.Address, approved []common.Address, tokenId []*big.Int) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _ICosmicSignature.contract.WatchLogs(opts, "Approval", ownerRule, approvedRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureApproval)
				if err := _ICosmicSignature.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_ICosmicSignature *ICosmicSignatureFilterer) ParseApproval(log types.Log) (*ICosmicSignatureApproval, error) {
	event := new(ICosmicSignatureApproval)
	if err := _ICosmicSignature.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureApprovalForAllIterator is returned from FilterApprovalForAll and is used to iterate over the raw logs and unpacked data for ApprovalForAll events raised by the ICosmicSignature contract.
type ICosmicSignatureApprovalForAllIterator struct {
	Event *ICosmicSignatureApprovalForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureApprovalForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureApprovalForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureApprovalForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureApprovalForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureApprovalForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureApprovalForAll represents a ApprovalForAll event raised by the ICosmicSignature contract.
type ICosmicSignatureApprovalForAll struct {
	Owner    common.Address
	Operator common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApprovalForAll is a free log retrieval operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_ICosmicSignature *ICosmicSignatureFilterer) FilterApprovalForAll(opts *bind.FilterOpts, owner []common.Address, operator []common.Address) (*ICosmicSignatureApprovalForAllIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _ICosmicSignature.contract.FilterLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureApprovalForAllIterator{contract: _ICosmicSignature.contract, event: "ApprovalForAll", logs: logs, sub: sub}, nil
}

// WatchApprovalForAll is a free log subscription operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_ICosmicSignature *ICosmicSignatureFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureApprovalForAll, owner []common.Address, operator []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _ICosmicSignature.contract.WatchLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureApprovalForAll)
				if err := _ICosmicSignature.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApprovalForAll is a log parse operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_ICosmicSignature *ICosmicSignatureFilterer) ParseApprovalForAll(log types.Log) (*ICosmicSignatureApprovalForAll, error) {
	event := new(ICosmicSignatureApprovalForAll)
	if err := _ICosmicSignature.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureBaseURIEventIterator is returned from FilterBaseURIEvent and is used to iterate over the raw logs and unpacked data for BaseURIEvent events raised by the ICosmicSignature contract.
type ICosmicSignatureBaseURIEventIterator struct {
	Event *ICosmicSignatureBaseURIEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureBaseURIEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureBaseURIEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureBaseURIEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureBaseURIEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureBaseURIEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureBaseURIEvent represents a BaseURIEvent event raised by the ICosmicSignature contract.
type ICosmicSignatureBaseURIEvent struct {
	NewURI string
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterBaseURIEvent is a free log retrieval operation binding the contract event 0x2fc013f885e8a815b9d697da28bc143b4dced47528c41b46e2b35fd0f4be718c.
//
// Solidity: event BaseURIEvent(string newURI)
func (_ICosmicSignature *ICosmicSignatureFilterer) FilterBaseURIEvent(opts *bind.FilterOpts) (*ICosmicSignatureBaseURIEventIterator, error) {

	logs, sub, err := _ICosmicSignature.contract.FilterLogs(opts, "BaseURIEvent")
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureBaseURIEventIterator{contract: _ICosmicSignature.contract, event: "BaseURIEvent", logs: logs, sub: sub}, nil
}

// WatchBaseURIEvent is a free log subscription operation binding the contract event 0x2fc013f885e8a815b9d697da28bc143b4dced47528c41b46e2b35fd0f4be718c.
//
// Solidity: event BaseURIEvent(string newURI)
func (_ICosmicSignature *ICosmicSignatureFilterer) WatchBaseURIEvent(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureBaseURIEvent) (event.Subscription, error) {

	logs, sub, err := _ICosmicSignature.contract.WatchLogs(opts, "BaseURIEvent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureBaseURIEvent)
				if err := _ICosmicSignature.contract.UnpackLog(event, "BaseURIEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBaseURIEvent is a log parse operation binding the contract event 0x2fc013f885e8a815b9d697da28bc143b4dced47528c41b46e2b35fd0f4be718c.
//
// Solidity: event BaseURIEvent(string newURI)
func (_ICosmicSignature *ICosmicSignatureFilterer) ParseBaseURIEvent(log types.Log) (*ICosmicSignatureBaseURIEvent, error) {
	event := new(ICosmicSignatureBaseURIEvent)
	if err := _ICosmicSignature.contract.UnpackLog(event, "BaseURIEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureMintEventIterator is returned from FilterMintEvent and is used to iterate over the raw logs and unpacked data for MintEvent events raised by the ICosmicSignature contract.
type ICosmicSignatureMintEventIterator struct {
	Event *ICosmicSignatureMintEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureMintEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureMintEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureMintEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureMintEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureMintEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureMintEvent represents a MintEvent event raised by the ICosmicSignature contract.
type ICosmicSignatureMintEvent struct {
	TokenId  *big.Int
	Owner    common.Address
	RoundNum *big.Int
	Seed     [32]byte
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterMintEvent is a free log retrieval operation binding the contract event 0xc646da88dc2b2526461a0ebb4326e2418ec0bea89496b632b7c9ee42fbfe1d4d.
//
// Solidity: event MintEvent(uint256 indexed tokenId, address indexed owner, uint256 indexed roundNum, bytes32 seed)
func (_ICosmicSignature *ICosmicSignatureFilterer) FilterMintEvent(opts *bind.FilterOpts, tokenId []*big.Int, owner []common.Address, roundNum []*big.Int) (*ICosmicSignatureMintEventIterator, error) {

	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}
	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var roundNumRule []interface{}
	for _, roundNumItem := range roundNum {
		roundNumRule = append(roundNumRule, roundNumItem)
	}

	logs, sub, err := _ICosmicSignature.contract.FilterLogs(opts, "MintEvent", tokenIdRule, ownerRule, roundNumRule)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureMintEventIterator{contract: _ICosmicSignature.contract, event: "MintEvent", logs: logs, sub: sub}, nil
}

// WatchMintEvent is a free log subscription operation binding the contract event 0xc646da88dc2b2526461a0ebb4326e2418ec0bea89496b632b7c9ee42fbfe1d4d.
//
// Solidity: event MintEvent(uint256 indexed tokenId, address indexed owner, uint256 indexed roundNum, bytes32 seed)
func (_ICosmicSignature *ICosmicSignatureFilterer) WatchMintEvent(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureMintEvent, tokenId []*big.Int, owner []common.Address, roundNum []*big.Int) (event.Subscription, error) {

	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}
	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var roundNumRule []interface{}
	for _, roundNumItem := range roundNum {
		roundNumRule = append(roundNumRule, roundNumItem)
	}

	logs, sub, err := _ICosmicSignature.contract.WatchLogs(opts, "MintEvent", tokenIdRule, ownerRule, roundNumRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureMintEvent)
				if err := _ICosmicSignature.contract.UnpackLog(event, "MintEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMintEvent is a log parse operation binding the contract event 0xc646da88dc2b2526461a0ebb4326e2418ec0bea89496b632b7c9ee42fbfe1d4d.
//
// Solidity: event MintEvent(uint256 indexed tokenId, address indexed owner, uint256 indexed roundNum, bytes32 seed)
func (_ICosmicSignature *ICosmicSignatureFilterer) ParseMintEvent(log types.Log) (*ICosmicSignatureMintEvent, error) {
	event := new(ICosmicSignatureMintEvent)
	if err := _ICosmicSignature.contract.UnpackLog(event, "MintEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureTokenGenerationScriptURLEventIterator is returned from FilterTokenGenerationScriptURLEvent and is used to iterate over the raw logs and unpacked data for TokenGenerationScriptURLEvent events raised by the ICosmicSignature contract.
type ICosmicSignatureTokenGenerationScriptURLEventIterator struct {
	Event *ICosmicSignatureTokenGenerationScriptURLEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureTokenGenerationScriptURLEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureTokenGenerationScriptURLEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureTokenGenerationScriptURLEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureTokenGenerationScriptURLEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureTokenGenerationScriptURLEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureTokenGenerationScriptURLEvent represents a TokenGenerationScriptURLEvent event raised by the ICosmicSignature contract.
type ICosmicSignatureTokenGenerationScriptURLEvent struct {
	NewURL string
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterTokenGenerationScriptURLEvent is a free log retrieval operation binding the contract event 0x0119741ee0f95fab26124262a82c3c0e9e1c7ff4bb33c6fba5f3b11c9b6d0bad.
//
// Solidity: event TokenGenerationScriptURLEvent(string newURL)
func (_ICosmicSignature *ICosmicSignatureFilterer) FilterTokenGenerationScriptURLEvent(opts *bind.FilterOpts) (*ICosmicSignatureTokenGenerationScriptURLEventIterator, error) {

	logs, sub, err := _ICosmicSignature.contract.FilterLogs(opts, "TokenGenerationScriptURLEvent")
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureTokenGenerationScriptURLEventIterator{contract: _ICosmicSignature.contract, event: "TokenGenerationScriptURLEvent", logs: logs, sub: sub}, nil
}

// WatchTokenGenerationScriptURLEvent is a free log subscription operation binding the contract event 0x0119741ee0f95fab26124262a82c3c0e9e1c7ff4bb33c6fba5f3b11c9b6d0bad.
//
// Solidity: event TokenGenerationScriptURLEvent(string newURL)
func (_ICosmicSignature *ICosmicSignatureFilterer) WatchTokenGenerationScriptURLEvent(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureTokenGenerationScriptURLEvent) (event.Subscription, error) {

	logs, sub, err := _ICosmicSignature.contract.WatchLogs(opts, "TokenGenerationScriptURLEvent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureTokenGenerationScriptURLEvent)
				if err := _ICosmicSignature.contract.UnpackLog(event, "TokenGenerationScriptURLEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTokenGenerationScriptURLEvent is a log parse operation binding the contract event 0x0119741ee0f95fab26124262a82c3c0e9e1c7ff4bb33c6fba5f3b11c9b6d0bad.
//
// Solidity: event TokenGenerationScriptURLEvent(string newURL)
func (_ICosmicSignature *ICosmicSignatureFilterer) ParseTokenGenerationScriptURLEvent(log types.Log) (*ICosmicSignatureTokenGenerationScriptURLEvent, error) {
	event := new(ICosmicSignatureTokenGenerationScriptURLEvent)
	if err := _ICosmicSignature.contract.UnpackLog(event, "TokenGenerationScriptURLEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureTokenNameEventIterator is returned from FilterTokenNameEvent and is used to iterate over the raw logs and unpacked data for TokenNameEvent events raised by the ICosmicSignature contract.
type ICosmicSignatureTokenNameEventIterator struct {
	Event *ICosmicSignatureTokenNameEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureTokenNameEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureTokenNameEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureTokenNameEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureTokenNameEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureTokenNameEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureTokenNameEvent represents a TokenNameEvent event raised by the ICosmicSignature contract.
type ICosmicSignatureTokenNameEvent struct {
	TokenId *big.Int
	NewName string
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterTokenNameEvent is a free log retrieval operation binding the contract event 0x8ad5e159ff95649c8a9f323ac5a457e741897cf44ce07dfce0e98b84ef9d5f12.
//
// Solidity: event TokenNameEvent(uint256 indexed tokenId, string newName)
func (_ICosmicSignature *ICosmicSignatureFilterer) FilterTokenNameEvent(opts *bind.FilterOpts, tokenId []*big.Int) (*ICosmicSignatureTokenNameEventIterator, error) {

	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _ICosmicSignature.contract.FilterLogs(opts, "TokenNameEvent", tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureTokenNameEventIterator{contract: _ICosmicSignature.contract, event: "TokenNameEvent", logs: logs, sub: sub}, nil
}

// WatchTokenNameEvent is a free log subscription operation binding the contract event 0x8ad5e159ff95649c8a9f323ac5a457e741897cf44ce07dfce0e98b84ef9d5f12.
//
// Solidity: event TokenNameEvent(uint256 indexed tokenId, string newName)
func (_ICosmicSignature *ICosmicSignatureFilterer) WatchTokenNameEvent(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureTokenNameEvent, tokenId []*big.Int) (event.Subscription, error) {

	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _ICosmicSignature.contract.WatchLogs(opts, "TokenNameEvent", tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureTokenNameEvent)
				if err := _ICosmicSignature.contract.UnpackLog(event, "TokenNameEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTokenNameEvent is a log parse operation binding the contract event 0x8ad5e159ff95649c8a9f323ac5a457e741897cf44ce07dfce0e98b84ef9d5f12.
//
// Solidity: event TokenNameEvent(uint256 indexed tokenId, string newName)
func (_ICosmicSignature *ICosmicSignatureFilterer) ParseTokenNameEvent(log types.Log) (*ICosmicSignatureTokenNameEvent, error) {
	event := new(ICosmicSignatureTokenNameEvent)
	if err := _ICosmicSignature.contract.UnpackLog(event, "TokenNameEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the ICosmicSignature contract.
type ICosmicSignatureTransferIterator struct {
	Event *ICosmicSignatureTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureTransfer represents a Transfer event raised by the ICosmicSignature contract.
type ICosmicSignatureTransfer struct {
	From    common.Address
	To      common.Address
	TokenId *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_ICosmicSignature *ICosmicSignatureFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenId []*big.Int) (*ICosmicSignatureTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _ICosmicSignature.contract.FilterLogs(opts, "Transfer", fromRule, toRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureTransferIterator{contract: _ICosmicSignature.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_ICosmicSignature *ICosmicSignatureFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureTransfer, from []common.Address, to []common.Address, tokenId []*big.Int) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _ICosmicSignature.contract.WatchLogs(opts, "Transfer", fromRule, toRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureTransfer)
				if err := _ICosmicSignature.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_ICosmicSignature *ICosmicSignatureFilterer) ParseTransfer(log types.Log) (*ICosmicSignatureTransfer, error) {
	event := new(ICosmicSignatureTransfer)
	if err := _ICosmicSignature.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
