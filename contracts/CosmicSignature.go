// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package contracts

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// CosmicSignatureMetaData contains all meta data concerning the CosmicSignature contract.
var CosmicSignatureMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_cosmicGameProxyContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ERC721EnumerableForbiddenBatchMint\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ERC721IncorrectOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ERC721InsufficientApproval\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"ERC721InvalidApprover\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"ERC721InvalidOperator\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ERC721InvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ERC721InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ERC721InvalidSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ERC721NonexistentToken\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"ERC721OutOfBoundsIndex\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"errStr\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"}],\"name\":\"NoMintPrivileges\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"errStr\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"OwnershipError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"errStr\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"len\",\"type\":\"uint256\"}],\"name\":\"TokenNameLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"errStr\",\"type\":\"string\"}],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newURI\",\"type\":\"string\"}],\"name\":\"BaseURIEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"seed\",\"type\":\"bytes32\"}],\"name\":\"MintEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newURL\",\"type\":\"string\"}],\"name\":\"TokenGenerationScriptURLEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"}],\"name\":\"TokenNameEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cosmicGameProxyContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"entropy\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roundNum\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"seeds\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newTokenGenerationScriptURL\",\"type\":\"string\"}],\"name\":\"setTokenGenerationScriptURL\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"setTokenName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenGenerationScriptURL\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenNames\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x60a06040523461003f57610019610014610104565b6105c8565b610021610044565b6132606109bd8239608051818181610ab90152611516015261326090f35b61004a565b60405190565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b906100769061004e565b810190811060018060401b0382111761008e57604052565b610058565b906100a661009f610044565b928361006c565b565b5f80fd5b60018060a01b031690565b6100c0906100ac565b90565b6100cc816100b7565b036100d357565b5f80fd5b905051906100e4826100c3565b565b906020828203126100ff576100fc915f016100d7565b90565b6100a8565b610122613c1d8038038061011781610093565b9283398101906100e6565b90565b60018060401b0381116101415761013d60209161004e565b0190565b610058565b9061015861015383610125565b610093565b918252565b5f7f436f736d69635369676e61747572650000000000000000000000000000000000910152565b61018e600f610146565b9061019b6020830161015d565b565b6101a5610184565b90565b5f7f4353530000000000000000000000000000000000000000000000000000000000910152565b6101d96003610146565b906101e6602083016101a8565b565b6101f06101cf565b90565b5f1b90565b906102045f19916101f3565b9181191691161790565b90565b90565b90565b61022b6102266102309261020e565b610214565b610211565b90565b90565b9061024b61024661025292610217565b610233565b82546101f8565b9055565b634e487b7160e01b5f52602260045260245ffd5b906001600283049216801561028a575b602083101461028557565b610256565b91607f169161027a565b5f5260205f2090565b601f602091010490565b1b90565b919060086102c69102916102c05f19846102a7565b926102a7565b9181191691161790565b6102e46102df6102e992610211565b610214565b610211565b90565b91906103026102fd61030a936102d0565b610233565b9083546102ab565b9055565b5f90565b6103249161031e61030e565b916102ec565b565b5b818110610332575050565b8061033f5f600193610312565b01610327565b9190601f8111610355575b505050565b61036161038693610294565b90602061036d8461029d565b8301931061038e575b61037f9061029d565b0190610326565b5f8080610350565b915061037f81929050610376565b6103b1600a6103ab835461026a565b83610345565b60147f697066733a2f2f54424400000000000000000000000000000000000000000000019055565b6103e29061039c565b565b6103f86103f36103fd9261020e565b610214565b6100ac565b90565b610409906103e4565b90565b60209181520190565b5f7f5a65726f2d616464726573732077617320676976656e2e000000000000000000910152565b610449601760209261040c565b61045281610415565b0190565b61046b9060208101905f81830391015261043c565b90565b1561047557565b61047d610044565b63eac0d38960e01b81528061049460048201610456565b0390fd5b90565b6104af6104aa6104b492610498565b610214565b610211565b90565b634e487b7160e01b5f52601160045260245ffd5b6104da6104e091939293610211565b92610211565b82039182116104eb57565b6104b7565b5f7f6e65774e46540000000000000000000000000000000000000000000000000000910152565b610524600660209261040c565b61052d816104f0565b0190565b61053a90610211565b9052565b90565b61054a9061053e565b9052565b91604061057f92949361057861056d606083018381035f850152610517565b966020830190610531565b0190610541565b565b60200190565b5190565b6105949061053e565b90565b5f1c90565b6105a590610597565b90565b906105bd6105b86105c49261058b565b61059c565b82546101f8565b9055565b6105e96105d36108ab565b6105db61019d565b6105e36101e8565b91610685565b6105f45f600e610236565b6105fe60106103d9565b6106238161061c6106166106115f610400565b6100b7565b916100b7565b141561046e565b6106804261066661063e43610638600161049b565b906104cb565b409161065761064b610044565b9384926020840161054e565b6020820181038252038261006c565b61067861067282610587565b91610581565b20600d6105a8565b608052565b9061069092916106b4565b565b61069b906100b7565b9052565b91906106b2905f60208501940190610692565b565b916106be91610710565b806106d96106d36106ce5f610400565b6100b7565b916100b7565b146106e9576106e79061095b565b565b61070c6106f55f610400565b5f918291631e4fbdf760e01b83526004830161069f565b0390fd5b9061071a9161071c565b565b9061072691610890565b565b5190565b5f5260205f2090565b9190601f8111610745575b505050565b6107516107769361072c565b90602061075d8461029d565b8301931061077e575b61076f9061029d565b0190610326565b5f8080610740565b915061076f81929050610766565b1c90565b906107a0905f199060080261078c565b191690565b816107af91610790565b906002021790565b906107c181610728565b9060018060401b03821161087f576107e3826107dd855461026a565b85610735565b602090601f831160011461081757918091610806935f9261080b575b50506107a5565b90555b565b90915001515f806107ff565b601f198316916108268561072c565b925f5b8181106108675750916002939185600196941061084d575b50505002019055610809565b61085d910151601f841690610790565b90555f8080610841565b91936020600181928787015181550195019201610829565b610058565b9061088e916107b7565b565b9061089e6108a5925f610884565b6001610884565b565b5f90565b6108b36108a7565b503390565b60018060a01b031690565b6108cf6108d491610597565b6108b8565b90565b6108e190546108c3565b90565b906108f560018060a01b03916101f3565b9181191691161790565b61091361090e610918926100ac565b610214565b6100ac565b90565b610924906108ff565b90565b6109309061091b565b90565b90565b9061094b61094661095292610927565b610933565b82546108e4565b9055565b5f0190565b610965600a6108d7565b61097082600a610936565b906109a461099e7f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e093610927565b91610927565b916109ad610044565b806109b781610956565b0390a356fe60806040526004361015610013575b610f69565b61001d5f356101ec565b806301ffc9a7146101e757806306fdde03146101e2578063081812fc146101dd578063095ea7b3146101d857806318160ddd146101d357806323b872dd146101ce5780632f745c59146101c9578063310495ab146101c457806340c10f19146101bf57806342842e0e146101ba57806346519a18146101b557806347ce07cc146101b05780634f6ccce7146101ab57806355f804b3146101a65780636352211e146101a157806370a082311461019c578063715018a6146101975780637722620d146101925780638da5cb5b1461018d5780638e499bcf1461018857806395d89b4114610183578063a22cb4651461017e578063b88d4fde14610179578063c87b56dd14610174578063cdb0e89e1461016f578063de9d90bc1461016a578063e985e9c514610165578063f0503e80146101605763f2fde38b0361000e57610f36565b610f01565b610e9c565b610e3a565b610df7565b610d7d565b610d46565b610c37565b610bb2565b610b7d565b610b10565b610adb565b610a84565b610a4f565b6109fc565b6109c9565b610994565b61095f565b6108cb565b6107be565b610788565b610753565b61055c565b610528565b6104b9565b610463565b6103d9565b610327565b610278565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b63ffffffff60e01b1690565b61021981610204565b0361022057565b5f80fd5b9050359061023182610210565b565b9060208282031261024c57610249915f01610224565b90565b6101fc565b151590565b61025f90610251565b9052565b9190610276905f60208501940190610256565b565b346102a8576102a461029361028e366004610233565b610f71565b61029b6101f2565b91829182610263565b0390f35b6101f8565b5f9103126102b757565b6101fc565b5190565b60209181520190565b90825f9392825e0152565b601f801991011690565b6102fd61030660209361030b936102f4816102bc565b938480936102c0565b958691016102c9565b6102d4565b0190565b6103249160208201915f8184039101526102de565b90565b34610357576103373660046102ad565b610353610342610fc2565b61034a6101f2565b9182918261030f565b0390f35b6101f8565b90565b6103688161035c565b0361036f57565b5f80fd5b905035906103808261035f565b565b9060208282031261039b57610398915f01610373565b90565b6101fc565b60018060a01b031690565b6103b4906103a0565b90565b6103c0906103ab565b9052565b91906103d7905f602085019401906103b7565b565b34610409576104056103f46103ef366004610382565b610fdb565b6103fc6101f2565b918291826103c4565b0390f35b6101f8565b610417816103ab565b0361041e57565b5f80fd5b9050359061042f8261040e565b565b9190604083820312610459578061044d610456925f8601610422565b93602001610373565b90565b6101fc565b5f0190565b346104925761047c610476366004610431565b90610ffa565b6104846101f2565b8061048e8161045e565b0390f35b6101f8565b6104a09061035c565b9052565b91906104b7905f60208501940190610497565b565b346104e9576104c93660046102ad565b6104e56104d4611018565b6104dc6101f2565b918291826104a4565b0390f35b6101f8565b909160608284031261052357610520610509845f8501610422565b936105178160208601610422565b93604001610373565b90565b6101fc565b346105575761054161053b3660046104ee565b9161108b565b6105496101f2565b806105538161045e565b0390f35b6101f8565b3461058d57610589610578610572366004610431565b906111cf565b6105806101f2565b918291826104a4565b0390f35b6101f8565b90565b6105a96105a46105ae9261035c565b610592565b61035c565b90565b906105bb90610595565b5f5260205260405f2090565b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52602260045260245ffd5b906001600283049216801561060e575b602083101461060957565b6105da565b91607f16916105fe565b60209181520190565b5f5260205f2090565b905f929180549061064461063d836105ee565b8094610618565b916001811690815f1461069b575060011461065f575b505050565b61066c9192939450610621565b915f925b81841061068357505001905f808061065a565b60018160209295939554848601520191019290610670565b92949550505060ff19168252151560200201905f808061065a565b906106c09161062a565b90565b634e487b7160e01b5f52604160045260245ffd5b906106e1906102d4565b810190811067ffffffffffffffff8211176106fb57604052565b6106c3565b90610720610719926107106101f2565b938480926106b6565b03836106d7565b565b905f106107355761073290610700565b90565b6105c7565b6107509061074b600c915f926105b1565b610722565b90565b346107835761077f61076e610769366004610382565b61073a565b6107766101f2565b9182918261030f565b0390f35b6101f8565b346107b9576107b56107a461079e366004610431565b906114d5565b6107ac6101f2565b918291826104a4565b0390f35b6101f8565b346107ed576107d76107d13660046104ee565b9161169b565b6107df6101f2565b806107e98161045e565b0390f35b6101f8565b5f80fd5b5f80fd5b9061080d6108066101f2565b92836106d7565b565b67ffffffffffffffff811161082d576108296020916102d4565b0190565b6106c3565b90825f939282370152565b9092919261085261084d8261080f565b6107fa565b9381855260208501908284011161086e5761086c92610832565b565b6107f6565b9080601f830112156108915781602061088e9335910161083d565b90565b6107f2565b906020828203126108c6575f82013567ffffffffffffffff81116108c1576108be9201610873565b90565b610200565b6101fc565b346108f9576108e36108de366004610896565b6118eb565b6108eb6101f2565b806108f58161045e565b0390f35b6101f8565b1c90565b90565b61091590600861091a93026108fe565b610902565b90565b906109289154610905565b90565b610937600d5f9061091d565b90565b90565b6109469061093a565b9052565b919061095d905f6020850194019061093d565b565b3461098f5761096f3660046102ad565b61098b61097a61092b565b6109826101f2565b9182918261094a565b0390f35b6101f8565b346109c4576109c06109af6109aa366004610382565b61193b565b6109b76101f2565b918291826104a4565b0390f35b6101f8565b346109f7576109e16109dc366004610896565b6119fb565b6109e96101f2565b806109f38161045e565b0390f35b6101f8565b34610a2c57610a28610a17610a12366004610382565b611a06565b610a1f6101f2565b918291826103c4565b0390f35b6101f8565b90602082820312610a4a57610a47915f01610422565b90565b6101fc565b34610a7f57610a7b610a6a610a65366004610a31565b611a31565b610a726101f2565b918291826104a4565b0390f35b6101f8565b34610ab257610a943660046102ad565b610a9c611abc565b610aa46101f2565b80610aae8161045e565b0390f35b6101f8565b7f000000000000000000000000000000000000000000000000000000000000000090565b34610b0b57610aeb3660046102ad565b610b07610af6610ab7565b610afe6101f2565b918291826103c4565b0390f35b6101f8565b34610b4057610b203660046102ad565b610b3c610b2b611af2565b610b336101f2565b918291826103c4565b0390f35b6101f8565b90565b610b58906008610b5d93026108fe565b610b45565b90565b90610b6b9154610b48565b90565b610b7a600e5f90610b60565b90565b34610bad57610b8d3660046102ad565b610ba9610b98610b6e565b610ba06101f2565b918291826104a4565b0390f35b6101f8565b34610be257610bc23660046102ad565b610bde610bcd611b08565b610bd56101f2565b9182918261030f565b0390f35b6101f8565b610bf081610251565b03610bf757565b5f80fd5b90503590610c0882610be7565b565b9190604083820312610c325780610c26610c2f925f8601610422565b93602001610bfb565b90565b6101fc565b34610c6657610c50610c4a366004610c0a565b90611b1e565b610c586101f2565b80610c628161045e565b0390f35b6101f8565b67ffffffffffffffff8111610c8957610c856020916102d4565b0190565b6106c3565b90929192610ca3610c9e82610c6b565b6107fa565b93818552602085019082840111610cbf57610cbd92610832565b565b6107f6565b9080601f83011215610ce257816020610cdf93359101610c8e565b90565b6107f2565b90608082820312610d4157610cfe815f8401610422565b92610d0c8260208501610422565b92610d1a8360408301610373565b92606082013567ffffffffffffffff8111610d3c57610d399201610cc4565b90565b610200565b6101fc565b34610d7857610d62610d59366004610ce7565b92919091611b34565b610d6a6101f2565b80610d748161045e565b0390f35b6101f8565b34610dad57610da9610d98610d93366004610382565b611bee565b610da06101f2565b9182918261030f565b0390f35b6101f8565b919091604081840312610df257610dcb835f8301610373565b92602082013567ffffffffffffffff8111610ded57610dea9201610873565b90565b610200565b6101fc565b34610e2657610e10610e0a366004610db2565b90611dc7565b610e186101f2565b80610e228161045e565b0390f35b6101f8565b610e3760105f90610722565b90565b34610e6a57610e4a3660046102ad565b610e66610e55610e2b565b610e5d6101f2565b9182918261030f565b0390f35b6101f8565b9190604083820312610e975780610e8b610e94925f8601610422565b93602001610422565b90565b6101fc565b34610ecd57610ec9610eb8610eb2366004610e6f565b90611ed8565b610ec06101f2565b91829182610263565b0390f35b6101f8565b90610edc90610595565b5f5260205260405f2090565b610efe90610ef9600b915f92610ed2565b61091d565b90565b34610f3157610f2d610f1c610f17366004610382565b610ee8565b610f246101f2565b9182918261094a565b0390f35b6101f8565b34610f6457610f4e610f49366004610a31565b611f65565b610f566101f2565b80610f608161045e565b0390f35b6101f8565b5f80fd5b5f90565b610f79610f6d565b5080610f94610f8e63780e9d6360e01b610204565b91610204565b14908115610fa1575b5090565b610fab9150611f70565b5f610f9d565b606090565b610fbf90610700565b90565b610fca610fb1565b50610fd45f610fb6565b90565b5f90565b610ff790610fe7610fd7565b50610ff181611fd8565b50612044565b90565b9061100e9190611008612063565b91612070565b565b5f90565b5490565b611020611010565b5061102b6008611014565b90565b90565b61104561104061104a9261102e565b610592565b6103a0565b90565b61105690611031565b90565b604090611082611089949695939661107860608401985f8501906103b7565b6020830190610497565b01906103b7565b565b9190806110a86110a261109d5f61104d565b6103ab565b916103ab565b146110ff576110c090826110ba612063565b91612080565b91826110d46110ce836103ab565b916103ab565b036110de57505050565b6110fb9091925f9384936364283d7b60e01b855260048501611059565b0390fd5b61112261110b5f61104d565b5f918291633250574960e11b8352600483016103c4565b0390fd5b91602061114792949361114060408201965f8301906103b7565b0190610497565b565b61115d611158611162926103a0565b610592565b6103a0565b90565b61116e90611149565b90565b61117a90611165565b90565b9061118790611171565b5f5260205260405f2090565b9061119d90610595565b5f5260205260405f2090565b5f1c90565b6111ba6111bf916111a9565b610b45565b90565b6111cc90546111ae565b90565b6111d7611010565b50816111f36111ed6111e884611a31565b61035c565b9161035c565b1015611218576112159161120b61121092600661117d565b611193565b6111c2565b90565b6112325f92839263295f44f760e21b845260048401611126565b0390fd5b5f7f5a65726f2d616464726573732077617320676976656e2e000000000000000000910152565b61126a60176020926102c0565b61127381611236565b0190565b61128c9060208101905f81830391015261125d565b90565b1561129657565b61129e6101f2565b63eac0d38960e01b8152806112b560048201611277565b0390fd5b60207f74206973207065726d697474656420746f206d696e742e000000000000000000917f4f6e6c792074686520436f736d696347616d6550726f787920636f6e747261635f8201520152565b61131360376040926102c0565b61131c816112b9565b0190565b919061134390602061133b604086018681035f880152611306565b9401906103b7565b565b1561134d5750565b61136f906113596101f2565b91829163173fda8d60e21b835260048301611320565b0390fd5b634e487b7160e01b5f52601160045260245ffd5b6113909061035c565b5f19811461139e5760010190565b611373565b5f1b90565b906113b45f19916113a3565b9181191691161790565b90565b906113d66113d16113dd92610595565b6113be565b82546113a8565b9055565b6113ed6113f2916111a9565b610902565b90565b6113ff90546113e1565b90565b90565b61141961141461141e92611402565b610592565b61035c565b90565b6114306114369193929361035c565b9261035c565b820391821161144157565b611373565b909594926114919461148061148a9261147660809661146c60a088019c5f89019061093d565b6020870190610497565b604085019061093d565b6060830190610497565b01906103b7565b565b60200190565b5190565b6114a69061093a565b90565b6114b2906111a9565b90565b906114ca6114c56114d19261149d565b6114a9565b82546113a8565b9055565b6114dd611010565b50611503816114fc6114f66114f15f61104d565b6103ab565b916103ab565b141561128f565b61154f61150e612063565b61154061153a7f00000000000000000000000000000000000000000000000000000000000000006103ab565b916103ab565b14611549612063565b90611345565b611559600e6111c2565b9161157661156f61156a600e6111c2565b611387565b600e6113c1565b6115e0611583600d6113f5565b6115c642916115b761159f436115996001611405565b90611421565b408888916115ab6101f2565b96879560208701611446565b602082018103825203826106d7565b6115d86115d282611499565b91611493565b20600d6114b5565b6115fe6115ed600d6113f5565b6115f9600b8690610ed2565b6114b5565b611609828490612154565b8291611615600d6113f5565b9261166761165561164f6116497fc646da88dc2b2526461a0ebb4326e2418ec0bea89496b632b7c9ee42fbfe1d4d94610595565b94611171565b94610595565b9461165e6101f2565b9182918261094a565b0390a490565b9061167f61167a8361080f565b6107fa565b918252565b61168d5f61166d565b90565b611698611684565b90565b916116af92916116a9611690565b92611b34565b565b6116c2906116bd6121f8565b6118a5565b565b601f602091010490565b1b90565b919060086116ed9102916116e75f19846116ce565b926116ce565b9181191691161790565b919061170d61170861171593610595565b6113be565b9083546116d2565b9055565b61172b91611725611010565b916116f7565b565b5b818110611739575050565b806117465f600193611719565b0161172e565b9190601f811161175c575b505050565b61176861178d93610621565b906020611774846116c4565b83019310611795575b611786906116c4565b019061172d565b5f8080611757565b91506117868192905061177d565b906117b3905f19906008026108fe565b191690565b816117c2916117a3565b906002021790565b906117d4816102bc565b9067ffffffffffffffff8211611894576117f8826117f285546105ee565b8561174c565b602090601f831160011461182c5791809161181b935f92611820575b50506117b8565b90555b565b90915001515f80611814565b601f1983169161183b85610621565b925f5b81811061187c57509160029391856001969410611862575b5050500201905561181e565b611872910151601f8416906117a3565b90555f8080611856565b9193602060018192878701518155019501920161183e565b6106c3565b906118a3916117ca565b565b6118b0816010611899565b6118e67f0119741ee0f95fab26124262a82c3c0e9e1c7ff4bb33c6fba5f3b11c9b6d0bad916118dd6101f2565b9182918261030f565b0390a1565b6118f4906116b1565b565b634e487b7160e01b5f52603260045260245ffd5b5f5260205f2090565b61191c81611014565b8210156119365761192e60019161190a565b910201905f90565b6118f6565b611943611010565b508061195e611958611953611018565b61035c565b9161035c565b101561197b57611972611978916008611913565b90610b60565b90565b6119845f61104d565b61199e5f92839263295f44f760e21b845260048401611126565b0390fd5b6119b3906119ae6121f8565b6119b5565b565b6119c081600f611899565b6119f67f2fc013f885e8a815b9d697da28bc143b4dced47528c41b46e2b35fd0f4be718c916119ed6101f2565b9182918261030f565b0390a1565b611a04906119a2565b565b611a1890611a12610fd7565b50611fd8565b90565b90611a2590611171565b5f5260205260405f2090565b611a39611010565b5080611a55611a4f611a4a5f61104d565b6103ab565b916103ab565b14611a7057611a68611a6d916003611a1b565b6111c2565b90565b611a93611a7c5f61104d565b5f9182916322718ad960e21b8352600483016103c4565b0390fd5b611a9f6121f8565b611aa7611aa9565b565b611aba611ab55f61104d565b612284565b565b611ac4611a97565b565b60018060a01b031690565b611add611ae2916111a9565b611ac6565b90565b611aef9054611ad1565b90565b611afa610fd7565b50611b05600a611ae5565b90565b611b10610fb1565b50611b1b6001610fb6565b90565b611b3291611b2a612063565b91909161232a565b565b91611b50939192611b478185849161108b565b929091926124f4565b565b90565b611b69611b64611b6e9261102e565b610592565b61035c565b90565b611b79611684565b90565b905090565b611ba6611b9d92602092611b94816102bc565b94858093611b7c565b938491016102c9565b0190565b611bb890611bbe9392611b81565b90611b81565b90565b611be09291611bec91611bd26101f2565b948592602084019283611baa565b908103825203836106d7565b565b611bf6610fb1565b50611c0081611fd8565b50611c0961264f565b90611c1b611c1683611b52565b611499565b611c2d611c275f611b55565b9161035c565b115f14611c4b57611c41611c479291612703565b90611bc1565b5b90565b5050611c55611b71565b611c48565b60207f72697a65642e0000000000000000000000000000000000000000000000000000917f736574546f6b656e4e616d652063616c6c6572206973206e6f7420617574686f5f8201520152565b611cb460266040926102c0565b611cbd81611c5a565b0190565b9190611ce4906020611cdc604086018681035f880152611ca7565b940190610497565b565b15611cee5750565b611d1090611cfa6101f2565b918291632b03cbb360e21b835260048301611cc1565b0390fd5b90565b611d2b611d26611d3092611d14565b610592565b61035c565b90565b5f7f546f6b656e206e616d6520697320746f6f206c6f6e672e000000000000000000910152565b611d6760176020926102c0565b611d7081611d33565b0190565b9190611d97906020611d8f604086018681035f880152611d5a565b940190610497565b565b15611da15750565b611dc390611dad6101f2565b918291635e8b1f5160e11b835260048301611d74565b0390fd5b611dec611de5611dd6836127ac565b611dde612063565b84916127cb565b8290611ce6565b611e2c611e00611dfb84611b52565b611499565b611e13611e0d6020611d17565b9161035c565b1115611e26611e2185611b52565b611499565b90611d99565b611e4182611e3c600c84906105b1565b611899565b611e80611e6e7f8ad5e159ff95649c8a9f323ac5a457e741897cf44ce07dfce0e98b84ef9d5f1292610595565b92611e776101f2565b9182918261030f565b0390a2565b90611e8f90611171565b5f5260205260405f2090565b90611ea590611171565b5f5260205260405f2090565b60ff1690565b611ec3611ec8916111a9565b611eb1565b90565b611ed59054611eb7565b90565b611efd91611ef3611ef892611eeb610f6d565b506005611e85565b611e9b565b611ecb565b90565b611f1190611f0c6121f8565b611f13565b565b80611f2e611f28611f235f61104d565b6103ab565b916103ab565b14611f3e57611f3c90612284565b565b611f61611f4a5f61104d565b5f918291631e4fbdf760e01b8352600483016103c4565b0390fd5b611f6e90611f00565b565b611f78610f6d565b5080611f93611f8d6380ac58cd60e01b610204565b91610204565b148015611fb7575b908115611fa7575b5090565b611fb1915061286b565b5f611fa3565b5080611fd2611fcc635b5e139f60e01b610204565b91610204565b14611f9b565b611fe0610fd7565b50611fea816127ac565b9081612006612000611ffb5f61104d565b6103ab565b916103ab565b1461200f575090565b61202a905f918291637e27328960e01b8352600483016104a4565b0390fd5b9061203890610595565b5f5260205260405f2090565b61205b61206091612053610fd7565b50600461202e565b611ae5565b90565b61206b610fd7565b503390565b9161207e9291600192612891565b565b90916120999061208e610fd7565b5082908490916129e9565b91826120b56120af6120aa5f61104d565b6103ab565b916103ab565b145f14612126576120c581612c99565b5b816120e16120db6120d65f61104d565b6103ab565b916103ab565b145f146120f6576120f29150612d61565b5b90565b82612109612103846103ab565b916103ab565b03612116575b50506120f3565b61211f91612ccc565b5f8061210f565b82612139612133846103ab565b916103ab565b03612144575b6120c6565b61214f838290612b6a565b61213f565b908161217061216a6121655f61104d565b6103ab565b916103ab565b146121d15761218991906121835f61104d565b91612080565b6121a361219d6121985f61104d565b6103ab565b916103ab565b036121aa57565b6121cd6121b65f61104d565b5f9182916339e3563760e11b8352600483016103c4565b0390fd5b6121f46121dd5f61104d565b5f918291633250574960e11b8352600483016103c4565b0390fd5b612200611af2565b61221961221361220e612063565b6103ab565b916103ab565b0361222057565b61224261222b612063565b5f91829163118cdaa760e01b8352600483016103c4565b0390fd5b9061225760018060a01b03916113a3565b9181191691161790565b90565b9061227961227461228092611171565b612261565b8254612246565b9055565b61228e600a611ae5565b61229982600a612264565b906122cd6122c77f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e093611171565b91611171565b916122d66101f2565b806122e08161045e565b0390a3565b906122f160ff916113a3565b9181191691161790565b61230490610251565b90565b90565b9061231f61231a612326926122fb565b612307565b82546122e5565b9055565b9190918261234861234261233d5f61104d565b6103ab565b916103ab565b146123bc5761236c8261236761236060058590611e85565b8690611e9b565b61230a565b9190916123b76123a561239f7f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c3193611171565b93611171565b936123ae6101f2565b91829182610263565b0390a3565b6123d7835f918291630b61174360e31b8352600483016103c4565b0390fd5b6123e490611149565b90565b6123f0906123db565b90565b6123fc90611165565b90565b60e01b90565b9050519061241282610210565b565b9060208282031261242d5761242a915f01612405565b90565b6101fc565b60209181520190565b61245a6124636020936124689361245181611499565b93848093612432565b958691016102c9565b6102d4565b0190565b909261249f906124956124ac969461248b60808601975f8701906103b7565b60208501906103b7565b6040830190610497565b606081840391015261243b565b90565b906124c16124bc83610c6b565b6107fa565b918252565b606090565b3d5f146124e6576124db3d6124af565b903d5f602084013e5b565b6124ee6124c6565b906124e4565b929092833b61250b6125055f611b55565b9161035c565b11612517575b50505050565b6020916125575f61252f61252a886123e7565b6123f3565b9261256263150b7a0291612541612063565b969861254b6101f2565b998a98899788966123ff565b86526004860161246c565b03925af180915f9261261f575b50155f146125dc5750600161258957505b5f808080612511565b6125916124cb565b9061259b82611499565b6125ad6125a75f611b55565b9161035c565b145f146125d3576125cf905f918291633250574960e11b8352600483016103c4565b0390fd5b50805190602001fd5b6125f56125ef630a85bd0160e11b610204565b91610204565b036126005750612580565b61261b905f918291633250574960e11b8352600483016103c4565b0390fd5b61264191925060203d8111612648575b61263981836106d7565b810190612414565b905f61256f565b503d61262f565b612657610fb1565b50612662600f610fb6565b90565b90612670910161035c565b90565b369037565b9061269d6126858361166d565b92602080612693869361080f565b9201910390612673565b565b60016126ab910361035c565b90565b90565b6126c56126c06126ca926126ae565b610592565b61035c565b90565b634e487b7160e01b5f52601260045260245ffd5b6126ed6126f39161035c565b9161035c565b9081156126fe570490565b6126cd565b61270b610fb1565b5061272861271882612f4d565b6127226001611405565b90612665565b9061273282612678565b9161273b611010565b5060200182015b6001156127a5576127556127819161269f565b916f181899199a1a9b1b9c1cb0b131b232b360811b600a82061a835361277b600a6126b1565b906126e1565b8061279461278e5f611b55565b9161035c565b1461279f5790612742565b50505b90565b50506127a2565b6127c36127c8916127bb610fd7565b50600261202e565b611ae5565b90565b91906127d5610f6d565b50806127f16127eb6127e65f61104d565b6103ab565b916103ab565b14159283612800575b50505090565b8091929350612817612811846103ab565b916103ab565b14908115612859575b50918215612833575b50505f80806127fa565b61285191925061284561284b91612044565b926103ab565b916103ab565b145f80612829565b61286591508290611ed8565b5f612820565b612873610f6d565b5061288d6128876301ffc9a760e01b610204565b91610204565b1490565b9190928080156129b8575b6128ba575b5050906128b36128b89291600461202e565b612264565b565b6128c384611fd8565b91806128df6128d96128d45f61104d565b6103ab565b916103ab565b14158061299d575b80612983575b6129645750916128b3916128b89493612909575b5091926128a1565b81849061294861294261293c7f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92595611171565b92611171565b92610595565b926129516101f2565b8061295b8161045e565b0390a45f612901565b61297f905f91829163a9fbf51f60e01b8352600483016103c4565b0390fd5b50612998612992848390611ed8565b15610251565b6128ed565b50826129b16129ab836103ab565b916103ab565b14156128e7565b50816129d46129ce6129c95f61104d565b6103ab565b916103ab565b141561289c565b906129e6910361035c565b90565b906129f2610fd7565b506129fc816127ac565b9280612a18612a12612a0d5f61104d565b6103ab565b916103ab565b03612b57575b5082612a3a612a34612a2f5f61104d565b6103ab565b916103ab565b03612b03575b81612a5b612a55612a505f61104d565b6103ab565b916103ab565b03612acd575b612a7682612a716002849061202e565b612264565b8291612ab4612aae612aa87fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef95611171565b92611171565b92610595565b92612abd6101f2565b80612ac78161045e565b0390a490565b612afe612ada6001611405565b612af8612ae960038690611a1b565b91612af3836111c2565b612665565b906113c1565b612a61565b612b21612b0f5f61104d565b82612b195f61104d565b905f92612891565b612b52612b2e6001611405565b612b4c612b3d60038790611a1b565b91612b47836111c2565b6129db565b906113c1565b612a40565b612b6490849083916131ae565b5f612a1e565b612bcd612bd292612bc85f93612bc185612bbc612b8684611a31565b95612b9b612b9660078390611193565b6111c2565b80612bae612ba88a61035c565b9161035c565b03612bd4575b506007611193565b611719565b600661117d565b611193565b611719565b565b612c2690612c21612bf9612bf4612bed60068b9061117d565b8c90611193565b6111c2565b91612c1983612c14612c0d60068d9061117d565b8490611193565b6113c1565b916007611193565b6113c1565b5f612bb4565b90565b5f5260205f2090565b5490565b612c4581612c38565b821015612c5f57612c57600191612c2f565b910201905f90565b6118f6565b9081549168010000000000000000831015612c945782612c8c916001612c9295018155612c3c565b906116f7565b565b6106c3565b612cca90612cbb612caa6008611014565b612cb660098490611193565b6113c1565b612cc56008612c2c565b612c64565b565b90612d17612d1c92612d0f612cf3612ce383611a31565b612ced6001611405565b90611421565b91612d0a612d038692600661117d565b8490611193565b6113c1565b916007611193565b6113c1565b565b634e487b7160e01b5f52603160045260245ffd5b612d3b81612c38565b8015612d5c576001900390612d59612d538383612c3c565b90611719565b55565b612d1e565b5f612ddf612de492612dd8612d89612d796008611014565b612d836001611405565b90611421565b612dd3612db4612dae612da6612da160098890611193565b6111c2565b936008611913565b90610b60565b91612dcb83612dc560088490611913565b906116f7565b916009611193565b6113c1565b6009611193565b611719565b612df6612df16008612c2c565b612d32565b565b90565b612e0f612e0a612e1492612df8565b610592565b61035c565b90565b90565b612e2e612e29612e3392612e17565b610592565b61035c565b90565b90565b612e4d612e48612e5292612e36565b610592565b61035c565b90565b90565b612e6c612e67612e7192612e55565b610592565b61035c565b90565b90565b612e8b612e86612e9092612e74565b610592565b61035c565b90565b90565b612eaa612ea5612eaf92612e93565b610592565b61035c565b90565b90565b612ec9612ec4612ece92612eb2565b610592565b61035c565b90565b90565b612ee8612ee3612eed92612ed1565b610592565b61035c565b90565b90565b612f07612f02612f0c92612ef0565b610592565b61035c565b90565b90565b612f26612f21612f2b92612f0f565b610592565b61035c565b90565b90565b612f45612f40612f4a92612f2e565b610592565b61035c565b90565b612f55611010565b50612f5f5f611b55565b9080612f8e612f887a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000612dfb565b9161035c565b1015613166575b80612fb6612fb06d04ee2d6d415b85acef8100000000612e39565b9161035c565b101561312b575b80612fd7612fd1662386f26fc10000612e58565b9161035c565b10156130f7575b80612ff5612fef6305f5e100612e96565b9161035c565b10156130c6575b8061301161300b612710612ed4565b9161035c565b1015613097575b8061302c6130266064612f12565b9161035c565b1015613069575b613046613040600a6126b1565b9161035c565b1015613050575b90565b6130649061305e6001611405565b90612665565b61304d565b6130806130919161307a6064612f12565b906126e1565b9161308b6002612f31565b90612665565b90613033565b6130af6130c0916130a9612710612ed4565b906126e1565b916130ba6004612ef3565b90612665565b90613018565b6130e06130f1916130da6305f5e100612e96565b906126e1565b916130eb6008612eb5565b90612665565b90612ffc565b6131146131259161310e662386f26fc10000612e58565b906126e1565b9161311f6010612e77565b90612665565b90612fde565b61314f613160916131496d04ee2d6d415b85acef8100000000612e39565b906126e1565b9161315a6020611d17565b90612665565b90612fbd565b6131976131a8916131917a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000612dfb565b906126e1565b916131a26040612e1a565b90612665565b90612f95565b6131c36131bd828486916127cb565b15610251565b6131cc57505050565b6131e66131e06131db5f61104d565b6103ab565b916103ab565b145f1461320c57613208825f918291637e27328960e01b8352600483016104a4565b0390fd5b6132265f92839263177e802f60e01b845260048401611126565b0390fdfea264697066735822122075a0e1d20a2c41c4e12cde5d83e498b5de0c279802627474ff25ab671a91d1d564736f6c634300081b0033",
}

// CosmicSignatureABI is the input ABI used to generate the binding from.
// Deprecated: Use CosmicSignatureMetaData.ABI instead.
var CosmicSignatureABI = CosmicSignatureMetaData.ABI

// CosmicSignatureBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use CosmicSignatureMetaData.Bin instead.
var CosmicSignatureBin = CosmicSignatureMetaData.Bin

// DeployCosmicSignature deploys a new Ethereum contract, binding an instance of CosmicSignature to it.
func DeployCosmicSignature(auth *bind.TransactOpts, backend bind.ContractBackend, _cosmicGameProxyContract common.Address) (common.Address, *types.Transaction, *CosmicSignature, error) {
	parsed, err := CosmicSignatureMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(CosmicSignatureBin), backend, _cosmicGameProxyContract)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &CosmicSignature{CosmicSignatureCaller: CosmicSignatureCaller{contract: contract}, CosmicSignatureTransactor: CosmicSignatureTransactor{contract: contract}, CosmicSignatureFilterer: CosmicSignatureFilterer{contract: contract}}, nil
}

// CosmicSignature is an auto generated Go binding around an Ethereum contract.
type CosmicSignature struct {
	CosmicSignatureCaller     // Read-only binding to the contract
	CosmicSignatureTransactor // Write-only binding to the contract
	CosmicSignatureFilterer   // Log filterer for contract events
}

// CosmicSignatureCaller is an auto generated read-only Go binding around an Ethereum contract.
type CosmicSignatureCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CosmicSignatureTransactor is an auto generated write-only Go binding around an Ethereum contract.
type CosmicSignatureTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CosmicSignatureFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type CosmicSignatureFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CosmicSignatureSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type CosmicSignatureSession struct {
	Contract     *CosmicSignature  // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// CosmicSignatureCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type CosmicSignatureCallerSession struct {
	Contract *CosmicSignatureCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts          // Call options to use throughout this session
}

// CosmicSignatureTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type CosmicSignatureTransactorSession struct {
	Contract     *CosmicSignatureTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts          // Transaction auth options to use throughout this session
}

// CosmicSignatureRaw is an auto generated low-level Go binding around an Ethereum contract.
type CosmicSignatureRaw struct {
	Contract *CosmicSignature // Generic contract binding to access the raw methods on
}

// CosmicSignatureCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type CosmicSignatureCallerRaw struct {
	Contract *CosmicSignatureCaller // Generic read-only contract binding to access the raw methods on
}

// CosmicSignatureTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type CosmicSignatureTransactorRaw struct {
	Contract *CosmicSignatureTransactor // Generic write-only contract binding to access the raw methods on
}

// NewCosmicSignature creates a new instance of CosmicSignature, bound to a specific deployed contract.
func NewCosmicSignature(address common.Address, backend bind.ContractBackend) (*CosmicSignature, error) {
	contract, err := bindCosmicSignature(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &CosmicSignature{CosmicSignatureCaller: CosmicSignatureCaller{contract: contract}, CosmicSignatureTransactor: CosmicSignatureTransactor{contract: contract}, CosmicSignatureFilterer: CosmicSignatureFilterer{contract: contract}}, nil
}

// NewCosmicSignatureCaller creates a new read-only instance of CosmicSignature, bound to a specific deployed contract.
func NewCosmicSignatureCaller(address common.Address, caller bind.ContractCaller) (*CosmicSignatureCaller, error) {
	contract, err := bindCosmicSignature(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureCaller{contract: contract}, nil
}

// NewCosmicSignatureTransactor creates a new write-only instance of CosmicSignature, bound to a specific deployed contract.
func NewCosmicSignatureTransactor(address common.Address, transactor bind.ContractTransactor) (*CosmicSignatureTransactor, error) {
	contract, err := bindCosmicSignature(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureTransactor{contract: contract}, nil
}

// NewCosmicSignatureFilterer creates a new log filterer instance of CosmicSignature, bound to a specific deployed contract.
func NewCosmicSignatureFilterer(address common.Address, filterer bind.ContractFilterer) (*CosmicSignatureFilterer, error) {
	contract, err := bindCosmicSignature(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureFilterer{contract: contract}, nil
}

// bindCosmicSignature binds a generic wrapper to an already deployed contract.
func bindCosmicSignature(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := CosmicSignatureMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_CosmicSignature *CosmicSignatureRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _CosmicSignature.Contract.CosmicSignatureCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_CosmicSignature *CosmicSignatureRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CosmicSignature.Contract.CosmicSignatureTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_CosmicSignature *CosmicSignatureRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _CosmicSignature.Contract.CosmicSignatureTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_CosmicSignature *CosmicSignatureCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _CosmicSignature.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_CosmicSignature *CosmicSignatureTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CosmicSignature.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_CosmicSignature *CosmicSignatureTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _CosmicSignature.Contract.contract.Transact(opts, method, params...)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256)
func (_CosmicSignature *CosmicSignatureCaller) BalanceOf(opts *bind.CallOpts, owner common.Address) (*big.Int, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "balanceOf", owner)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256)
func (_CosmicSignature *CosmicSignatureSession) BalanceOf(owner common.Address) (*big.Int, error) {
	return _CosmicSignature.Contract.BalanceOf(&_CosmicSignature.CallOpts, owner)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256)
func (_CosmicSignature *CosmicSignatureCallerSession) BalanceOf(owner common.Address) (*big.Int, error) {
	return _CosmicSignature.Contract.BalanceOf(&_CosmicSignature.CallOpts, owner)
}

// CosmicGameProxyContract is a free data retrieval call binding the contract method 0x7722620d.
//
// Solidity: function cosmicGameProxyContract() view returns(address)
func (_CosmicSignature *CosmicSignatureCaller) CosmicGameProxyContract(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "cosmicGameProxyContract")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// CosmicGameProxyContract is a free data retrieval call binding the contract method 0x7722620d.
//
// Solidity: function cosmicGameProxyContract() view returns(address)
func (_CosmicSignature *CosmicSignatureSession) CosmicGameProxyContract() (common.Address, error) {
	return _CosmicSignature.Contract.CosmicGameProxyContract(&_CosmicSignature.CallOpts)
}

// CosmicGameProxyContract is a free data retrieval call binding the contract method 0x7722620d.
//
// Solidity: function cosmicGameProxyContract() view returns(address)
func (_CosmicSignature *CosmicSignatureCallerSession) CosmicGameProxyContract() (common.Address, error) {
	return _CosmicSignature.Contract.CosmicGameProxyContract(&_CosmicSignature.CallOpts)
}

// Entropy is a free data retrieval call binding the contract method 0x47ce07cc.
//
// Solidity: function entropy() view returns(bytes32)
func (_CosmicSignature *CosmicSignatureCaller) Entropy(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "entropy")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// Entropy is a free data retrieval call binding the contract method 0x47ce07cc.
//
// Solidity: function entropy() view returns(bytes32)
func (_CosmicSignature *CosmicSignatureSession) Entropy() ([32]byte, error) {
	return _CosmicSignature.Contract.Entropy(&_CosmicSignature.CallOpts)
}

// Entropy is a free data retrieval call binding the contract method 0x47ce07cc.
//
// Solidity: function entropy() view returns(bytes32)
func (_CosmicSignature *CosmicSignatureCallerSession) Entropy() ([32]byte, error) {
	return _CosmicSignature.Contract.Entropy(&_CosmicSignature.CallOpts)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address)
func (_CosmicSignature *CosmicSignatureCaller) GetApproved(opts *bind.CallOpts, tokenId *big.Int) (common.Address, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "getApproved", tokenId)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address)
func (_CosmicSignature *CosmicSignatureSession) GetApproved(tokenId *big.Int) (common.Address, error) {
	return _CosmicSignature.Contract.GetApproved(&_CosmicSignature.CallOpts, tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address)
func (_CosmicSignature *CosmicSignatureCallerSession) GetApproved(tokenId *big.Int) (common.Address, error) {
	return _CosmicSignature.Contract.GetApproved(&_CosmicSignature.CallOpts, tokenId)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_CosmicSignature *CosmicSignatureCaller) IsApprovedForAll(opts *bind.CallOpts, owner common.Address, operator common.Address) (bool, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "isApprovedForAll", owner, operator)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_CosmicSignature *CosmicSignatureSession) IsApprovedForAll(owner common.Address, operator common.Address) (bool, error) {
	return _CosmicSignature.Contract.IsApprovedForAll(&_CosmicSignature.CallOpts, owner, operator)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_CosmicSignature *CosmicSignatureCallerSession) IsApprovedForAll(owner common.Address, operator common.Address) (bool, error) {
	return _CosmicSignature.Contract.IsApprovedForAll(&_CosmicSignature.CallOpts, owner, operator)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_CosmicSignature *CosmicSignatureCaller) Name(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "name")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_CosmicSignature *CosmicSignatureSession) Name() (string, error) {
	return _CosmicSignature.Contract.Name(&_CosmicSignature.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_CosmicSignature *CosmicSignatureCallerSession) Name() (string, error) {
	return _CosmicSignature.Contract.Name(&_CosmicSignature.CallOpts)
}

// NumTokens is a free data retrieval call binding the contract method 0x8e499bcf.
//
// Solidity: function numTokens() view returns(uint256)
func (_CosmicSignature *CosmicSignatureCaller) NumTokens(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "numTokens")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NumTokens is a free data retrieval call binding the contract method 0x8e499bcf.
//
// Solidity: function numTokens() view returns(uint256)
func (_CosmicSignature *CosmicSignatureSession) NumTokens() (*big.Int, error) {
	return _CosmicSignature.Contract.NumTokens(&_CosmicSignature.CallOpts)
}

// NumTokens is a free data retrieval call binding the contract method 0x8e499bcf.
//
// Solidity: function numTokens() view returns(uint256)
func (_CosmicSignature *CosmicSignatureCallerSession) NumTokens() (*big.Int, error) {
	return _CosmicSignature.Contract.NumTokens(&_CosmicSignature.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_CosmicSignature *CosmicSignatureCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_CosmicSignature *CosmicSignatureSession) Owner() (common.Address, error) {
	return _CosmicSignature.Contract.Owner(&_CosmicSignature.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_CosmicSignature *CosmicSignatureCallerSession) Owner() (common.Address, error) {
	return _CosmicSignature.Contract.Owner(&_CosmicSignature.CallOpts)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address)
func (_CosmicSignature *CosmicSignatureCaller) OwnerOf(opts *bind.CallOpts, tokenId *big.Int) (common.Address, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "ownerOf", tokenId)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address)
func (_CosmicSignature *CosmicSignatureSession) OwnerOf(tokenId *big.Int) (common.Address, error) {
	return _CosmicSignature.Contract.OwnerOf(&_CosmicSignature.CallOpts, tokenId)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address)
func (_CosmicSignature *CosmicSignatureCallerSession) OwnerOf(tokenId *big.Int) (common.Address, error) {
	return _CosmicSignature.Contract.OwnerOf(&_CosmicSignature.CallOpts, tokenId)
}

// Seeds is a free data retrieval call binding the contract method 0xf0503e80.
//
// Solidity: function seeds(uint256 ) view returns(bytes32)
func (_CosmicSignature *CosmicSignatureCaller) Seeds(opts *bind.CallOpts, arg0 *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "seeds", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// Seeds is a free data retrieval call binding the contract method 0xf0503e80.
//
// Solidity: function seeds(uint256 ) view returns(bytes32)
func (_CosmicSignature *CosmicSignatureSession) Seeds(arg0 *big.Int) ([32]byte, error) {
	return _CosmicSignature.Contract.Seeds(&_CosmicSignature.CallOpts, arg0)
}

// Seeds is a free data retrieval call binding the contract method 0xf0503e80.
//
// Solidity: function seeds(uint256 ) view returns(bytes32)
func (_CosmicSignature *CosmicSignatureCallerSession) Seeds(arg0 *big.Int) ([32]byte, error) {
	return _CosmicSignature.Contract.Seeds(&_CosmicSignature.CallOpts, arg0)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_CosmicSignature *CosmicSignatureCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "supportsInterface", interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_CosmicSignature *CosmicSignatureSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _CosmicSignature.Contract.SupportsInterface(&_CosmicSignature.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_CosmicSignature *CosmicSignatureCallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _CosmicSignature.Contract.SupportsInterface(&_CosmicSignature.CallOpts, interfaceId)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_CosmicSignature *CosmicSignatureCaller) Symbol(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "symbol")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_CosmicSignature *CosmicSignatureSession) Symbol() (string, error) {
	return _CosmicSignature.Contract.Symbol(&_CosmicSignature.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_CosmicSignature *CosmicSignatureCallerSession) Symbol() (string, error) {
	return _CosmicSignature.Contract.Symbol(&_CosmicSignature.CallOpts)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 index) view returns(uint256)
func (_CosmicSignature *CosmicSignatureCaller) TokenByIndex(opts *bind.CallOpts, index *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "tokenByIndex", index)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 index) view returns(uint256)
func (_CosmicSignature *CosmicSignatureSession) TokenByIndex(index *big.Int) (*big.Int, error) {
	return _CosmicSignature.Contract.TokenByIndex(&_CosmicSignature.CallOpts, index)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 index) view returns(uint256)
func (_CosmicSignature *CosmicSignatureCallerSession) TokenByIndex(index *big.Int) (*big.Int, error) {
	return _CosmicSignature.Contract.TokenByIndex(&_CosmicSignature.CallOpts, index)
}

// TokenGenerationScriptURL is a free data retrieval call binding the contract method 0xde9d90bc.
//
// Solidity: function tokenGenerationScriptURL() view returns(string)
func (_CosmicSignature *CosmicSignatureCaller) TokenGenerationScriptURL(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "tokenGenerationScriptURL")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// TokenGenerationScriptURL is a free data retrieval call binding the contract method 0xde9d90bc.
//
// Solidity: function tokenGenerationScriptURL() view returns(string)
func (_CosmicSignature *CosmicSignatureSession) TokenGenerationScriptURL() (string, error) {
	return _CosmicSignature.Contract.TokenGenerationScriptURL(&_CosmicSignature.CallOpts)
}

// TokenGenerationScriptURL is a free data retrieval call binding the contract method 0xde9d90bc.
//
// Solidity: function tokenGenerationScriptURL() view returns(string)
func (_CosmicSignature *CosmicSignatureCallerSession) TokenGenerationScriptURL() (string, error) {
	return _CosmicSignature.Contract.TokenGenerationScriptURL(&_CosmicSignature.CallOpts)
}

// TokenNames is a free data retrieval call binding the contract method 0x310495ab.
//
// Solidity: function tokenNames(uint256 ) view returns(string)
func (_CosmicSignature *CosmicSignatureCaller) TokenNames(opts *bind.CallOpts, arg0 *big.Int) (string, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "tokenNames", arg0)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// TokenNames is a free data retrieval call binding the contract method 0x310495ab.
//
// Solidity: function tokenNames(uint256 ) view returns(string)
func (_CosmicSignature *CosmicSignatureSession) TokenNames(arg0 *big.Int) (string, error) {
	return _CosmicSignature.Contract.TokenNames(&_CosmicSignature.CallOpts, arg0)
}

// TokenNames is a free data retrieval call binding the contract method 0x310495ab.
//
// Solidity: function tokenNames(uint256 ) view returns(string)
func (_CosmicSignature *CosmicSignatureCallerSession) TokenNames(arg0 *big.Int) (string, error) {
	return _CosmicSignature.Contract.TokenNames(&_CosmicSignature.CallOpts, arg0)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address owner, uint256 index) view returns(uint256)
func (_CosmicSignature *CosmicSignatureCaller) TokenOfOwnerByIndex(opts *bind.CallOpts, owner common.Address, index *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "tokenOfOwnerByIndex", owner, index)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address owner, uint256 index) view returns(uint256)
func (_CosmicSignature *CosmicSignatureSession) TokenOfOwnerByIndex(owner common.Address, index *big.Int) (*big.Int, error) {
	return _CosmicSignature.Contract.TokenOfOwnerByIndex(&_CosmicSignature.CallOpts, owner, index)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address owner, uint256 index) view returns(uint256)
func (_CosmicSignature *CosmicSignatureCallerSession) TokenOfOwnerByIndex(owner common.Address, index *big.Int) (*big.Int, error) {
	return _CosmicSignature.Contract.TokenOfOwnerByIndex(&_CosmicSignature.CallOpts, owner, index)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 tokenId) view returns(string)
func (_CosmicSignature *CosmicSignatureCaller) TokenURI(opts *bind.CallOpts, tokenId *big.Int) (string, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "tokenURI", tokenId)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 tokenId) view returns(string)
func (_CosmicSignature *CosmicSignatureSession) TokenURI(tokenId *big.Int) (string, error) {
	return _CosmicSignature.Contract.TokenURI(&_CosmicSignature.CallOpts, tokenId)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 tokenId) view returns(string)
func (_CosmicSignature *CosmicSignatureCallerSession) TokenURI(tokenId *big.Int) (string, error) {
	return _CosmicSignature.Contract.TokenURI(&_CosmicSignature.CallOpts, tokenId)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_CosmicSignature *CosmicSignatureCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _CosmicSignature.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_CosmicSignature *CosmicSignatureSession) TotalSupply() (*big.Int, error) {
	return _CosmicSignature.Contract.TotalSupply(&_CosmicSignature.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_CosmicSignature *CosmicSignatureCallerSession) TotalSupply() (*big.Int, error) {
	return _CosmicSignature.Contract.TotalSupply(&_CosmicSignature.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_CosmicSignature *CosmicSignatureTransactor) Approve(opts *bind.TransactOpts, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignature.contract.Transact(opts, "approve", to, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_CosmicSignature *CosmicSignatureSession) Approve(to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignature.Contract.Approve(&_CosmicSignature.TransactOpts, to, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_CosmicSignature *CosmicSignatureTransactorSession) Approve(to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignature.Contract.Approve(&_CosmicSignature.TransactOpts, to, tokenId)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address owner, uint256 roundNum) returns(uint256)
func (_CosmicSignature *CosmicSignatureTransactor) Mint(opts *bind.TransactOpts, owner common.Address, roundNum *big.Int) (*types.Transaction, error) {
	return _CosmicSignature.contract.Transact(opts, "mint", owner, roundNum)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address owner, uint256 roundNum) returns(uint256)
func (_CosmicSignature *CosmicSignatureSession) Mint(owner common.Address, roundNum *big.Int) (*types.Transaction, error) {
	return _CosmicSignature.Contract.Mint(&_CosmicSignature.TransactOpts, owner, roundNum)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address owner, uint256 roundNum) returns(uint256)
func (_CosmicSignature *CosmicSignatureTransactorSession) Mint(owner common.Address, roundNum *big.Int) (*types.Transaction, error) {
	return _CosmicSignature.Contract.Mint(&_CosmicSignature.TransactOpts, owner, roundNum)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_CosmicSignature *CosmicSignatureTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CosmicSignature.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_CosmicSignature *CosmicSignatureSession) RenounceOwnership() (*types.Transaction, error) {
	return _CosmicSignature.Contract.RenounceOwnership(&_CosmicSignature.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_CosmicSignature *CosmicSignatureTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _CosmicSignature.Contract.RenounceOwnership(&_CosmicSignature.TransactOpts)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_CosmicSignature *CosmicSignatureTransactor) SafeTransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignature.contract.Transact(opts, "safeTransferFrom", from, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_CosmicSignature *CosmicSignatureSession) SafeTransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignature.Contract.SafeTransferFrom(&_CosmicSignature.TransactOpts, from, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_CosmicSignature *CosmicSignatureTransactorSession) SafeTransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignature.Contract.SafeTransferFrom(&_CosmicSignature.TransactOpts, from, to, tokenId)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_CosmicSignature *CosmicSignatureTransactor) SafeTransferFrom0(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _CosmicSignature.contract.Transact(opts, "safeTransferFrom0", from, to, tokenId, data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_CosmicSignature *CosmicSignatureSession) SafeTransferFrom0(from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _CosmicSignature.Contract.SafeTransferFrom0(&_CosmicSignature.TransactOpts, from, to, tokenId, data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_CosmicSignature *CosmicSignatureTransactorSession) SafeTransferFrom0(from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _CosmicSignature.Contract.SafeTransferFrom0(&_CosmicSignature.TransactOpts, from, to, tokenId, data)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_CosmicSignature *CosmicSignatureTransactor) SetApprovalForAll(opts *bind.TransactOpts, operator common.Address, approved bool) (*types.Transaction, error) {
	return _CosmicSignature.contract.Transact(opts, "setApprovalForAll", operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_CosmicSignature *CosmicSignatureSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _CosmicSignature.Contract.SetApprovalForAll(&_CosmicSignature.TransactOpts, operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_CosmicSignature *CosmicSignatureTransactorSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _CosmicSignature.Contract.SetApprovalForAll(&_CosmicSignature.TransactOpts, operator, approved)
}

// SetBaseURI is a paid mutator transaction binding the contract method 0x55f804b3.
//
// Solidity: function setBaseURI(string value) returns()
func (_CosmicSignature *CosmicSignatureTransactor) SetBaseURI(opts *bind.TransactOpts, value string) (*types.Transaction, error) {
	return _CosmicSignature.contract.Transact(opts, "setBaseURI", value)
}

// SetBaseURI is a paid mutator transaction binding the contract method 0x55f804b3.
//
// Solidity: function setBaseURI(string value) returns()
func (_CosmicSignature *CosmicSignatureSession) SetBaseURI(value string) (*types.Transaction, error) {
	return _CosmicSignature.Contract.SetBaseURI(&_CosmicSignature.TransactOpts, value)
}

// SetBaseURI is a paid mutator transaction binding the contract method 0x55f804b3.
//
// Solidity: function setBaseURI(string value) returns()
func (_CosmicSignature *CosmicSignatureTransactorSession) SetBaseURI(value string) (*types.Transaction, error) {
	return _CosmicSignature.Contract.SetBaseURI(&_CosmicSignature.TransactOpts, value)
}

// SetTokenGenerationScriptURL is a paid mutator transaction binding the contract method 0x46519a18.
//
// Solidity: function setTokenGenerationScriptURL(string newTokenGenerationScriptURL) returns()
func (_CosmicSignature *CosmicSignatureTransactor) SetTokenGenerationScriptURL(opts *bind.TransactOpts, newTokenGenerationScriptURL string) (*types.Transaction, error) {
	return _CosmicSignature.contract.Transact(opts, "setTokenGenerationScriptURL", newTokenGenerationScriptURL)
}

// SetTokenGenerationScriptURL is a paid mutator transaction binding the contract method 0x46519a18.
//
// Solidity: function setTokenGenerationScriptURL(string newTokenGenerationScriptURL) returns()
func (_CosmicSignature *CosmicSignatureSession) SetTokenGenerationScriptURL(newTokenGenerationScriptURL string) (*types.Transaction, error) {
	return _CosmicSignature.Contract.SetTokenGenerationScriptURL(&_CosmicSignature.TransactOpts, newTokenGenerationScriptURL)
}

// SetTokenGenerationScriptURL is a paid mutator transaction binding the contract method 0x46519a18.
//
// Solidity: function setTokenGenerationScriptURL(string newTokenGenerationScriptURL) returns()
func (_CosmicSignature *CosmicSignatureTransactorSession) SetTokenGenerationScriptURL(newTokenGenerationScriptURL string) (*types.Transaction, error) {
	return _CosmicSignature.Contract.SetTokenGenerationScriptURL(&_CosmicSignature.TransactOpts, newTokenGenerationScriptURL)
}

// SetTokenName is a paid mutator transaction binding the contract method 0xcdb0e89e.
//
// Solidity: function setTokenName(uint256 nftId, string name) returns()
func (_CosmicSignature *CosmicSignatureTransactor) SetTokenName(opts *bind.TransactOpts, nftId *big.Int, name string) (*types.Transaction, error) {
	return _CosmicSignature.contract.Transact(opts, "setTokenName", nftId, name)
}

// SetTokenName is a paid mutator transaction binding the contract method 0xcdb0e89e.
//
// Solidity: function setTokenName(uint256 nftId, string name) returns()
func (_CosmicSignature *CosmicSignatureSession) SetTokenName(nftId *big.Int, name string) (*types.Transaction, error) {
	return _CosmicSignature.Contract.SetTokenName(&_CosmicSignature.TransactOpts, nftId, name)
}

// SetTokenName is a paid mutator transaction binding the contract method 0xcdb0e89e.
//
// Solidity: function setTokenName(uint256 nftId, string name) returns()
func (_CosmicSignature *CosmicSignatureTransactorSession) SetTokenName(nftId *big.Int, name string) (*types.Transaction, error) {
	return _CosmicSignature.Contract.SetTokenName(&_CosmicSignature.TransactOpts, nftId, name)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_CosmicSignature *CosmicSignatureTransactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignature.contract.Transact(opts, "transferFrom", from, to, tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_CosmicSignature *CosmicSignatureSession) TransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignature.Contract.TransferFrom(&_CosmicSignature.TransactOpts, from, to, tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_CosmicSignature *CosmicSignatureTransactorSession) TransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _CosmicSignature.Contract.TransferFrom(&_CosmicSignature.TransactOpts, from, to, tokenId)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_CosmicSignature *CosmicSignatureTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _CosmicSignature.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_CosmicSignature *CosmicSignatureSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _CosmicSignature.Contract.TransferOwnership(&_CosmicSignature.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_CosmicSignature *CosmicSignatureTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _CosmicSignature.Contract.TransferOwnership(&_CosmicSignature.TransactOpts, newOwner)
}

// CosmicSignatureApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the CosmicSignature contract.
type CosmicSignatureApprovalIterator struct {
	Event *CosmicSignatureApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureApproval represents a Approval event raised by the CosmicSignature contract.
type CosmicSignatureApproval struct {
	Owner    common.Address
	Approved common.Address
	TokenId  *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_CosmicSignature *CosmicSignatureFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, approved []common.Address, tokenId []*big.Int) (*CosmicSignatureApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _CosmicSignature.contract.FilterLogs(opts, "Approval", ownerRule, approvedRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureApprovalIterator{contract: _CosmicSignature.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_CosmicSignature *CosmicSignatureFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *CosmicSignatureApproval, owner []common.Address, approved []common.Address, tokenId []*big.Int) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _CosmicSignature.contract.WatchLogs(opts, "Approval", ownerRule, approvedRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureApproval)
				if err := _CosmicSignature.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_CosmicSignature *CosmicSignatureFilterer) ParseApproval(log types.Log) (*CosmicSignatureApproval, error) {
	event := new(CosmicSignatureApproval)
	if err := _CosmicSignature.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureApprovalForAllIterator is returned from FilterApprovalForAll and is used to iterate over the raw logs and unpacked data for ApprovalForAll events raised by the CosmicSignature contract.
type CosmicSignatureApprovalForAllIterator struct {
	Event *CosmicSignatureApprovalForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureApprovalForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureApprovalForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureApprovalForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureApprovalForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureApprovalForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureApprovalForAll represents a ApprovalForAll event raised by the CosmicSignature contract.
type CosmicSignatureApprovalForAll struct {
	Owner    common.Address
	Operator common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApprovalForAll is a free log retrieval operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_CosmicSignature *CosmicSignatureFilterer) FilterApprovalForAll(opts *bind.FilterOpts, owner []common.Address, operator []common.Address) (*CosmicSignatureApprovalForAllIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _CosmicSignature.contract.FilterLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureApprovalForAllIterator{contract: _CosmicSignature.contract, event: "ApprovalForAll", logs: logs, sub: sub}, nil
}

// WatchApprovalForAll is a free log subscription operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_CosmicSignature *CosmicSignatureFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *CosmicSignatureApprovalForAll, owner []common.Address, operator []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _CosmicSignature.contract.WatchLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureApprovalForAll)
				if err := _CosmicSignature.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApprovalForAll is a log parse operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_CosmicSignature *CosmicSignatureFilterer) ParseApprovalForAll(log types.Log) (*CosmicSignatureApprovalForAll, error) {
	event := new(CosmicSignatureApprovalForAll)
	if err := _CosmicSignature.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureBaseURIEventIterator is returned from FilterBaseURIEvent and is used to iterate over the raw logs and unpacked data for BaseURIEvent events raised by the CosmicSignature contract.
type CosmicSignatureBaseURIEventIterator struct {
	Event *CosmicSignatureBaseURIEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureBaseURIEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureBaseURIEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureBaseURIEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureBaseURIEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureBaseURIEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureBaseURIEvent represents a BaseURIEvent event raised by the CosmicSignature contract.
type CosmicSignatureBaseURIEvent struct {
	NewURI string
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterBaseURIEvent is a free log retrieval operation binding the contract event 0x2fc013f885e8a815b9d697da28bc143b4dced47528c41b46e2b35fd0f4be718c.
//
// Solidity: event BaseURIEvent(string newURI)
func (_CosmicSignature *CosmicSignatureFilterer) FilterBaseURIEvent(opts *bind.FilterOpts) (*CosmicSignatureBaseURIEventIterator, error) {

	logs, sub, err := _CosmicSignature.contract.FilterLogs(opts, "BaseURIEvent")
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureBaseURIEventIterator{contract: _CosmicSignature.contract, event: "BaseURIEvent", logs: logs, sub: sub}, nil
}

// WatchBaseURIEvent is a free log subscription operation binding the contract event 0x2fc013f885e8a815b9d697da28bc143b4dced47528c41b46e2b35fd0f4be718c.
//
// Solidity: event BaseURIEvent(string newURI)
func (_CosmicSignature *CosmicSignatureFilterer) WatchBaseURIEvent(opts *bind.WatchOpts, sink chan<- *CosmicSignatureBaseURIEvent) (event.Subscription, error) {

	logs, sub, err := _CosmicSignature.contract.WatchLogs(opts, "BaseURIEvent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureBaseURIEvent)
				if err := _CosmicSignature.contract.UnpackLog(event, "BaseURIEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBaseURIEvent is a log parse operation binding the contract event 0x2fc013f885e8a815b9d697da28bc143b4dced47528c41b46e2b35fd0f4be718c.
//
// Solidity: event BaseURIEvent(string newURI)
func (_CosmicSignature *CosmicSignatureFilterer) ParseBaseURIEvent(log types.Log) (*CosmicSignatureBaseURIEvent, error) {
	event := new(CosmicSignatureBaseURIEvent)
	if err := _CosmicSignature.contract.UnpackLog(event, "BaseURIEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureMintEventIterator is returned from FilterMintEvent and is used to iterate over the raw logs and unpacked data for MintEvent events raised by the CosmicSignature contract.
type CosmicSignatureMintEventIterator struct {
	Event *CosmicSignatureMintEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureMintEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureMintEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureMintEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureMintEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureMintEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureMintEvent represents a MintEvent event raised by the CosmicSignature contract.
type CosmicSignatureMintEvent struct {
	NftId    *big.Int
	Owner    common.Address
	RoundNum *big.Int
	Seed     [32]byte
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterMintEvent is a free log retrieval operation binding the contract event 0xc646da88dc2b2526461a0ebb4326e2418ec0bea89496b632b7c9ee42fbfe1d4d.
//
// Solidity: event MintEvent(uint256 indexed nftId, address indexed owner, uint256 indexed roundNum, bytes32 seed)
func (_CosmicSignature *CosmicSignatureFilterer) FilterMintEvent(opts *bind.FilterOpts, nftId []*big.Int, owner []common.Address, roundNum []*big.Int) (*CosmicSignatureMintEventIterator, error) {

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}
	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var roundNumRule []interface{}
	for _, roundNumItem := range roundNum {
		roundNumRule = append(roundNumRule, roundNumItem)
	}

	logs, sub, err := _CosmicSignature.contract.FilterLogs(opts, "MintEvent", nftIdRule, ownerRule, roundNumRule)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureMintEventIterator{contract: _CosmicSignature.contract, event: "MintEvent", logs: logs, sub: sub}, nil
}

// WatchMintEvent is a free log subscription operation binding the contract event 0xc646da88dc2b2526461a0ebb4326e2418ec0bea89496b632b7c9ee42fbfe1d4d.
//
// Solidity: event MintEvent(uint256 indexed nftId, address indexed owner, uint256 indexed roundNum, bytes32 seed)
func (_CosmicSignature *CosmicSignatureFilterer) WatchMintEvent(opts *bind.WatchOpts, sink chan<- *CosmicSignatureMintEvent, nftId []*big.Int, owner []common.Address, roundNum []*big.Int) (event.Subscription, error) {

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}
	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var roundNumRule []interface{}
	for _, roundNumItem := range roundNum {
		roundNumRule = append(roundNumRule, roundNumItem)
	}

	logs, sub, err := _CosmicSignature.contract.WatchLogs(opts, "MintEvent", nftIdRule, ownerRule, roundNumRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureMintEvent)
				if err := _CosmicSignature.contract.UnpackLog(event, "MintEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMintEvent is a log parse operation binding the contract event 0xc646da88dc2b2526461a0ebb4326e2418ec0bea89496b632b7c9ee42fbfe1d4d.
//
// Solidity: event MintEvent(uint256 indexed nftId, address indexed owner, uint256 indexed roundNum, bytes32 seed)
func (_CosmicSignature *CosmicSignatureFilterer) ParseMintEvent(log types.Log) (*CosmicSignatureMintEvent, error) {
	event := new(CosmicSignatureMintEvent)
	if err := _CosmicSignature.contract.UnpackLog(event, "MintEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the CosmicSignature contract.
type CosmicSignatureOwnershipTransferredIterator struct {
	Event *CosmicSignatureOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureOwnershipTransferred represents a OwnershipTransferred event raised by the CosmicSignature contract.
type CosmicSignatureOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_CosmicSignature *CosmicSignatureFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*CosmicSignatureOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _CosmicSignature.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureOwnershipTransferredIterator{contract: _CosmicSignature.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_CosmicSignature *CosmicSignatureFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *CosmicSignatureOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _CosmicSignature.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureOwnershipTransferred)
				if err := _CosmicSignature.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_CosmicSignature *CosmicSignatureFilterer) ParseOwnershipTransferred(log types.Log) (*CosmicSignatureOwnershipTransferred, error) {
	event := new(CosmicSignatureOwnershipTransferred)
	if err := _CosmicSignature.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureTokenGenerationScriptURLEventIterator is returned from FilterTokenGenerationScriptURLEvent and is used to iterate over the raw logs and unpacked data for TokenGenerationScriptURLEvent events raised by the CosmicSignature contract.
type CosmicSignatureTokenGenerationScriptURLEventIterator struct {
	Event *CosmicSignatureTokenGenerationScriptURLEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureTokenGenerationScriptURLEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureTokenGenerationScriptURLEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureTokenGenerationScriptURLEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureTokenGenerationScriptURLEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureTokenGenerationScriptURLEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureTokenGenerationScriptURLEvent represents a TokenGenerationScriptURLEvent event raised by the CosmicSignature contract.
type CosmicSignatureTokenGenerationScriptURLEvent struct {
	NewURL string
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterTokenGenerationScriptURLEvent is a free log retrieval operation binding the contract event 0x0119741ee0f95fab26124262a82c3c0e9e1c7ff4bb33c6fba5f3b11c9b6d0bad.
//
// Solidity: event TokenGenerationScriptURLEvent(string newURL)
func (_CosmicSignature *CosmicSignatureFilterer) FilterTokenGenerationScriptURLEvent(opts *bind.FilterOpts) (*CosmicSignatureTokenGenerationScriptURLEventIterator, error) {

	logs, sub, err := _CosmicSignature.contract.FilterLogs(opts, "TokenGenerationScriptURLEvent")
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureTokenGenerationScriptURLEventIterator{contract: _CosmicSignature.contract, event: "TokenGenerationScriptURLEvent", logs: logs, sub: sub}, nil
}

// WatchTokenGenerationScriptURLEvent is a free log subscription operation binding the contract event 0x0119741ee0f95fab26124262a82c3c0e9e1c7ff4bb33c6fba5f3b11c9b6d0bad.
//
// Solidity: event TokenGenerationScriptURLEvent(string newURL)
func (_CosmicSignature *CosmicSignatureFilterer) WatchTokenGenerationScriptURLEvent(opts *bind.WatchOpts, sink chan<- *CosmicSignatureTokenGenerationScriptURLEvent) (event.Subscription, error) {

	logs, sub, err := _CosmicSignature.contract.WatchLogs(opts, "TokenGenerationScriptURLEvent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureTokenGenerationScriptURLEvent)
				if err := _CosmicSignature.contract.UnpackLog(event, "TokenGenerationScriptURLEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTokenGenerationScriptURLEvent is a log parse operation binding the contract event 0x0119741ee0f95fab26124262a82c3c0e9e1c7ff4bb33c6fba5f3b11c9b6d0bad.
//
// Solidity: event TokenGenerationScriptURLEvent(string newURL)
func (_CosmicSignature *CosmicSignatureFilterer) ParseTokenGenerationScriptURLEvent(log types.Log) (*CosmicSignatureTokenGenerationScriptURLEvent, error) {
	event := new(CosmicSignatureTokenGenerationScriptURLEvent)
	if err := _CosmicSignature.contract.UnpackLog(event, "TokenGenerationScriptURLEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureTokenNameEventIterator is returned from FilterTokenNameEvent and is used to iterate over the raw logs and unpacked data for TokenNameEvent events raised by the CosmicSignature contract.
type CosmicSignatureTokenNameEventIterator struct {
	Event *CosmicSignatureTokenNameEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureTokenNameEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureTokenNameEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureTokenNameEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureTokenNameEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureTokenNameEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureTokenNameEvent represents a TokenNameEvent event raised by the CosmicSignature contract.
type CosmicSignatureTokenNameEvent struct {
	NftId   *big.Int
	NewName string
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterTokenNameEvent is a free log retrieval operation binding the contract event 0x8ad5e159ff95649c8a9f323ac5a457e741897cf44ce07dfce0e98b84ef9d5f12.
//
// Solidity: event TokenNameEvent(uint256 indexed nftId, string newName)
func (_CosmicSignature *CosmicSignatureFilterer) FilterTokenNameEvent(opts *bind.FilterOpts, nftId []*big.Int) (*CosmicSignatureTokenNameEventIterator, error) {

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}

	logs, sub, err := _CosmicSignature.contract.FilterLogs(opts, "TokenNameEvent", nftIdRule)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureTokenNameEventIterator{contract: _CosmicSignature.contract, event: "TokenNameEvent", logs: logs, sub: sub}, nil
}

// WatchTokenNameEvent is a free log subscription operation binding the contract event 0x8ad5e159ff95649c8a9f323ac5a457e741897cf44ce07dfce0e98b84ef9d5f12.
//
// Solidity: event TokenNameEvent(uint256 indexed nftId, string newName)
func (_CosmicSignature *CosmicSignatureFilterer) WatchTokenNameEvent(opts *bind.WatchOpts, sink chan<- *CosmicSignatureTokenNameEvent, nftId []*big.Int) (event.Subscription, error) {

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}

	logs, sub, err := _CosmicSignature.contract.WatchLogs(opts, "TokenNameEvent", nftIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureTokenNameEvent)
				if err := _CosmicSignature.contract.UnpackLog(event, "TokenNameEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTokenNameEvent is a log parse operation binding the contract event 0x8ad5e159ff95649c8a9f323ac5a457e741897cf44ce07dfce0e98b84ef9d5f12.
//
// Solidity: event TokenNameEvent(uint256 indexed nftId, string newName)
func (_CosmicSignature *CosmicSignatureFilterer) ParseTokenNameEvent(log types.Log) (*CosmicSignatureTokenNameEvent, error) {
	event := new(CosmicSignatureTokenNameEvent)
	if err := _CosmicSignature.contract.UnpackLog(event, "TokenNameEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// CosmicSignatureTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the CosmicSignature contract.
type CosmicSignatureTransferIterator struct {
	Event *CosmicSignatureTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CosmicSignatureTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CosmicSignatureTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CosmicSignatureTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CosmicSignatureTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CosmicSignatureTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CosmicSignatureTransfer represents a Transfer event raised by the CosmicSignature contract.
type CosmicSignatureTransfer struct {
	From    common.Address
	To      common.Address
	TokenId *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_CosmicSignature *CosmicSignatureFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenId []*big.Int) (*CosmicSignatureTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _CosmicSignature.contract.FilterLogs(opts, "Transfer", fromRule, toRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &CosmicSignatureTransferIterator{contract: _CosmicSignature.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_CosmicSignature *CosmicSignatureFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *CosmicSignatureTransfer, from []common.Address, to []common.Address, tokenId []*big.Int) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _CosmicSignature.contract.WatchLogs(opts, "Transfer", fromRule, toRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CosmicSignatureTransfer)
				if err := _CosmicSignature.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_CosmicSignature *CosmicSignatureFilterer) ParseTransfer(log types.Log) (*CosmicSignatureTransfer, error) {
	event := new(CosmicSignatureTransfer)
	if err := _CosmicSignature.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureMetaData contains all meta data concerning the ICosmicSignature contract.
var ICosmicSignatureMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newURI\",\"type\":\"string\"}],\"name\":\"BaseURIEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"seed\",\"type\":\"bytes32\"}],\"name\":\"MintEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newURL\",\"type\":\"string\"}],\"name\":\"TokenGenerationScriptURLEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"}],\"name\":\"TokenNameEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roundNum\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newTokenGenerationScriptURL\",\"type\":\"string\"}],\"name\":\"setTokenGenerationScriptURL\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"setTokenName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// ICosmicSignatureABI is the input ABI used to generate the binding from.
// Deprecated: Use ICosmicSignatureMetaData.ABI instead.
var ICosmicSignatureABI = ICosmicSignatureMetaData.ABI

// ICosmicSignature is an auto generated Go binding around an Ethereum contract.
type ICosmicSignature struct {
	ICosmicSignatureCaller     // Read-only binding to the contract
	ICosmicSignatureTransactor // Write-only binding to the contract
	ICosmicSignatureFilterer   // Log filterer for contract events
}

// ICosmicSignatureCaller is an auto generated read-only Go binding around an Ethereum contract.
type ICosmicSignatureCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ICosmicSignatureTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ICosmicSignatureTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ICosmicSignatureFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ICosmicSignatureFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ICosmicSignatureSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ICosmicSignatureSession struct {
	Contract     *ICosmicSignature // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ICosmicSignatureCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ICosmicSignatureCallerSession struct {
	Contract *ICosmicSignatureCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts           // Call options to use throughout this session
}

// ICosmicSignatureTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ICosmicSignatureTransactorSession struct {
	Contract     *ICosmicSignatureTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts           // Transaction auth options to use throughout this session
}

// ICosmicSignatureRaw is an auto generated low-level Go binding around an Ethereum contract.
type ICosmicSignatureRaw struct {
	Contract *ICosmicSignature // Generic contract binding to access the raw methods on
}

// ICosmicSignatureCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ICosmicSignatureCallerRaw struct {
	Contract *ICosmicSignatureCaller // Generic read-only contract binding to access the raw methods on
}

// ICosmicSignatureTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ICosmicSignatureTransactorRaw struct {
	Contract *ICosmicSignatureTransactor // Generic write-only contract binding to access the raw methods on
}

// NewICosmicSignature creates a new instance of ICosmicSignature, bound to a specific deployed contract.
func NewICosmicSignature(address common.Address, backend bind.ContractBackend) (*ICosmicSignature, error) {
	contract, err := bindICosmicSignature(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignature{ICosmicSignatureCaller: ICosmicSignatureCaller{contract: contract}, ICosmicSignatureTransactor: ICosmicSignatureTransactor{contract: contract}, ICosmicSignatureFilterer: ICosmicSignatureFilterer{contract: contract}}, nil
}

// NewICosmicSignatureCaller creates a new read-only instance of ICosmicSignature, bound to a specific deployed contract.
func NewICosmicSignatureCaller(address common.Address, caller bind.ContractCaller) (*ICosmicSignatureCaller, error) {
	contract, err := bindICosmicSignature(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureCaller{contract: contract}, nil
}

// NewICosmicSignatureTransactor creates a new write-only instance of ICosmicSignature, bound to a specific deployed contract.
func NewICosmicSignatureTransactor(address common.Address, transactor bind.ContractTransactor) (*ICosmicSignatureTransactor, error) {
	contract, err := bindICosmicSignature(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureTransactor{contract: contract}, nil
}

// NewICosmicSignatureFilterer creates a new log filterer instance of ICosmicSignature, bound to a specific deployed contract.
func NewICosmicSignatureFilterer(address common.Address, filterer bind.ContractFilterer) (*ICosmicSignatureFilterer, error) {
	contract, err := bindICosmicSignature(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureFilterer{contract: contract}, nil
}

// bindICosmicSignature binds a generic wrapper to an already deployed contract.
func bindICosmicSignature(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ICosmicSignatureMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ICosmicSignature *ICosmicSignatureRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ICosmicSignature.Contract.ICosmicSignatureCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ICosmicSignature *ICosmicSignatureRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.ICosmicSignatureTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ICosmicSignature *ICosmicSignatureRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.ICosmicSignatureTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ICosmicSignature *ICosmicSignatureCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ICosmicSignature.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ICosmicSignature *ICosmicSignatureTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ICosmicSignature *ICosmicSignatureTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.contract.Transact(opts, method, params...)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256 balance)
func (_ICosmicSignature *ICosmicSignatureCaller) BalanceOf(opts *bind.CallOpts, owner common.Address) (*big.Int, error) {
	var out []interface{}
	err := _ICosmicSignature.contract.Call(opts, &out, "balanceOf", owner)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256 balance)
func (_ICosmicSignature *ICosmicSignatureSession) BalanceOf(owner common.Address) (*big.Int, error) {
	return _ICosmicSignature.Contract.BalanceOf(&_ICosmicSignature.CallOpts, owner)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256 balance)
func (_ICosmicSignature *ICosmicSignatureCallerSession) BalanceOf(owner common.Address) (*big.Int, error) {
	return _ICosmicSignature.Contract.BalanceOf(&_ICosmicSignature.CallOpts, owner)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address operator)
func (_ICosmicSignature *ICosmicSignatureCaller) GetApproved(opts *bind.CallOpts, tokenId *big.Int) (common.Address, error) {
	var out []interface{}
	err := _ICosmicSignature.contract.Call(opts, &out, "getApproved", tokenId)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address operator)
func (_ICosmicSignature *ICosmicSignatureSession) GetApproved(tokenId *big.Int) (common.Address, error) {
	return _ICosmicSignature.Contract.GetApproved(&_ICosmicSignature.CallOpts, tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address operator)
func (_ICosmicSignature *ICosmicSignatureCallerSession) GetApproved(tokenId *big.Int) (common.Address, error) {
	return _ICosmicSignature.Contract.GetApproved(&_ICosmicSignature.CallOpts, tokenId)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_ICosmicSignature *ICosmicSignatureCaller) IsApprovedForAll(opts *bind.CallOpts, owner common.Address, operator common.Address) (bool, error) {
	var out []interface{}
	err := _ICosmicSignature.contract.Call(opts, &out, "isApprovedForAll", owner, operator)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_ICosmicSignature *ICosmicSignatureSession) IsApprovedForAll(owner common.Address, operator common.Address) (bool, error) {
	return _ICosmicSignature.Contract.IsApprovedForAll(&_ICosmicSignature.CallOpts, owner, operator)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_ICosmicSignature *ICosmicSignatureCallerSession) IsApprovedForAll(owner common.Address, operator common.Address) (bool, error) {
	return _ICosmicSignature.Contract.IsApprovedForAll(&_ICosmicSignature.CallOpts, owner, operator)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address owner)
func (_ICosmicSignature *ICosmicSignatureCaller) OwnerOf(opts *bind.CallOpts, tokenId *big.Int) (common.Address, error) {
	var out []interface{}
	err := _ICosmicSignature.contract.Call(opts, &out, "ownerOf", tokenId)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address owner)
func (_ICosmicSignature *ICosmicSignatureSession) OwnerOf(tokenId *big.Int) (common.Address, error) {
	return _ICosmicSignature.Contract.OwnerOf(&_ICosmicSignature.CallOpts, tokenId)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address owner)
func (_ICosmicSignature *ICosmicSignatureCallerSession) OwnerOf(tokenId *big.Int) (common.Address, error) {
	return _ICosmicSignature.Contract.OwnerOf(&_ICosmicSignature.CallOpts, tokenId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_ICosmicSignature *ICosmicSignatureCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _ICosmicSignature.contract.Call(opts, &out, "supportsInterface", interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_ICosmicSignature *ICosmicSignatureSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _ICosmicSignature.Contract.SupportsInterface(&_ICosmicSignature.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_ICosmicSignature *ICosmicSignatureCallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _ICosmicSignature.Contract.SupportsInterface(&_ICosmicSignature.CallOpts, interfaceId)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 index) view returns(uint256)
func (_ICosmicSignature *ICosmicSignatureCaller) TokenByIndex(opts *bind.CallOpts, index *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _ICosmicSignature.contract.Call(opts, &out, "tokenByIndex", index)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 index) view returns(uint256)
func (_ICosmicSignature *ICosmicSignatureSession) TokenByIndex(index *big.Int) (*big.Int, error) {
	return _ICosmicSignature.Contract.TokenByIndex(&_ICosmicSignature.CallOpts, index)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 index) view returns(uint256)
func (_ICosmicSignature *ICosmicSignatureCallerSession) TokenByIndex(index *big.Int) (*big.Int, error) {
	return _ICosmicSignature.Contract.TokenByIndex(&_ICosmicSignature.CallOpts, index)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address owner, uint256 index) view returns(uint256)
func (_ICosmicSignature *ICosmicSignatureCaller) TokenOfOwnerByIndex(opts *bind.CallOpts, owner common.Address, index *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _ICosmicSignature.contract.Call(opts, &out, "tokenOfOwnerByIndex", owner, index)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address owner, uint256 index) view returns(uint256)
func (_ICosmicSignature *ICosmicSignatureSession) TokenOfOwnerByIndex(owner common.Address, index *big.Int) (*big.Int, error) {
	return _ICosmicSignature.Contract.TokenOfOwnerByIndex(&_ICosmicSignature.CallOpts, owner, index)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address owner, uint256 index) view returns(uint256)
func (_ICosmicSignature *ICosmicSignatureCallerSession) TokenOfOwnerByIndex(owner common.Address, index *big.Int) (*big.Int, error) {
	return _ICosmicSignature.Contract.TokenOfOwnerByIndex(&_ICosmicSignature.CallOpts, owner, index)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ICosmicSignature *ICosmicSignatureCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _ICosmicSignature.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ICosmicSignature *ICosmicSignatureSession) TotalSupply() (*big.Int, error) {
	return _ICosmicSignature.Contract.TotalSupply(&_ICosmicSignature.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ICosmicSignature *ICosmicSignatureCallerSession) TotalSupply() (*big.Int, error) {
	return _ICosmicSignature.Contract.TotalSupply(&_ICosmicSignature.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_ICosmicSignature *ICosmicSignatureTransactor) Approve(opts *bind.TransactOpts, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignature.contract.Transact(opts, "approve", to, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_ICosmicSignature *ICosmicSignatureSession) Approve(to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.Approve(&_ICosmicSignature.TransactOpts, to, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_ICosmicSignature *ICosmicSignatureTransactorSession) Approve(to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.Approve(&_ICosmicSignature.TransactOpts, to, tokenId)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address owner, uint256 roundNum) returns(uint256)
func (_ICosmicSignature *ICosmicSignatureTransactor) Mint(opts *bind.TransactOpts, owner common.Address, roundNum *big.Int) (*types.Transaction, error) {
	return _ICosmicSignature.contract.Transact(opts, "mint", owner, roundNum)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address owner, uint256 roundNum) returns(uint256)
func (_ICosmicSignature *ICosmicSignatureSession) Mint(owner common.Address, roundNum *big.Int) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.Mint(&_ICosmicSignature.TransactOpts, owner, roundNum)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address owner, uint256 roundNum) returns(uint256)
func (_ICosmicSignature *ICosmicSignatureTransactorSession) Mint(owner common.Address, roundNum *big.Int) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.Mint(&_ICosmicSignature.TransactOpts, owner, roundNum)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_ICosmicSignature *ICosmicSignatureTransactor) SafeTransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignature.contract.Transact(opts, "safeTransferFrom", from, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_ICosmicSignature *ICosmicSignatureSession) SafeTransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.SafeTransferFrom(&_ICosmicSignature.TransactOpts, from, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_ICosmicSignature *ICosmicSignatureTransactorSession) SafeTransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.SafeTransferFrom(&_ICosmicSignature.TransactOpts, from, to, tokenId)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_ICosmicSignature *ICosmicSignatureTransactor) SafeTransferFrom0(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _ICosmicSignature.contract.Transact(opts, "safeTransferFrom0", from, to, tokenId, data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_ICosmicSignature *ICosmicSignatureSession) SafeTransferFrom0(from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.SafeTransferFrom0(&_ICosmicSignature.TransactOpts, from, to, tokenId, data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_ICosmicSignature *ICosmicSignatureTransactorSession) SafeTransferFrom0(from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.SafeTransferFrom0(&_ICosmicSignature.TransactOpts, from, to, tokenId, data)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_ICosmicSignature *ICosmicSignatureTransactor) SetApprovalForAll(opts *bind.TransactOpts, operator common.Address, approved bool) (*types.Transaction, error) {
	return _ICosmicSignature.contract.Transact(opts, "setApprovalForAll", operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_ICosmicSignature *ICosmicSignatureSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.SetApprovalForAll(&_ICosmicSignature.TransactOpts, operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_ICosmicSignature *ICosmicSignatureTransactorSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.SetApprovalForAll(&_ICosmicSignature.TransactOpts, operator, approved)
}

// SetBaseURI is a paid mutator transaction binding the contract method 0x55f804b3.
//
// Solidity: function setBaseURI(string value) returns()
func (_ICosmicSignature *ICosmicSignatureTransactor) SetBaseURI(opts *bind.TransactOpts, value string) (*types.Transaction, error) {
	return _ICosmicSignature.contract.Transact(opts, "setBaseURI", value)
}

// SetBaseURI is a paid mutator transaction binding the contract method 0x55f804b3.
//
// Solidity: function setBaseURI(string value) returns()
func (_ICosmicSignature *ICosmicSignatureSession) SetBaseURI(value string) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.SetBaseURI(&_ICosmicSignature.TransactOpts, value)
}

// SetBaseURI is a paid mutator transaction binding the contract method 0x55f804b3.
//
// Solidity: function setBaseURI(string value) returns()
func (_ICosmicSignature *ICosmicSignatureTransactorSession) SetBaseURI(value string) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.SetBaseURI(&_ICosmicSignature.TransactOpts, value)
}

// SetTokenGenerationScriptURL is a paid mutator transaction binding the contract method 0x46519a18.
//
// Solidity: function setTokenGenerationScriptURL(string newTokenGenerationScriptURL) returns()
func (_ICosmicSignature *ICosmicSignatureTransactor) SetTokenGenerationScriptURL(opts *bind.TransactOpts, newTokenGenerationScriptURL string) (*types.Transaction, error) {
	return _ICosmicSignature.contract.Transact(opts, "setTokenGenerationScriptURL", newTokenGenerationScriptURL)
}

// SetTokenGenerationScriptURL is a paid mutator transaction binding the contract method 0x46519a18.
//
// Solidity: function setTokenGenerationScriptURL(string newTokenGenerationScriptURL) returns()
func (_ICosmicSignature *ICosmicSignatureSession) SetTokenGenerationScriptURL(newTokenGenerationScriptURL string) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.SetTokenGenerationScriptURL(&_ICosmicSignature.TransactOpts, newTokenGenerationScriptURL)
}

// SetTokenGenerationScriptURL is a paid mutator transaction binding the contract method 0x46519a18.
//
// Solidity: function setTokenGenerationScriptURL(string newTokenGenerationScriptURL) returns()
func (_ICosmicSignature *ICosmicSignatureTransactorSession) SetTokenGenerationScriptURL(newTokenGenerationScriptURL string) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.SetTokenGenerationScriptURL(&_ICosmicSignature.TransactOpts, newTokenGenerationScriptURL)
}

// SetTokenName is a paid mutator transaction binding the contract method 0xcdb0e89e.
//
// Solidity: function setTokenName(uint256 nftId, string name) returns()
func (_ICosmicSignature *ICosmicSignatureTransactor) SetTokenName(opts *bind.TransactOpts, nftId *big.Int, name string) (*types.Transaction, error) {
	return _ICosmicSignature.contract.Transact(opts, "setTokenName", nftId, name)
}

// SetTokenName is a paid mutator transaction binding the contract method 0xcdb0e89e.
//
// Solidity: function setTokenName(uint256 nftId, string name) returns()
func (_ICosmicSignature *ICosmicSignatureSession) SetTokenName(nftId *big.Int, name string) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.SetTokenName(&_ICosmicSignature.TransactOpts, nftId, name)
}

// SetTokenName is a paid mutator transaction binding the contract method 0xcdb0e89e.
//
// Solidity: function setTokenName(uint256 nftId, string name) returns()
func (_ICosmicSignature *ICosmicSignatureTransactorSession) SetTokenName(nftId *big.Int, name string) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.SetTokenName(&_ICosmicSignature.TransactOpts, nftId, name)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_ICosmicSignature *ICosmicSignatureTransactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignature.contract.Transact(opts, "transferFrom", from, to, tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_ICosmicSignature *ICosmicSignatureSession) TransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.TransferFrom(&_ICosmicSignature.TransactOpts, from, to, tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_ICosmicSignature *ICosmicSignatureTransactorSession) TransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _ICosmicSignature.Contract.TransferFrom(&_ICosmicSignature.TransactOpts, from, to, tokenId)
}

// ICosmicSignatureApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the ICosmicSignature contract.
type ICosmicSignatureApprovalIterator struct {
	Event *ICosmicSignatureApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureApproval represents a Approval event raised by the ICosmicSignature contract.
type ICosmicSignatureApproval struct {
	Owner    common.Address
	Approved common.Address
	TokenId  *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_ICosmicSignature *ICosmicSignatureFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, approved []common.Address, tokenId []*big.Int) (*ICosmicSignatureApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _ICosmicSignature.contract.FilterLogs(opts, "Approval", ownerRule, approvedRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureApprovalIterator{contract: _ICosmicSignature.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_ICosmicSignature *ICosmicSignatureFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureApproval, owner []common.Address, approved []common.Address, tokenId []*big.Int) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _ICosmicSignature.contract.WatchLogs(opts, "Approval", ownerRule, approvedRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureApproval)
				if err := _ICosmicSignature.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_ICosmicSignature *ICosmicSignatureFilterer) ParseApproval(log types.Log) (*ICosmicSignatureApproval, error) {
	event := new(ICosmicSignatureApproval)
	if err := _ICosmicSignature.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureApprovalForAllIterator is returned from FilterApprovalForAll and is used to iterate over the raw logs and unpacked data for ApprovalForAll events raised by the ICosmicSignature contract.
type ICosmicSignatureApprovalForAllIterator struct {
	Event *ICosmicSignatureApprovalForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureApprovalForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureApprovalForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureApprovalForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureApprovalForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureApprovalForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureApprovalForAll represents a ApprovalForAll event raised by the ICosmicSignature contract.
type ICosmicSignatureApprovalForAll struct {
	Owner    common.Address
	Operator common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApprovalForAll is a free log retrieval operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_ICosmicSignature *ICosmicSignatureFilterer) FilterApprovalForAll(opts *bind.FilterOpts, owner []common.Address, operator []common.Address) (*ICosmicSignatureApprovalForAllIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _ICosmicSignature.contract.FilterLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureApprovalForAllIterator{contract: _ICosmicSignature.contract, event: "ApprovalForAll", logs: logs, sub: sub}, nil
}

// WatchApprovalForAll is a free log subscription operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_ICosmicSignature *ICosmicSignatureFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureApprovalForAll, owner []common.Address, operator []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _ICosmicSignature.contract.WatchLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureApprovalForAll)
				if err := _ICosmicSignature.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApprovalForAll is a log parse operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_ICosmicSignature *ICosmicSignatureFilterer) ParseApprovalForAll(log types.Log) (*ICosmicSignatureApprovalForAll, error) {
	event := new(ICosmicSignatureApprovalForAll)
	if err := _ICosmicSignature.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureBaseURIEventIterator is returned from FilterBaseURIEvent and is used to iterate over the raw logs and unpacked data for BaseURIEvent events raised by the ICosmicSignature contract.
type ICosmicSignatureBaseURIEventIterator struct {
	Event *ICosmicSignatureBaseURIEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureBaseURIEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureBaseURIEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureBaseURIEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureBaseURIEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureBaseURIEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureBaseURIEvent represents a BaseURIEvent event raised by the ICosmicSignature contract.
type ICosmicSignatureBaseURIEvent struct {
	NewURI string
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterBaseURIEvent is a free log retrieval operation binding the contract event 0x2fc013f885e8a815b9d697da28bc143b4dced47528c41b46e2b35fd0f4be718c.
//
// Solidity: event BaseURIEvent(string newURI)
func (_ICosmicSignature *ICosmicSignatureFilterer) FilterBaseURIEvent(opts *bind.FilterOpts) (*ICosmicSignatureBaseURIEventIterator, error) {

	logs, sub, err := _ICosmicSignature.contract.FilterLogs(opts, "BaseURIEvent")
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureBaseURIEventIterator{contract: _ICosmicSignature.contract, event: "BaseURIEvent", logs: logs, sub: sub}, nil
}

// WatchBaseURIEvent is a free log subscription operation binding the contract event 0x2fc013f885e8a815b9d697da28bc143b4dced47528c41b46e2b35fd0f4be718c.
//
// Solidity: event BaseURIEvent(string newURI)
func (_ICosmicSignature *ICosmicSignatureFilterer) WatchBaseURIEvent(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureBaseURIEvent) (event.Subscription, error) {

	logs, sub, err := _ICosmicSignature.contract.WatchLogs(opts, "BaseURIEvent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureBaseURIEvent)
				if err := _ICosmicSignature.contract.UnpackLog(event, "BaseURIEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBaseURIEvent is a log parse operation binding the contract event 0x2fc013f885e8a815b9d697da28bc143b4dced47528c41b46e2b35fd0f4be718c.
//
// Solidity: event BaseURIEvent(string newURI)
func (_ICosmicSignature *ICosmicSignatureFilterer) ParseBaseURIEvent(log types.Log) (*ICosmicSignatureBaseURIEvent, error) {
	event := new(ICosmicSignatureBaseURIEvent)
	if err := _ICosmicSignature.contract.UnpackLog(event, "BaseURIEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureMintEventIterator is returned from FilterMintEvent and is used to iterate over the raw logs and unpacked data for MintEvent events raised by the ICosmicSignature contract.
type ICosmicSignatureMintEventIterator struct {
	Event *ICosmicSignatureMintEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureMintEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureMintEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureMintEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureMintEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureMintEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureMintEvent represents a MintEvent event raised by the ICosmicSignature contract.
type ICosmicSignatureMintEvent struct {
	NftId    *big.Int
	Owner    common.Address
	RoundNum *big.Int
	Seed     [32]byte
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterMintEvent is a free log retrieval operation binding the contract event 0xc646da88dc2b2526461a0ebb4326e2418ec0bea89496b632b7c9ee42fbfe1d4d.
//
// Solidity: event MintEvent(uint256 indexed nftId, address indexed owner, uint256 indexed roundNum, bytes32 seed)
func (_ICosmicSignature *ICosmicSignatureFilterer) FilterMintEvent(opts *bind.FilterOpts, nftId []*big.Int, owner []common.Address, roundNum []*big.Int) (*ICosmicSignatureMintEventIterator, error) {

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}
	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var roundNumRule []interface{}
	for _, roundNumItem := range roundNum {
		roundNumRule = append(roundNumRule, roundNumItem)
	}

	logs, sub, err := _ICosmicSignature.contract.FilterLogs(opts, "MintEvent", nftIdRule, ownerRule, roundNumRule)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureMintEventIterator{contract: _ICosmicSignature.contract, event: "MintEvent", logs: logs, sub: sub}, nil
}

// WatchMintEvent is a free log subscription operation binding the contract event 0xc646da88dc2b2526461a0ebb4326e2418ec0bea89496b632b7c9ee42fbfe1d4d.
//
// Solidity: event MintEvent(uint256 indexed nftId, address indexed owner, uint256 indexed roundNum, bytes32 seed)
func (_ICosmicSignature *ICosmicSignatureFilterer) WatchMintEvent(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureMintEvent, nftId []*big.Int, owner []common.Address, roundNum []*big.Int) (event.Subscription, error) {

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}
	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var roundNumRule []interface{}
	for _, roundNumItem := range roundNum {
		roundNumRule = append(roundNumRule, roundNumItem)
	}

	logs, sub, err := _ICosmicSignature.contract.WatchLogs(opts, "MintEvent", nftIdRule, ownerRule, roundNumRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureMintEvent)
				if err := _ICosmicSignature.contract.UnpackLog(event, "MintEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMintEvent is a log parse operation binding the contract event 0xc646da88dc2b2526461a0ebb4326e2418ec0bea89496b632b7c9ee42fbfe1d4d.
//
// Solidity: event MintEvent(uint256 indexed nftId, address indexed owner, uint256 indexed roundNum, bytes32 seed)
func (_ICosmicSignature *ICosmicSignatureFilterer) ParseMintEvent(log types.Log) (*ICosmicSignatureMintEvent, error) {
	event := new(ICosmicSignatureMintEvent)
	if err := _ICosmicSignature.contract.UnpackLog(event, "MintEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureTokenGenerationScriptURLEventIterator is returned from FilterTokenGenerationScriptURLEvent and is used to iterate over the raw logs and unpacked data for TokenGenerationScriptURLEvent events raised by the ICosmicSignature contract.
type ICosmicSignatureTokenGenerationScriptURLEventIterator struct {
	Event *ICosmicSignatureTokenGenerationScriptURLEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureTokenGenerationScriptURLEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureTokenGenerationScriptURLEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureTokenGenerationScriptURLEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureTokenGenerationScriptURLEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureTokenGenerationScriptURLEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureTokenGenerationScriptURLEvent represents a TokenGenerationScriptURLEvent event raised by the ICosmicSignature contract.
type ICosmicSignatureTokenGenerationScriptURLEvent struct {
	NewURL string
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterTokenGenerationScriptURLEvent is a free log retrieval operation binding the contract event 0x0119741ee0f95fab26124262a82c3c0e9e1c7ff4bb33c6fba5f3b11c9b6d0bad.
//
// Solidity: event TokenGenerationScriptURLEvent(string newURL)
func (_ICosmicSignature *ICosmicSignatureFilterer) FilterTokenGenerationScriptURLEvent(opts *bind.FilterOpts) (*ICosmicSignatureTokenGenerationScriptURLEventIterator, error) {

	logs, sub, err := _ICosmicSignature.contract.FilterLogs(opts, "TokenGenerationScriptURLEvent")
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureTokenGenerationScriptURLEventIterator{contract: _ICosmicSignature.contract, event: "TokenGenerationScriptURLEvent", logs: logs, sub: sub}, nil
}

// WatchTokenGenerationScriptURLEvent is a free log subscription operation binding the contract event 0x0119741ee0f95fab26124262a82c3c0e9e1c7ff4bb33c6fba5f3b11c9b6d0bad.
//
// Solidity: event TokenGenerationScriptURLEvent(string newURL)
func (_ICosmicSignature *ICosmicSignatureFilterer) WatchTokenGenerationScriptURLEvent(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureTokenGenerationScriptURLEvent) (event.Subscription, error) {

	logs, sub, err := _ICosmicSignature.contract.WatchLogs(opts, "TokenGenerationScriptURLEvent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureTokenGenerationScriptURLEvent)
				if err := _ICosmicSignature.contract.UnpackLog(event, "TokenGenerationScriptURLEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTokenGenerationScriptURLEvent is a log parse operation binding the contract event 0x0119741ee0f95fab26124262a82c3c0e9e1c7ff4bb33c6fba5f3b11c9b6d0bad.
//
// Solidity: event TokenGenerationScriptURLEvent(string newURL)
func (_ICosmicSignature *ICosmicSignatureFilterer) ParseTokenGenerationScriptURLEvent(log types.Log) (*ICosmicSignatureTokenGenerationScriptURLEvent, error) {
	event := new(ICosmicSignatureTokenGenerationScriptURLEvent)
	if err := _ICosmicSignature.contract.UnpackLog(event, "TokenGenerationScriptURLEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureTokenNameEventIterator is returned from FilterTokenNameEvent and is used to iterate over the raw logs and unpacked data for TokenNameEvent events raised by the ICosmicSignature contract.
type ICosmicSignatureTokenNameEventIterator struct {
	Event *ICosmicSignatureTokenNameEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureTokenNameEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureTokenNameEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureTokenNameEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureTokenNameEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureTokenNameEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureTokenNameEvent represents a TokenNameEvent event raised by the ICosmicSignature contract.
type ICosmicSignatureTokenNameEvent struct {
	NftId   *big.Int
	NewName string
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterTokenNameEvent is a free log retrieval operation binding the contract event 0x8ad5e159ff95649c8a9f323ac5a457e741897cf44ce07dfce0e98b84ef9d5f12.
//
// Solidity: event TokenNameEvent(uint256 indexed nftId, string newName)
func (_ICosmicSignature *ICosmicSignatureFilterer) FilterTokenNameEvent(opts *bind.FilterOpts, nftId []*big.Int) (*ICosmicSignatureTokenNameEventIterator, error) {

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}

	logs, sub, err := _ICosmicSignature.contract.FilterLogs(opts, "TokenNameEvent", nftIdRule)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureTokenNameEventIterator{contract: _ICosmicSignature.contract, event: "TokenNameEvent", logs: logs, sub: sub}, nil
}

// WatchTokenNameEvent is a free log subscription operation binding the contract event 0x8ad5e159ff95649c8a9f323ac5a457e741897cf44ce07dfce0e98b84ef9d5f12.
//
// Solidity: event TokenNameEvent(uint256 indexed nftId, string newName)
func (_ICosmicSignature *ICosmicSignatureFilterer) WatchTokenNameEvent(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureTokenNameEvent, nftId []*big.Int) (event.Subscription, error) {

	var nftIdRule []interface{}
	for _, nftIdItem := range nftId {
		nftIdRule = append(nftIdRule, nftIdItem)
	}

	logs, sub, err := _ICosmicSignature.contract.WatchLogs(opts, "TokenNameEvent", nftIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureTokenNameEvent)
				if err := _ICosmicSignature.contract.UnpackLog(event, "TokenNameEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTokenNameEvent is a log parse operation binding the contract event 0x8ad5e159ff95649c8a9f323ac5a457e741897cf44ce07dfce0e98b84ef9d5f12.
//
// Solidity: event TokenNameEvent(uint256 indexed nftId, string newName)
func (_ICosmicSignature *ICosmicSignatureFilterer) ParseTokenNameEvent(log types.Log) (*ICosmicSignatureTokenNameEvent, error) {
	event := new(ICosmicSignatureTokenNameEvent)
	if err := _ICosmicSignature.contract.UnpackLog(event, "TokenNameEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ICosmicSignatureTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the ICosmicSignature contract.
type ICosmicSignatureTransferIterator struct {
	Event *ICosmicSignatureTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ICosmicSignatureTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ICosmicSignatureTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ICosmicSignatureTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ICosmicSignatureTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ICosmicSignatureTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ICosmicSignatureTransfer represents a Transfer event raised by the ICosmicSignature contract.
type ICosmicSignatureTransfer struct {
	From    common.Address
	To      common.Address
	TokenId *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_ICosmicSignature *ICosmicSignatureFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenId []*big.Int) (*ICosmicSignatureTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _ICosmicSignature.contract.FilterLogs(opts, "Transfer", fromRule, toRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &ICosmicSignatureTransferIterator{contract: _ICosmicSignature.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_ICosmicSignature *ICosmicSignatureFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *ICosmicSignatureTransfer, from []common.Address, to []common.Address, tokenId []*big.Int) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _ICosmicSignature.contract.WatchLogs(opts, "Transfer", fromRule, toRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ICosmicSignatureTransfer)
				if err := _ICosmicSignature.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_ICosmicSignature *ICosmicSignatureFilterer) ParseTransfer(log types.Log) (*ICosmicSignatureTransfer, error) {
	event := new(ICosmicSignatureTransfer)
	if err := _ICosmicSignature.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
